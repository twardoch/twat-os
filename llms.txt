This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-06-25 10:56:19

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
cleanup.py
src
  twat_os
    __init__.py
    paths.toml
    paths.py
pyproject.toml
TODO.md
VERSION.txt
LOG.md
tests
  test_package.py
.github
  workflows
    release.yml
    push.yml
.cursor
  rules
    cleanup.mdc
    0project.mdc
    filetree.mdc
    quality.mdc
README.md
LICENSE
CHANGELOG.md
.gitignore
.pre-commit-config.yaml
REPO_CONTENT.txt
CLEANUP.txt
llms.txt
```

# Repository Files


## cleanup.py

```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = [
#   "ruff>=0.9.6",
#   "pytest>=8.3.4",
#   "mypy>=1.15.0",
# ]
# ///
# this_file: cleanup.py

"""
Cleanup tool for managing repository tasks and maintaining code quality.

This script provides a comprehensive set of commands for repository maintenance:

When to use each command:

- `cleanup.py status`: Use this FIRST when starting work to check the current state
  of the repository. It shows file structure, git status, and runs all code quality
  checks. Run this before making any changes to ensure you're starting from a clean state.

- `cleanup.py venv`: Run this when setting up the project for the first time or if
  your virtual environment is corrupted/missing. Creates a new virtual environment
  using uv.

- `cleanup.py install`: Use after `venv` or when dependencies have changed. Installs
  the package and all development dependencies in editable mode.

- `cleanup.py update`: Run this when you've made changes and want to commit them.
  It will:
  1. Show current status (like `status` command)
  2. Stage and commit any changes with a generic message
  Use this for routine maintenance commits.

- `cleanup.py push`: Run this after `update` when you want to push your committed
  changes to the remote repository.

Workflow Example:
1. Start work: `cleanup.py status`
2. Make changes to code
3. Commit changes: `cleanup.py update`
4. Push to remote: `cleanup.py push`

The script maintains a CLEANUP.txt file that records all operations with timestamps.
It also includes content from README.md at the start and TODO.md at the end of logs
for context.

Required Files:
- LOG.md: Project changelog
- README.md: Project documentation
- TODO.md: Pending tasks and future plans
"""

import subprocess
import os
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import NoReturn
from shutil import which

# Configuration
IGNORE_PATTERNS = [
    ".git",
    ".venv",
    "__pycache__",
    "*.pyc",
    "dist",
    "build",
    "*.egg-info",
]
REQUIRED_FILES = ["LOG.md", ".cursor/rules/0project.mdc", "TODO.md"]
LOG_FILE = Path("CLEANUP.txt")

# Ensure we're working from the script's directory
os.chdir(Path(__file__).parent)


def new() -> None:
    """Remove existing log file."""
    if LOG_FILE.exists():
        LOG_FILE.unlink()


def prefix() -> None:
    """Write README.md content to log file."""
    readme = Path(".cursor/rules/0project.mdc")
    if readme.exists():
        log_message("\n=== PROJECT STATEMENT ===")
        content = readme.read_text()
        log_message(content)


def suffix() -> None:
    """Write TODO.md content to log file."""
    todo = Path("TODO.md")
    if todo.exists():
        log_message("\n=== TODO.md ===")
        content = todo.read_text()
        log_message(content)


def log_message(message: str) -> None:
    """Log a message to file and console with timestamp."""
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
    log_line = f"{timestamp} - {message}\n"
    with LOG_FILE.open("a") as f:
        f.write(log_line)


def run_command(cmd: list[str], check: bool = True) -> subprocess.CompletedProcess:
    """Run a shell command and return the result."""
    try:
        result = subprocess.run(
            cmd,
            check=check,
            capture_output=True,
            text=True,
            shell=False,  # Explicitly set shell=False for security
        )
        if result.stdout:
            log_message(result.stdout)
        return result
    except subprocess.CalledProcessError as e:
        log_message(f"Command failed: {' '.join(cmd)}")
        log_message(f"Error: {e.stderr}")
        if check:
            raise
        return subprocess.CompletedProcess(cmd, 1, "", str(e))


def check_command_exists(cmd: str) -> bool:
    """Check if a command exists in the system."""
    try:
        return which(cmd) is not None
    except Exception:
        return False


class Cleanup:
    """Main cleanup tool class."""

    def __init__(self) -> None:
        self.workspace = Path.cwd()

    def _print_header(self, message: str) -> None:
        """Print a section header."""
        log_message(f"\n=== {message} ===")

    def _check_required_files(self) -> bool:
        """Check if all required files exist."""
        missing = False
        for file in REQUIRED_FILES:
            if not (self.workspace / file).exists():
                log_message(f"Error: {file} is missing")
                missing = True
        return not missing

    def _generate_tree(self) -> None:
        """Generate and display tree structure of the project."""
        if not check_command_exists("tree"):
            log_message("Warning: 'tree' command not found. Skipping tree generation.")
            return

        try:
            # Create/overwrite the file with YAML frontmatter
            rules_dir = Path(".cursor/rules")
            rules_dir.mkdir(parents=True, exist_ok=True)
            # Get tree output
            tree_result = run_command(["tree", "-a", "-I", ".git", "--gitignore", "-n", "-h", "-I", "*_cache"])
            tree_text = tree_result.stdout
            # Write frontmatter and tree output to file
            with open(rules_dir / "filetree.mdc", "w") as f:
                f.write("---\ndescription: File tree of the project\nglobs: \n---\n")
                f.write(tree_text)

            # Log the contents
            log_message("\nProject structure:")
            log_message(tree_text)

        except Exception as e:
            log_message(f"Failed to generate tree: {e}")
        return

    def _git_status(self) -> bool:
        """Check git status and return True if there are changes."""
        result = run_command(["git", "status", "--porcelain"], check=False)
        return bool(result.stdout.strip())

    def _venv(self) -> None:
        """Create and activate virtual environment using uv."""
        log_message("Setting up virtual environment")
        try:
            run_command(["uv", "venv"])
            # Activate the virtual environment
            venv_path = self.workspace / ".venv" / "bin" / "activate"
            if venv_path.exists():
                os.environ["VIRTUAL_ENV"] = str(self.workspace / ".venv")
                os.environ["PATH"] = f"{self.workspace / '.venv' / 'bin'}{os.pathsep}{os.environ['PATH']}"
                log_message("Virtual environment created and activated")
            else:
                log_message("Virtual environment created but activation failed")
        except Exception as e:
            log_message(f"Failed to create virtual environment: {e}")

    def _install(self) -> None:
        """Install package in development mode with all extras."""
        log_message("Installing package with all extras")
        try:
            self._venv()
            run_command(["uv", "pip", "install", "-e", ".[test,dev]"])
            log_message("Package installed successfully")
        except Exception as e:
            log_message(f"Failed to install package: {e}")

    def _run_checks(self) -> None:
        """Run code quality checks using ruff and pytest."""
        log_message("Running code quality checks")

        try:
            # Run ruff checks
            log_message(">>> Running code fixes...")
            run_command(
                [
                    "python",
                    "-m",
                    "ruff",
                    "check",
                    "--fix",
                    "--unsafe-fixes",
                    "src",
                    "tests",
                ],
                check=False,
            )
            run_command(
                [
                    "python",
                    "-m",
                    "ruff",
                    "format",
                    "--respect-gitignore",
                    "src",
                    "tests",
                ],
                check=False,
            )

            # Run type checks
            log_message(">>>Running type checks...")
            run_command(["python", "-m", "mypy", "src", "tests"], check=False)

            # Run tests
            log_message(">>> Running tests...")
            run_command(["python", "-m", "pytest", "tests"], check=False)

            log_message("All checks completed")
        except Exception as e:
            log_message(f"Failed during checks: {e}")

    def status(self) -> None:
        """Show current repository status: tree structure, git status, and run checks."""
        prefix()  # Add README.md content at start
        self._print_header("Current Status")

        # Check required files
        self._check_required_files()

        # Show tree structure
        self._generate_tree()

        # Show git status
        result = run_command(["git", "status"], check=False)
        log_message(result.stdout)

        # Run additional checks
        self._print_header("Environment Status")
        self._venv()
        self._install()
        self._run_checks()

        suffix()  # Add TODO.md content at end

    def venv(self) -> None:
        """Create and activate virtual environment."""
        self._print_header("Virtual Environment Setup")
        self._venv()

    def install(self) -> None:
        """Install package with all extras."""
        self._print_header("Package Installation")
        self._install()

    def update(self) -> None:
        """Show status and commit any changes if needed."""
        # First show current status
        self.status()

        # Then handle git changes if any
        if self._git_status():
            log_message("Changes detected in repository")
            try:
                # Add all changes
                run_command(["git", "add", "."])
                # Commit changes
                commit_msg = "Update repository files"
                run_command(["git", "commit", "-m", commit_msg])
                log_message("Changes committed successfully")
            except Exception as e:
                log_message(f"Failed to commit changes: {e}")
        else:
            log_message("No changes to commit")

    def push(self) -> None:
        """Push changes to remote repository."""
        self._print_header("Pushing Changes")
        try:
            run_command(["git", "push"])
            log_message("Changes pushed successfully")
        except Exception as e:
            log_message(f"Failed to push changes: {e}")


def print_usage() -> None:
    """Print usage information."""
    log_message("Usage:")
    log_message("  cleanup.py status   # Show current status and run all checks")
    log_message("  cleanup.py venv     # Create virtual environment")
    log_message("  cleanup.py install  # Install package with all extras")
    log_message("  cleanup.py update   # Update and commit changes")
    log_message("  cleanup.py push     # Push changes to remote")


def main() -> NoReturn:
    """Main entry point."""
    new()  # Clear log file

    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)

    command = sys.argv[1]
    cleanup = Cleanup()

    try:
        if command == "status":
            cleanup.status()
        elif command == "venv":
            cleanup.venv()
        elif command == "install":
            cleanup.install()
        elif command == "update":
            cleanup.update()
        elif command == "push":
            cleanup.push()
        else:
            print_usage()
    except Exception as e:
        log_message(f"Error: {e}")
    # Call the system-installed repomix to generate llms.txt
    run_command(["repomix", "-o", "llms.txt", "."])
    log_message("Repository content mixed into llms.txt by system repomix call.")
    sys.stdout.write(Path("CLEANUP.txt").read_text())
    sys.exit(0)  # Ensure we exit with a status code


if __name__ == "__main__":
    main()
```

## src/twat_os/__init__.py

```python
"""twat os plugin"""

from importlib import metadata

__version__ = metadata.version(__name__)
```

## src/twat_os/paths.toml

```text
[cache]
# Base directory for all cache operations
base_dir = "~/.cache/twat"
# Directory for storing package-specific cache data
package_dir = "~/.cache/twat/{package_name}"

[config]
# Base directory for configuration files
base_dir = "~/.config/twat"
# Directory for package-specific configuration
package_dir = "~/.config/twat/{package_name}"

[data]
# Base directory for user data
base_dir = "~/.local/share/twat"
# Directory for package-specific data
package_dir = "~/.local/share/twat/{package_name}"

[temp]
# Base directory for temporary files
base_dir = "~/tmp/twat"
# Directory for package-specific temporary files
package_dir = "~/tmp/twat/{package_name}"

[genai]
# Directory for storing LoRA files
lora_dir = "~/.local/share/twat/genai/loras"
# Directory for model weights
model_dir = "~/.local/share/twat/genai/models"
# Directory for generated images
output_dir = "~/Pictures/twat_genai"

[logs]
# Base directory for log files
base_dir = "~/.local/state/twat/logs"
# Directory for package-specific logs
package_dir = "~/.local/state/twat/logs/{package_name}"
```

## src/twat_os/paths.py

```python
#!/usr/bin/env -S uv run
# /// script
# dependencies = ["pydantic", "platformdirs"]
# ///
"""Path management for twat packages.

This module provides a centralized way to manage paths for various twat packages.
It handles path resolution, validation, and creation of directories as needed.
"""

from __future__ import annotations

import os
from pathlib import Path
from typing import TYPE_CHECKING, cast

import platformdirs
import tomli
from pydantic import BaseModel, Field, field_validator, model_validator

if TYPE_CHECKING:
    from typing_extensions import Self

# Load default paths from TOML
PATHS_TOML = Path(__file__).parent / "paths.toml"
DEFAULT_PATHS = tomli.loads(PATHS_TOML.read_text())


class PathConfig(BaseModel):
    """Base configuration for path settings."""

    base_dir: Path
    package_dir: Path | None = None
    create_if_missing: bool = True

    @field_validator("base_dir", "package_dir")
    @classmethod
    def expand_path(cls, v: str | Path | None) -> Path | None:
        """Expand user and environment variables in paths."""
        if v is None:
            return None
        if isinstance(v, str):
            # Expand both ~ and environment variables
            expanded_user = Path(v).expanduser()
            expanded_vars = os.path.expandvars(str(expanded_user))
            return Path(expanded_vars)
        return v

    @model_validator(mode="after")
    def validate_and_create_dirs(self) -> Self:
        """Create directories if they don't exist and creation is enabled."""
        if self.create_if_missing:
            self.base_dir.mkdir(parents=True, exist_ok=True)
            if self.package_dir:
                self.package_dir.mkdir(parents=True, exist_ok=True)
        return self


class CacheConfig(PathConfig):
    """Configuration for cache directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_cache_dir()) / "twat"
    )


class ConfigDirConfig(PathConfig):
    """Configuration for config directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_config_dir()) / "twat"
    )


class DataDirConfig(PathConfig):
    """Configuration for data directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat"
    )


class TempDirConfig(PathConfig):
    """Configuration for temporary directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_runtime_dir()) / "twat"
    )


class GenAIConfig(PathConfig):
    """Configuration for GenAI-specific paths."""

    lora_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/loras"
    )
    model_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/models"
    )
    output_dir: Path = Field(
        default_factory=lambda: Path.home() / "Pictures/twat_genai"
    )

    @model_validator(mode="after")
    def validate_and_create_all_dirs(self) -> Self:
        """Create all GenAI directories if enabled."""
        if self.create_if_missing:
            self.base_dir.mkdir(parents=True, exist_ok=True)
            self.lora_dir.mkdir(parents=True, exist_ok=True)
            self.model_dir.mkdir(parents=True, exist_ok=True)
            self.output_dir.mkdir(parents=True, exist_ok=True)
        return self


class LogConfig(PathConfig):
    """Configuration for log directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_state_dir()) / "twat/logs"
    )


class PathManager:
    """Central manager for all path configurations."""

    def __init__(
        self,
        package_name: str | None = None,
        config_file: str | Path | None = None,
        *,
        create_dirs: bool = True,
    ) -> None:
        """Initialize path manager.

        Args:
            package_name: Optional package name for package-specific paths
            config_file: Optional path to custom config file
            create_dirs: Whether to create directories if they don't exist
        """
        self.package_name = package_name
        self.create_dirs = create_dirs

        # Load config
        if config_file:
            config_path = Path(config_file)
            if not config_path.exists():
                msg = f"Config file not found: {config_file}"
                raise FileNotFoundError(msg)
            self.config = tomli.loads(config_path.read_text())
        else:
            self.config = DEFAULT_PATHS

        # Initialize path configurations
        self._init_paths()

    def _init_paths(self) -> None:
        """Initialize all path configurations."""

        # Helper to format package-specific paths
        def format_path(path_str: str) -> Path | None:
            if not self.package_name:
                return None
            expanded_user = Path(path_str).expanduser()
            expanded_vars = os.path.expandvars(str(expanded_user))
            return Path(expanded_vars.format(package_name=self.package_name))

        # Initialize configurations
        self.cache = CacheConfig(
            base_dir=self.config["cache"]["base_dir"],
            package_dir=format_path(self.config["cache"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.config_dir = ConfigDirConfig(
            base_dir=self.config["config"]["base_dir"],
            package_dir=format_path(self.config["config"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.data = DataDirConfig(
            base_dir=self.config["data"]["base_dir"],
            package_dir=format_path(self.config["data"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.temp = TempDirConfig(
            base_dir=self.config["temp"]["base_dir"],
            package_dir=format_path(self.config["temp"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.genai = GenAIConfig(
            base_dir=self.config["data"]["base_dir"],
            lora_dir=self.config["genai"]["lora_dir"],
            model_dir=self.config["genai"]["model_dir"],
            output_dir=self.config["genai"]["output_dir"],
            create_if_missing=self.create_dirs,
        )

        self.logs = LogConfig(
            base_dir=self.config["logs"]["base_dir"],
            package_dir=format_path(self.config["logs"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

    def get_path(self, category: str, key: str = "base_dir") -> Path:
        """Get a specific path by category and key.

        Args:
            category: Path category (cache, config, data, temp, genai, logs)
            key: Path key within the category (base_dir, package_dir, etc.)

        Returns:
            Resolved path

        Raises:
            AttributeError: If category or key doesn't exist
        """
        config = getattr(self, category)
        path_value = getattr(config, key)
        if not isinstance(path_value, Path):
            # This case should ideally not happen if Pydantic models are correct
            # and keys always point to Path objects or None (for package_dir sometimes).
            # However, to satisfy type checker for dynamic getattr:
            if path_value is None and key == "package_dir":  # package_dir can be None
                # This function is typed to return Path, so None is not allowed here.
                # This indicates a potential design issue or misuse of get_path for optional paths.
                # For now, raising an error is safer than returning None.
                msg = (
                    f"Path for '{category}.{key}' is None, but Path type was expected."
                )
                raise ValueError(msg)
            msg = f"Unexpected type for '{category}.{key}': {type(path_value)}. Expected Path."
            raise TypeError(msg)
        return path_value  # Cast is redundant due to isinstance check

    @classmethod
    def for_package(
        cls, package_name: str, config_file: str | Path | None = None
    ) -> PathManager:
        """Create a PathManager instance for a specific package.

        Args:
            package_name: Package name
            config_file: Optional path to custom config file

        Returns:
            PathManager instance configured for the package
        """
        return cls(package_name=package_name, config_file=config_file)

    def __repr__(self) -> str:
        """Return string representation of PathManager."""
        package_info = (
            f" for package '{self.package_name}'" if self.package_name else ""
        )
        return f"PathManager{package_info}"
```

## pyproject.toml

```text
#==============================================================================
# TWAT_OS PACKAGE CONFIGURATION
# This pyproject.toml defines the package metadata, dependencies, build system,
# and development environment for the twat-os package, which provides operating
# system utilities for the twat framework.
#==============================================================================

#------------------------------------------------------------------------------
# PROJECT METADATA
# Core package information used by PyPI and package managers.
#------------------------------------------------------------------------------
[project]
name = "twat-os" # Package name on PyPI
dynamic = ["version"] # Fields set dynamically at build time
description = "Operating system utilities for twat" # Short description
readme = "README.md" # Path to README file
requires-python = ">=3.10" # Minimum Python version
license = "MIT" # License type

# Keywords for PyPI search
keywords = [
    "os",
    "system",
    "twat",
    "utilities",
    "operating-system",
]

# PyPI classifiers for package categorization
classifiers = [
    "Development Status :: 4 - Beta", # Package maturity level
    "Programming Language :: Python",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
    "Operating System :: OS Independent",
    "License :: OSI Approved :: MIT License",
    "Intended Audience :: Developers",
]

# Core dependencies
dependencies = [
    "fire>=0.6.0",      # CLI framework
    "loguru>=0.7.2",    # Structured logging
    "twat>=1.8.1",       # Core twat package
    "pydantic>=2.0",    # Data validation and settings management
    "platformdirs>=3.0.0" # Platform-specific user directories
]

#------------------------------------------------------------------------------
# OPTIONAL DEPENDENCIES
# Additional dependencies for optional features, development, and testing.
#------------------------------------------------------------------------------
[project.optional-dependencies]

# Development tools
dev = [
    "hatch>=1.14.0",         # Build tool
    "hatchling>=1.27.0",     # Build backend
    "hatch-vcs>=0.4.0",      # Version control integration
    "mypy>=1.15.0",          # Type checking
    "pre-commit>=4.1.0",     # Pre-commit hooks
    "pyupgrade>=3.19.1",     # Python syntax upgrader
    "ruff>=0.9.7",           # Linting and formatting
    "absolufy-imports>=0.3.1", # Absolute imports
    "isort>=6.0.1",           # Import sorting
    "typing-extensions>=4.0.0" # For Self type hint and other backports
]

# Testing tools
test = [
    "pytest>=8.3.4",           # Testing framework
    "pytest-cov>=6.0.0",       # Coverage reporting
    "pytest-xdist>=3.6.1",     # Parallel testing
    "pytest-benchmark[histogram]>=5.1.0",  # Benchmarking with histogram
    "pytest-mock>=3.14.0",     # Mocking
    "pytest-asyncio>=0.25.3",  # Async testing
    "pytest-timeout>=2.3.1",   # Test timeouts
    "coverage[toml]>=7.6.12"   # Coverage with TOML support
]

# Documentation tools
docs = [
    "sphinx>=7.2.6",
    "sphinx-rtd-theme>=2.0.0",
    "sphinx-autodoc-typehints>=2.0.0",
    "myst-parser>=3.0.0", # Markdown support in Sphinx
]

#------------------------------------------------------------------------------
# COMMAND-LINE SCRIPTS
# Entry points for command-line executables installed with the package.
#------------------------------------------------------------------------------
[project.scripts]
twat-os = "twat_os.__main__:main"

[project.entry-points."twat.plugins"]
os = "twat_os"

# Author information
[[project.authors]]
name = "Adam Twardoch"
email = "adam+github@twardoch.com"

# Project URLs
[project.urls]
Documentation = "https://github.com/twardoch/twat-os#readme"
Issues = "https://github.com/twardoch/twat-os/issues"
Source = "https://github.com/twardoch/twat-os"

#------------------------------------------------------------------------------
# BUILD SYSTEM CONFIGURATION
# Defines the tools required to build the package.
#------------------------------------------------------------------------------
[build-system]
build-backend = "hatchling.build"
requires = [
    "hatchling>=1.27.0",
    "hatch-vcs>=0.4.0"
]

#------------------------------------------------------------------------------
# COVERAGE CONFIGURATION
# Settings for test coverage measurement and reporting.
#------------------------------------------------------------------------------
[tool.coverage.paths]
twat_os = ["src/twat_os", "*/twat-os/src/twat_os"]
tests = ["tests", "*/twat-os/tests"]

[tool.coverage.report]
exclude_lines = [
    "no cov",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:"
]

[tool.coverage.run]
source_pkgs = ["twat_os", "tests"]
branch = true
parallel = true
omit = ["src/twat_os/__about__.py"]

#------------------------------------------------------------------------------
# HATCH BUILD CONFIGURATION
# Configures the build process and development environments.
#------------------------------------------------------------------------------
[tool.hatch.build.hooks.vcs]
version-file = "src/twat_os/__version__.py"

[tool.hatch.build.targets.wheel]
packages = ["src/twat_os"]
include = [
    "src/twat_os/**/*.py",
    "src/twat_os/py.typed"
]
reproducible = true

[tool.hatch.envs.default]
features = ["dev", "test"]

[tool.hatch.envs.default.scripts]
test = "pytest {args:tests}"
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
type-check = "mypy src/twat_os tests"
lint = ["ruff check src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]
fix = ["ruff check --fix --unsafe-fixes src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]

[[tool.hatch.envs.all.matrix]]
python = ["3.10", "3.11", "3.12"]

[tool.hatch.envs.lint]
detached = true
features = ["dev"]

[tool.hatch.envs.lint.scripts]
typing = "mypy --install-types --non-interactive {args:src/twat_os tests}"
style = ["ruff check {args:.}", "ruff format --respect-gitignore {args:.}"]
fmt = ["ruff format --respect-gitignore {args:.}", "ruff check --fix {args:.}"]
all = ["style", "typing"]

[tool.hatch.envs.test]
features = ["test"]

[tool.hatch.envs.test.scripts]
test = "python -m pytest -n auto -p no:briefcase {args:tests}"
test-cov = "python -m pytest -n auto -p no:briefcase --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
bench = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only"
bench-save = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only --benchmark-json=benchmark/results.json"

# Documentation environment
[tool.hatch.envs.docs]
features = ["docs"]

# Documentation environment commands
[tool.hatch.envs.docs.scripts]
build = "sphinx-build -b html docs/source docs/build"

# GitHub Actions workflow configuration
[tool.hatch.envs.ci]
features = ["test"]

[tool.hatch.envs.ci.scripts]
test = "pytest --cov=src/twat_os --cov-report=xml"

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
version_scheme = "post-release"

#------------------------------------------------------------------------------
# MYPY CONFIGURATION
# Configuration for type checking with mypy.
#------------------------------------------------------------------------------
[tool.mypy]
python_version = "3.10"
check_untyped_defs = true
disallow_incomplete_defs = true
disallow_untyped_decorators = true
disallow_untyped_defs = true
no_implicit_optional = true
warn_no_return = true
warn_redundant_casts = true
warn_return_any = true
warn_unreachable = true
warn_unused_configs = true
warn_unused_ignores = true

#------------------------------------------------------------------------------
# RUFF CONFIGURATION
# Configuration for Ruff linting and formatting.
#------------------------------------------------------------------------------
[tool.ruff]
line-length = 88
target-version = "py310"

[tool.ruff.lint]
extend-select = [
    "A",     # flake8-builtins
    "ARG",   # flake8-unused-arguments
    "ASYNC", # flake8-async
    "B",     # flake8-bugbear
    "C",     # flake8-comprehensions
    "DTZ",   # flake8-datetimez
    "E",     # pycodestyle errors
    "EM",    # flake8-errmsg
    "F",     # pyflakes
    "FBT",   # flake8-boolean-trap
    "I",     # isort
    "ICN",   # flake8-import-conventions
    "ISC",   # flake8-implicit-str-concat
    "LOG",   # flake8-logging
    "N",     # pep8-naming
    "PLC",   # pylint convention
    "PLE",   # pylint error
    "PLR",   # pylint refactor
    "PLW",   # pylint warning
    "PT",    # flake8-pytest-style
    "PTH",   # flake8-use-pathlib
    "PYI",   # flake8-pyi
    "RET",   # flake8-return
    "RSE",   # flake8-raise
    "RUF",   # Ruff-specific
    "S",     # flake8-bandit
    "SIM",   # flake8-simplify
    "T",     # flake8-print
    "TCH",   # flake8-type-checking
    "TID",   # flake8-tidy-imports
    "UP",    # pyupgrade
    "W",     # pycodestyle warnings
    "YTT"    # flake8-2020
]

ignore = [
    "ARG001",  # Unused function argument
    "E501",    # Line too long
    "I001",    # Import block formatting
    "RUF001",  # String formatting
    "PLR2004", # Magic numbers
    "EXE003",  # Shebang formatting
    "ISC001",  # Implicit string concatenation
    "B027",    # Empty method in abstract base class
    "C901",    # Function complexity
    "FBT003",  # Boolean positional args
    "PLR0911", # Too many returns
    "PLR0912", # Too many branches
    "PLR0913", # Too many arguments
    "PLR0915", # Too many statements
    "PLW0603", # Global statement usage
    "S105",    # Possible hardcoded password
    "S106",    # Possible hardcoded password
    "S107",    # Possible hardcoded password
    "SIM102"   # Nested if statements
]

unfixable = ["F401"]  # Don't remove unused imports automatically

[tool.ruff.lint.isort]
known-first-party = ["twat_os"]

[tool.ruff.lint.flake8-tidy-imports]
ban-relative-imports = "all"

[tool.ruff.lint.per-file-ignores]
"tests/*" = ["S101", "PLR2004", "TID252"]

#------------------------------------------------------------------------------
# PYTEST CONFIGURATION
# Configuration for pytest testing framework.
#------------------------------------------------------------------------------
[tool.pytest.ini_options]
addopts = "-v --durations=10 -p no:briefcase"
asyncio_mode = "auto"
console_output_style = "progress"
filterwarnings = [
    "ignore::DeprecationWarning",
    "ignore::UserWarning"
]
log_cli = true
log_cli_level = "INFO"
markers = [
    "benchmark: marks tests as benchmarks (select with '-m benchmark')",
    "unit: mark a test as a unit test",
    "integration: mark a test as an integration test",
    "permutation: tests for permutation functionality",
    "parameter: tests for parameter parsing",
    "prompt: tests for prompt parsing"
]
norecursedirs = [
    ".*",
    "build",
    "dist",
    "venv",
    "__pycache__",
    "*.egg-info",
    "_private"
]
python_classes = ["Test*"]
python_files = ["test_*.py"]
python_functions = ["test_*"]
testpaths = ["tests"]

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",    # Minimum time
    "max",    # Maximum time
    "mean",   # Mean time
    "stddev", # Standard deviation
    "median", # Median time
    "iqr",    # Inter-quartile range
    "ops",    # Operations per second
    "rounds"  # Number of rounds
]
```

## TODO.md

```markdown
# TODO

- [ ] Initial task setup.
```

## VERSION.txt

```text
v2.7.5
```

## LOG.md

```markdown
# Log

This file is intended for manual log entries about development progress or significant events. For automated logs from the `cleanup.py` script, please refer to `CLEANUP.txt`.

---
```

## tests/test_package.py

```python
"""Test suite for twat_os."""

import twat_os


def test_version() -> None:
    """Verify package exposes version."""
    assert twat_os.__version__
```

## .github/workflows/release.yml

```yaml
name: Release

on:
  push:
    tags: ["v*"]

permissions:
  contents: write
  id-token: write

jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/twat-os
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

## .github/workflows/push.yml

```yaml
name: Build & Test

on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"

      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"

  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}

      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"

      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/twat_os --cov=tests tests/

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml

  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5
```

## .cursor/rules/cleanup.mdc

```text
---
description: Run `cleanup.py` script before and after changes
globs:
---
Before you do any changes or if I say "cleanup", run the `cleanup.py update` script in the main folder. Analyze the results, describe recent changes in @LOG.md and edit @TODO.md to update priorities and plan next changes. PERFORM THE CHANGES, then run the `cleanup.py status` script and react to the results.

When you edit @TODO.md, lead in lines with empty GFM checkboxes if things aren't done (`- [ ] `) vs. filled (`- [x] `) if done.
```

## .cursor/rules/0project.mdc

```text
---
description: About the twat-os project
globs:
---
# About twat-os

`twat-os` is a Python package providing operating system related utilities for the `twat` ecosystem. Its primary focus is on robust and configurable path management for applications and plugins.

## Key Features:
- **Path Management**: Centralized system for managing application paths (cache, config, data, logs, etc.) using `platformdirs` for cross-platform compatibility and `pydantic` for validation.
- **Configurable**: Path definitions can be customized via a `paths.toml` file.
- **Integration with `twat`**: Designed to function as a plugin within the `twat` framework.
- **Developer Experience**: Clean API with type hints.

## Development Notes
- Uses `uv` for Python package management.
- Quality tools: `ruff` for linting/formatting, `mypy` for type checking, `pytest` for testing.
- Built with Hatch and includes CI/CD setup using GitHub Actions.
- Strong typing and runtime checks are encouraged.
```

## .cursor/rules/filetree.mdc

```text
---
description: File tree of the project
globs:
---
[4.0K]  .
├── [4.0K]  .benchmarks
├── [4.0K]  .cursor
│   └── [4.0K]  rules
│       ├── [ 982]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.2K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [4.0K]  .github
│   └── [4.0K]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.1K]  CHANGELOG.md
├── [1.1K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 187]  LOG.md
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [  34]  TODO.md
├── [   7]  VERSION.txt
├── [ 12K]  cleanup.py
├── [4.0K]  dist
│   └── [   1]  .gitkeep
├── [456K]  llms.txt
├── [ 11K]  pyproject.toml
├── [4.0K]  src
│   └── [4.0K]  twat_os
│       ├── [  95]  __init__.py
│       ├── [4.0K]  __pycache__
│       ├── [8.6K]  paths.py
│       └── [1.0K]  paths.toml
└── [4.0K]  tests
    ├── [4.0K]  __pycache__
    └── [ 149]  test_package.py

12 directories, 24 files
```

## .cursor/rules/quality.mdc

```text
---
description: Quality
globs:
---
- **Verify Information**: Always verify information before presenting it. Do not make assumptions or speculate without clear evidence.
- **No Apologies**: Never use apologies.
- **No Whitespace Suggestions**: Don't suggest whitespace changes.
- **No Inventions**: Don't invent major changes other than what's explicitly requested.
- **No Unnecessary Confirmations**: Don't ask for confirmation of information already provided in the context.
- **Preserve Existing Code**: Don't remove unrelated code or functionalities. Pay attention to preserving existing structures.
- **No Implementation Checks**: Don't ask the user to verify implementations that are visible in the provided context.
- **No Unnecessary Updates**: Don't suggest updates or changes to files when there are no actual modifications needed.
- **No Current Implementation**: Don't show or discuss the current implementation unless specifically requested.
- **Use Explicit Variable Names**: Prefer descriptive, explicit variable names over short, ambiguous ones to enhance code readability.
- **Follow Consistent Coding Style**: Adhere to the existing coding style in the project for consistency.
- **Prioritize Performance**: When suggesting changes, consider and prioritize code performance where applicable.
- **Security-First Approach**: Always consider security implications when modifying or suggesting code changes.
- **Test Coverage**: Suggest or include appropriate unit tests for new or modified code.
- **Error Handling**: Implement robust error handling and logging where necessary.
- **Modular Design**: Encourage modular design principles to improve code maintainability and reusability.
- **Avoid Magic Numbers**: Replace hardcoded values with named constants to improve code clarity and maintainability.
- **Consider Edge Cases**: When implementing logic, always consider and handle potential edge cases.
- **Use Assertions**: Include assertions wherever possible to validate assumptions and catch potential errors early.
```

## README.md

````markdown
#



## Features

- Plugin for twat
- Modern Python packaging with PEP 621 compliance
- Type hints and runtime type checking
- Comprehensive test suite and documentation
- CI/CD ready configuration

## Installation

```bash
pip install twat-os
```

## Usage

```python
import twat_os
plugin = twat_os.plugin
```

## Development

This project uses [Hatch](https://hatch.pypa.io/) for development workflow management.

### Setup Development Environment

```bash
# Install hatch if you haven't already
pip install hatch

# Create and activate development environment
hatch shell

# Run tests
hatch run test

# Run tests with coverage
hatch run test-cov

# Run linting
hatch run lint

# Format code
hatch run format
```

## License

MIT License
````

## LICENSE

```text
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## CHANGELOG.md

```markdown
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]
### Added
- Created `TODO.md`, `LOG.md`, and `CHANGELOG.md`.

### Changed
- Corrected project description in `.cursor/rules/0project.mdc` to accurately describe `twat-os`.

### Refactored
- Simplified `cleanup.py`:
    - Removed internal `repomix` function.
    - Modified the script to call the system `repomix` command and output to `llms.txt` instead of `REPO_CONTENT.txt`.
- Improved `src/twat_os/paths.py`:
    - Added `from typing_extensions import Self` for compatibility.
    - Changed `create_dirs` parameter in `PathManager.__init__` to be keyword-only, resolving Ruff FBT001/FBT002 warnings.
- Updated `pyproject.toml`:
    - Added `pydantic` and `platformdirs` to core project dependencies.
    - Added `typing-extensions` to `dev` dependencies.
    - Removed the `[project.optional-dependencies.all]` group.
    - Updated `tool.hatch.envs.default.features` to exclude `all`.
```

## .gitignore

```text
*_autogen/
.DS_Store
__version__.py
__pycache__/
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
!?*.[Cc]ache/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!**/[Pp]ackages/build/
!Directory.Build.rsp
.*crunch*.local.xml
.axoCover/*
.builds
.cr/personal
.fake/
.history/
.ionide/
.localhistory/
.mfractor/
.ntvs_analysis.dat
.paket/paket.exe
.sass-cache/
.vs/
.vscode
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim_*.settings
*.bim.layout
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
**/[Pp]ackages/*
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
*~
~$*
$tf/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
coverage*.info
coverage*.json
coverage*.xml
csx/
CTestTestfile.cmake
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
ecf/
FakesAssemblies/
FodyWeavers.xsd
Generated_Code/
Generated\ Files/
healthchecksdb
install_manifest.txt
ipch/
Makefile
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
UpgradeLog*.htm
UpgradeLog*.XML
x64/
x86/
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Distribution / packaging
!dist/.gitkeep

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
.ruff_cache/

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Project specific
__version__.py
_private
```

## .pre-commit-config.yaml

```yaml
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]
```

## REPO_CONTENT.txt

````text
This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix. The content has been processed where empty lines have been removed.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: .specstory/**/*.md, .venv/**, _private/**, CLEANUP.txt, **/*.json, *.lock
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.cursor/
  rules/
    0project.mdc
    cleanup.mdc
    filetree.mdc
    quality.mdc
.github/
  workflows/
    push.yml
    release.yml
src/
  twat_os/
    __init__.py
    paths.py
    paths.toml
tests/
  test_package.py
.gitignore
.pre-commit-config.yaml
cleanup.py
LICENSE
pyproject.toml
README.md
VERSION.txt

================================================================
Files
================================================================

================
File: .cursor/rules/0project.mdc
================
---
description: About this project
globs:
---
# About this project

`twat-fs` is a file system utility library focused on robust and extensible file upload capabilities with multiple provider support. It provides:

- Multi-provider upload system with smart fallback (catbox.moe default, plus Dropbox, S3, etc.)
- Automatic retry for temporary failures, fallback for permanent ones
- URL validation and clean developer experience with type hints
- Simple CLI: `python -m twat_fs upload_file path/to/file.txt`
- Easy installation: `uv pip install twat-fs` (basic) or `uv pip install 'twat-fs[all,dev]'` (all features)

## Development Notes
- Uses `uv` for Python package management
- Quality tools: ruff, mypy, pytest
- Clear provider protocol for adding new storage backends
- Strong typing and runtime checks throughout

================
File: .cursor/rules/cleanup.mdc
================
---
description: Run `cleanup.py` script before and after changes
globs:
---
Before you do any changes or if I say "cleanup", run the `cleanup.py update` script in the main folder. Analyze the results, describe recent changes in @LOG.md and edit @TODO.md to update priorities and plan next changes. PERFORM THE CHANGES, then run the `cleanup.py status` script and react to the results.

When you edit @TODO.md, lead in lines with empty GFM checkboxes if things aren't done (`- [ ] `) vs. filled (`- [x] `) if done.

================
File: .cursor/rules/filetree.mdc
================
---
description: File tree of the project
globs:
---
[ 736]  .
├── [  64]  .benchmarks
├── [  96]  .cursor
│   └── [ 224]  rules
│       ├── [ 821]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.0K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [  96]  .github
│   └── [ 128]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.0K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [   7]  VERSION.txt
├── [ 13K]  cleanup.py
├── [ 192]  dist
│   └── [   1]  .gitkeep
├── [5.6K]  pyproject.toml
├── [  96]  src
│   └── [ 224]  twat_os
│       ├── [  95]  __init__.py
│       ├── [7.4K]  paths.py
│       └── [1.0K]  paths.toml
└── [ 128]  tests
    └── [ 145]  test_package.py

10 directories, 20 files

================
File: .cursor/rules/quality.mdc
================
---
description: Quality
globs:
---
- **Verify Information**: Always verify information before presenting it. Do not make assumptions or speculate without clear evidence.
- **No Apologies**: Never use apologies.
- **No Whitespace Suggestions**: Don't suggest whitespace changes.
- **No Inventions**: Don't invent major changes other than what's explicitly requested.
- **No Unnecessary Confirmations**: Don't ask for confirmation of information already provided in the context.
- **Preserve Existing Code**: Don't remove unrelated code or functionalities. Pay attention to preserving existing structures.
- **No Implementation Checks**: Don't ask the user to verify implementations that are visible in the provided context.
- **No Unnecessary Updates**: Don't suggest updates or changes to files when there are no actual modifications needed.
- **No Current Implementation**: Don't show or discuss the current implementation unless specifically requested.
- **Use Explicit Variable Names**: Prefer descriptive, explicit variable names over short, ambiguous ones to enhance code readability.
- **Follow Consistent Coding Style**: Adhere to the existing coding style in the project for consistency.
- **Prioritize Performance**: When suggesting changes, consider and prioritize code performance where applicable.
- **Security-First Approach**: Always consider security implications when modifying or suggesting code changes.
- **Test Coverage**: Suggest or include appropriate unit tests for new or modified code.
- **Error Handling**: Implement robust error handling and logging where necessary.
- **Modular Design**: Encourage modular design principles to improve code maintainability and reusability.
- **Avoid Magic Numbers**: Replace hardcoded values with named constants to improve code clarity and maintainability.
- **Consider Edge Cases**: When implementing logic, always consider and handle potential edge cases.
- **Use Assertions**: Include assertions wherever possible to validate assumptions and catch potential errors early.

================
File: .github/workflows/push.yml
================
name: Build & Test
on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:
permissions:
  contents: write
  id-token: write
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true
jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"
      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"
  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}
      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"
      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/twat_os --cov=tests tests/
      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml
  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true
      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs
      - name: Build distributions
        run: uv run python -m build --outdir dist
      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5

================
File: .github/workflows/release.yml
================
name: Release
on:
  push:
    tags: ["v*"]
permissions:
  contents: write
  id-token: write
jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/twat-os
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true
      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs
      - name: Build distributions
        run: uv run python -m build --outdir dist
      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)
      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

================
File: src/twat_os/__init__.py
================
__version__ = metadata.version(__name__)

================
File: src/twat_os/paths.py
================
PATHS_TOML = Path(__file__).parent / "paths.toml"
DEFAULT_PATHS = tomli.loads(PATHS_TOML.read_text())
class PathConfig(BaseModel):
    @field_validator("base_dir", "package_dir")
    def expand_path(cls, v: str | Path | None) -> Path | None:
        if isinstance(v, str):
            expanded = os.path.expandvars(os.path.expanduser(v))
            return Path(expanded)
    @model_validator(mode="after")
    def validate_and_create_dirs(self) -> Self:
            self.base_dir.mkdir(parents=True, exist_ok=True)
                self.package_dir.mkdir(parents=True, exist_ok=True)
class CacheConfig(PathConfig):
    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_cache_dir()) / "twat"
class ConfigDirConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_config_dir()) / "twat"
class DataDirConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat"
class TempDirConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_runtime_dir()) / "twat"
class GenAIConfig(PathConfig):
    lora_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/loras"
    model_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/models"
    output_dir: Path = Field(
        default_factory=lambda: Path.home() / "Pictures/twat_genai"
    def validate_and_create_all_dirs(self) -> Self:
            self.lora_dir.mkdir(parents=True, exist_ok=True)
            self.model_dir.mkdir(parents=True, exist_ok=True)
            self.output_dir.mkdir(parents=True, exist_ok=True)
class LogConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_state_dir()) / "twat/logs"
class PathManager:
    def __init__(
            config_path = Path(config_file)
            if not config_path.exists():
                raise FileNotFoundError(msg)
            self.config = tomli.loads(config_path.read_text())
        self._init_paths()
    def _init_paths(self) -> None:
        def format_path(path_str: str) -> Path | None:
            expanded = os.path.expandvars(os.path.expanduser(path_str))
            return Path(expanded.format(package_name=self.package_name))
        self.cache = CacheConfig(
            package_dir=format_path(self.config["cache"]["package_dir"]),
        self.config_dir = ConfigDirConfig(
            package_dir=format_path(self.config["config"]["package_dir"]),
        self.data = DataDirConfig(
            package_dir=format_path(self.config["data"]["package_dir"]),
        self.temp = TempDirConfig(
            package_dir=format_path(self.config["temp"]["package_dir"]),
        self.genai = GenAIConfig(
        self.logs = LogConfig(
            package_dir=format_path(self.config["logs"]["package_dir"]),
    def get_path(self, category: str, key: str = "base_dir") -> Path:
        config = getattr(self, category)
        return getattr(config, key)
    def for_package(
        return cls(package_name=package_name, config_file=config_file)
    def __repr__(self) -> str:

================
File: src/twat_os/paths.toml
================
[cache]
# Base directory for all cache operations
base_dir = "~/.cache/twat"
# Directory for storing package-specific cache data
package_dir = "~/.cache/twat/{package_name}"

[config]
# Base directory for configuration files
base_dir = "~/.config/twat"
# Directory for package-specific configuration
package_dir = "~/.config/twat/{package_name}"

[data]
# Base directory for user data
base_dir = "~/.local/share/twat"
# Directory for package-specific data
package_dir = "~/.local/share/twat/{package_name}"

[temp]
# Base directory for temporary files
base_dir = "~/tmp/twat"
# Directory for package-specific temporary files
package_dir = "~/tmp/twat/{package_name}"

[genai]
# Directory for storing LoRA files
lora_dir = "~/.local/share/twat/genai/loras"
# Directory for model weights
model_dir = "~/.local/share/twat/genai/models"
# Directory for generated images
output_dir = "~/Pictures/twat_genai"

[logs]
# Base directory for log files
base_dir = "~/.local/state/twat/logs"
# Directory for package-specific logs
package_dir = "~/.local/state/twat/logs/{package_name}"

================
File: tests/test_package.py
================
def test_version():

================
File: .gitignore
================
*_autogen/
.DS_Store
__version__.py
__pycache__/
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
!?*.[Cc]ache/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!**/[Pp]ackages/build/
!Directory.Build.rsp
.*crunch*.local.xml
.axoCover/*
.builds
.cr/personal
.fake/
.history/
.ionide/
.localhistory/
.mfractor/
.ntvs_analysis.dat
.paket/paket.exe
.sass-cache/
.vs/
.vscode
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim_*.settings
*.bim.layout
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
**/[Pp]ackages/*
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
*~
~$*
$tf/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
coverage*.info
coverage*.json
coverage*.xml
csx/
CTestTestfile.cmake
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
ecf/
FakesAssemblies/
FodyWeavers.xsd
Generated_Code/
Generated\ Files/
healthchecksdb
install_manifest.txt
ipch/
Makefile
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
UpgradeLog*.htm
UpgradeLog*.XML
x64/
x86/
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Distribution / packaging
!dist/.gitkeep

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
.ruff_cache/

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Project specific
__version__.py
_private

================
File: .pre-commit-config.yaml
================
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]

================
File: cleanup.py
================
LOG_FILE = Path("CLEANUP.txt")
os.chdir(Path(__file__).parent)
def new() -> None:
    if LOG_FILE.exists():
        LOG_FILE.unlink()
def prefix() -> None:
    readme = Path(".cursor/rules/0project.mdc")
    if readme.exists():
        log_message("\n=== PROJECT STATEMENT ===")
        content = readme.read_text()
        log_message(content)
def suffix() -> None:
    todo = Path("TODO.md")
    if todo.exists():
        log_message("\n=== TODO.md ===")
        content = todo.read_text()
def log_message(message: str) -> None:
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
    with LOG_FILE.open("a") as f:
        f.write(log_line)
def run_command(cmd: list[str], check: bool = True) -> subprocess.CompletedProcess:
        result = subprocess.run(
            log_message(result.stdout)
        log_message(f"Command failed: {' '.join(cmd)}")
        log_message(f"Error: {e.stderr}")
        return subprocess.CompletedProcess(cmd, 1, "", str(e))
def check_command_exists(cmd: str) -> bool:
        return which(cmd) is not None
class Cleanup:
    def __init__(self) -> None:
        self.workspace = Path.cwd()
    def _print_header(self, message: str) -> None:
        log_message(f"\n=== {message} ===")
    def _check_required_files(self) -> bool:
            if not (self.workspace / file).exists():
                log_message(f"Error: {file} is missing")
    def _generate_tree(self) -> None:
        if not check_command_exists("tree"):
            log_message("Warning: 'tree' command not found. Skipping tree generation.")
            rules_dir = Path(".cursor/rules")
            rules_dir.mkdir(parents=True, exist_ok=True)
            tree_result = run_command(["tree", "-a", "-I", ".git", "--gitignore", "-n", "-h", "-I", "*_cache"])
            with open(rules_dir / "filetree.mdc", "w") as f:
                f.write("---\ndescription: File tree of the project\nglobs: \n---\n")
                f.write(tree_text)
            log_message("\nProject structure:")
            log_message(tree_text)
            log_message(f"Failed to generate tree: {e}")
    def _git_status(self) -> bool:
        result = run_command(["git", "status", "--porcelain"], check=False)
        return bool(result.stdout.strip())
    def _venv(self) -> None:
        log_message("Setting up virtual environment")
            run_command(["uv", "venv"])
            if venv_path.exists():
                os.environ["VIRTUAL_ENV"] = str(self.workspace / ".venv")
                log_message("Virtual environment created and activated")
                log_message("Virtual environment created but activation failed")
            log_message(f"Failed to create virtual environment: {e}")
    def _install(self) -> None:
        log_message("Installing package with all extras")
            self._venv()
            run_command(["uv", "pip", "install", "-e", ".[test,dev]"])
            log_message("Package installed successfully")
            log_message(f"Failed to install package: {e}")
    def _run_checks(self) -> None:
        log_message("Running code quality checks")
            log_message(">>> Running code fixes...")
            run_command(
            log_message(">>>Running type checks...")
            run_command(["python", "-m", "mypy", "src", "tests"], check=False)
            log_message(">>> Running tests...")
            run_command(["python", "-m", "pytest", "tests"], check=False)
            log_message("All checks completed")
            log_message(f"Failed during checks: {e}")
    def status(self) -> None:
        prefix()  # Add README.md content at start
        self._print_header("Current Status")
        self._check_required_files()
        self._generate_tree()
        result = run_command(["git", "status"], check=False)
        self._print_header("Environment Status")
        self._install()
        self._run_checks()
        suffix()  # Add TODO.md content at end
    def venv(self) -> None:
        self._print_header("Virtual Environment Setup")
    def install(self) -> None:
        self._print_header("Package Installation")
    def update(self) -> None:
        self.status()
        if self._git_status():
            log_message("Changes detected in repository")
                run_command(["git", "add", "."])
                run_command(["git", "commit", "-m", commit_msg])
                log_message("Changes committed successfully")
                log_message(f"Failed to commit changes: {e}")
            log_message("No changes to commit")
    def push(self) -> None:
        self._print_header("Pushing Changes")
            run_command(["git", "push"])
            log_message("Changes pushed successfully")
            log_message(f"Failed to push changes: {e}")
def repomix(
            cmd.append("--compress")
            cmd.append("--remove-empty-lines")
            cmd.append("-i")
            cmd.append(ignore_patterns)
        cmd.extend(["-o", output_file])
        run_command(cmd)
        log_message(f"Repository content mixed into {output_file}")
        log_message(f"Failed to mix repository: {e}")
def print_usage() -> None:
    log_message("Usage:")
    log_message("  cleanup.py status   # Show current status and run all checks")
    log_message("  cleanup.py venv     # Create virtual environment")
    log_message("  cleanup.py install  # Install package with all extras")
    log_message("  cleanup.py update   # Update and commit changes")
    log_message("  cleanup.py push     # Push changes to remote")
def main() -> NoReturn:
    new()  # Clear log file
    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)
    cleanup = Cleanup()
            cleanup.status()
            cleanup.venv()
            cleanup.install()
            cleanup.update()
            cleanup.push()
        log_message(f"Error: {e}")
    repomix()
    sys.stdout.write(Path("CLEANUP.txt").read_text())
    sys.exit(0)  # Ensure we exit with a status code
    main()

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: pyproject.toml
================
# this_file: pyproject.toml
# this_project: twat_os
[project]
name = "twat-os"
dynamic = ["version"]
description = "Operating system utilities for twat"
readme = "README.md"
requires-python = ">=3.10"
license = "MIT"
keywords = [
    "os",
    "system",
    "twat"
]
classifiers = [
    "Development Status :: 4 - Beta",
    "Programming Language :: Python",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
]

dependencies = [
    "fire>=0.6.0",
    "loguru>=0.7.2",
    "twat>=1.8.1"
]

[project.optional-dependencies]
dev = [
    "hatch>=1.14.0",
    "hatchling>=1.27.0",
    "hatch-vcs>=0.4.0",
    "mypy>=1.15.0",
    "pre-commit>=4.1.0",
    "pyupgrade>=3.19.1",
    "ruff>=0.9.6"
]

test = [
    "pytest>=8.3.4",
    "pytest-cov>=6.0.0",
    "pytest-benchmark>=5.1.0",
    "pytest-mock>=3.14.0",
    "pytest-asyncio>=0.25.3",
    "pytest-timeout>=2.3.1"
]

all = [
    "fire>=0.6.0",
    "loguru>=0.7.2",
    "twat>=1.8.1"
]

[project.scripts]
twat-os = "twat_os.__main__:main"

[project.entry-points."twat.plugins"]
os = "twat_os"

[[project.authors]]
name = "Adam Twardoch"
email = "adam+github@twardoch.com"

[project.urls]
Documentation = "https://github.com/twardoch/twat-os#readme"
Issues = "https://github.com/twardoch/twat-os/issues"
Source = "https://github.com/twardoch/twat-os"

[build-system]
build-backend = "hatchling.build"
requires = [
    "hatchling>=1.27.0",
    "hatch-vcs>=0.4.0"
]

[tool.coverage.paths]
twat_os = ["src/twat_os", "*/twat-os/src/twat_os"]
tests = ["tests", "*/twat-os/tests"]

[tool.coverage.report]
exclude_lines = [
    "no cov",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:"
]

[tool.coverage.run]
source_pkgs = ["twat_os", "tests"]
branch = true
parallel = true
omit = ["src/twat_os/__about__.py"]

[tool.hatch.build.hooks.vcs]
version-file = "src/twat_os/__version__.py"

[tool.hatch.build.targets.wheel]
packages = ["src/twat_os"]
include = [
    "src/twat_os/**/*.py",
    "src/twat_os/py.typed"
]

[tool.hatch.envs.default]
dependencies = [
    "pytest>=8.3.4",
    "pytest-cov>=6.0.0",
    "ruff>=0.9.6",
    "mypy>=1.15.0"
]

[tool.hatch.envs.default.scripts]
test = "pytest {args:tests}"
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
type-check = "mypy src/twat_os tests"
lint = ["ruff check src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]
fix = ["ruff check --fix --unsafe-fixes src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]

[[tool.hatch.envs.all.matrix]]
python = ["3.10", "3.11", "3.12"]

[tool.hatch.envs.lint]
detached = true
dependencies = [
    "pytest>=8.3.4",
    "pytest-cov>=6.0.0",
    "ruff>=0.9.6",
    "mypy>=1.15.0"
]

[tool.hatch.envs.lint.scripts]
typing = "mypy --install-types --non-interactive {args:src/twat_os tests}"
style = ["ruff check {args:.}", "ruff format --respect-gitignore {args:.}"]
fmt = ["ruff format --respect-gitignore {args:.}", "ruff check --fix {args:.}"]
all = ["style", "typing"]

[tool.hatch.envs.test]
dependencies = []

[tool.hatch.envs.test.scripts]
test = "python -m pytest -n auto -p no:briefcase {args:tests}"
test-cov = "python -m pytest -n auto -p no:briefcase --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
bench = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only"
bench-save = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only --benchmark-json=benchmark/results.json"

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
version_scheme = "post-release"

[tool.mypy]
python_version = "3.10"
check_untyped_defs = true
disallow_incomplete_defs = true
disallow_untyped_decorators = true
disallow_untyped_defs = true
no_implicit_optional = true
warn_no_return = true
warn_redundant_casts = true
warn_return_any = true
warn_unreachable = true
warn_unused_configs = true
warn_unused_ignores = true

[tool.ruff]
line-length = 88
target-version = "py310"

[tool.ruff.lint]
extend-select = [
    "A",
    "ARG",
    "B",
    "C",
    "DTZ",
    "E",
    "EM",
    "F",
    "FBT",
    "I",
    "ICN",
    "ISC",
    "N",
    "PLC",
    "PLE",
    "PLR",
    "PLW",
    "Q",
    "RUF",
    "S",
    "T",
    "TID",
    "UP",
    "W",
    "YTT"
]
ignore = [
    "ARG001",
    "E501",
    "I001",
    "RUF001",
    "PLR2004",
    "EXE003",
    "ISC001"
]

[tool.ruff.per-file-ignores]
"tests/*" = ["S101"]

[tool.pytest.ini_options]
addopts = "-v --durations=10 -p no:briefcase"
asyncio_mode = "auto"
console_output_style = "progress"
filterwarnings = [
    "ignore::DeprecationWarning",
    "ignore::UserWarning"
]
log_cli = true
log_cli_level = "INFO"
markers = [
    "benchmark: marks tests as benchmarks (select with '-m benchmark')",
    "unit: mark a test as a unit test",
    "integration: mark a test as an integration test",
    "permutation: tests for permutation functionality",
    "parameter: tests for parameter parsing",
    "prompt: tests for prompt parsing"
]
norecursedirs = [
    ".*",
    "build",
    "dist",
    "venv",
    "__pycache__",
    "*.egg-info",
    "_private"
]
python_classes = ["Test*"]
python_files = ["test_*.py"]
python_functions = ["test_*"]
testpaths = ["tests"]

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",
    "max",
    "mean",
    "stddev",
    "median",
    "iqr",
    "ops",
    "rounds"
]

================
File: README.md
================
#



## Features

- Plugin for twat
- Modern Python packaging with PEP 621 compliance
- Type hints and runtime type checking
- Comprehensive test suite and documentation
- CI/CD ready configuration

## Installation

```bash
pip install twat-os
```

## Usage

```python
import twat_os
plugin = twat_os.plugin
```

## Development

This project uses [Hatch](https://hatch.pypa.io/) for development workflow management.

### Setup Development Environment

```bash
# Install hatch if you haven't already
pip install hatch

# Create and activate development environment
hatch shell

# Run tests
hatch run test

# Run tests with coverage
hatch run test-cov

# Run linting
hatch run lint

# Format code
hatch run format
```

## License

MIT License

================
File: VERSION.txt
================
v2.6.2



================================================================
End of Codebase
================================================================
````

## CLEANUP.txt

```text
2025-06-25 10:56:08 -
=== PROJECT STATEMENT ===
2025-06-25 10:56:08 - ---
description: About the twat-os project
globs:
---
# About twat-os

`twat-os` is a Python package providing operating system related utilities for the `twat` ecosystem. Its primary focus is on robust and configurable path management for applications and plugins.

## Key Features:
- **Path Management**: Centralized system for managing application paths (cache, config, data, logs, etc.) using `platformdirs` for cross-platform compatibility and `pydantic` for validation.
- **Configurable**: Path definitions can be customized via a `paths.toml` file.
- **Integration with `twat`**: Designed to function as a plugin within the `twat` framework.
- **Developer Experience**: Clean API with type hints.

## Development Notes
- Uses `uv` for Python package management.
- Quality tools: `ruff` for linting/formatting, `mypy` for type checking, `pytest` for testing.
- Built with Hatch and includes CI/CD setup using GitHub Actions.
- Strong typing and runtime checks are encouraged.

2025-06-25 10:56:08 -
=== Current Status ===
2025-06-25 10:56:08 - [4.0K]  .
├── [4.0K]  .benchmarks
├── [4.0K]  .cursor
│   └── [4.0K]  rules
│       ├── [ 982]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.2K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [4.0K]  .github
│   └── [4.0K]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.1K]  CHANGELOG.md
├── [1.1K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 187]  LOG.md
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [  34]  TODO.md
├── [   7]  VERSION.txt
├── [ 12K]  cleanup.py
├── [4.0K]  dist
│   └── [   1]  .gitkeep
├── [456K]  llms.txt
├── [ 11K]  pyproject.toml
├── [4.0K]  src
│   └── [4.0K]  twat_os
│       ├── [  95]  __init__.py
│       ├── [4.0K]  __pycache__
│       ├── [8.6K]  paths.py
│       └── [1.0K]  paths.toml
└── [4.0K]  tests
    ├── [4.0K]  __pycache__
    └── [ 149]  test_package.py

12 directories, 24 files

2025-06-25 10:56:08 -
Project structure:
2025-06-25 10:56:08 - [4.0K]  .
├── [4.0K]  .benchmarks
├── [4.0K]  .cursor
│   └── [4.0K]  rules
│       ├── [ 982]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.2K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [4.0K]  .github
│   └── [4.0K]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.1K]  CHANGELOG.md
├── [1.1K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 187]  LOG.md
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [  34]  TODO.md
├── [   7]  VERSION.txt
├── [ 12K]  cleanup.py
├── [4.0K]  dist
│   └── [   1]  .gitkeep
├── [456K]  llms.txt
├── [ 11K]  pyproject.toml
├── [4.0K]  src
│   └── [4.0K]  twat_os
│       ├── [  95]  __init__.py
│       ├── [4.0K]  __pycache__
│       ├── [8.6K]  paths.py
│       └── [1.0K]  paths.toml
└── [4.0K]  tests
    ├── [4.0K]  __pycache__
    └── [ 149]  test_package.py

12 directories, 24 files

2025-06-25 10:56:08 - HEAD detached from 23e0688
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   .cursor/rules/filetree.mdc
	modified:   CLEANUP.txt

no changes added to commit (use "git add" and/or "git commit -a")

2025-06-25 10:56:08 - HEAD detached from 23e0688
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   .cursor/rules/filetree.mdc
	modified:   CLEANUP.txt

no changes added to commit (use "git add" and/or "git commit -a")

2025-06-25 10:56:08 -
=== Environment Status ===
2025-06-25 10:56:08 - Setting up virtual environment
2025-06-25 10:56:08 - Virtual environment created and activated
2025-06-25 10:56:08 - Installing package with all extras
2025-06-25 10:56:08 - Setting up virtual environment
2025-06-25 10:56:08 - Virtual environment created and activated
2025-06-25 10:56:10 - Package installed successfully
2025-06-25 10:56:10 - Running code quality checks
2025-06-25 10:56:10 - >>> Running code fixes...
2025-06-25 10:56:10 - src/twat_os/paths.py:15:35: F401 `typing.cast` imported but unused
   |
13 | import os
14 | from pathlib import Path
15 | from typing import TYPE_CHECKING, cast
   |                                   ^^^^ F401
16 |
17 | import platformdirs
   |
   = help: Remove unused import: `typing.cast`

Found 1 error.

2025-06-25 10:56:10 - 3 files left unchanged

2025-06-25 10:56:10 - >>>Running type checks...
2025-06-25 10:56:10 - Success: no issues found in 4 source files

2025-06-25 10:56:10 - >>> Running tests...
2025-06-25 10:56:12 - ============================= test session starts ==============================
platform linux -- Python 3.12.11, pytest-8.4.1, pluggy-1.6.0 -- /app/.venv/bin/python
cachedir: .pytest_cache
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /app
configfile: pyproject.toml
plugins: asyncio-1.0.0, benchmark-5.1.0, mock-3.14.1, timeout-2.4.0, cov-6.2.1, anyio-4.9.0, xdist-3.7.0
asyncio: mode=Mode.AUTO, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 1 item

tests/test_package.py::test_version PASSED                               [100%]

============================= slowest 10 durations =============================

(3 durations < 0.005s hidden.  Use -vv to show these durations.)
============================== 1 passed in 0.02s ===============================

2025-06-25 10:56:12 - All checks completed
2025-06-25 10:56:12 -
=== TODO.md ===
2025-06-25 10:56:12 - # TODO

- [ ] Initial task setup.
```

## llms.txt

`````````text
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-06-25 10:55:58

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
cleanup.py
src
  twat_os
    __init__.py
    paths.toml
    paths.py
pyproject.toml
TODO.md
VERSION.txt
LOG.md
tests
  test_package.py
.github
  workflows
    release.yml
    push.yml
.cursor
  rules
    cleanup.mdc
    0project.mdc
    filetree.mdc
    quality.mdc
README.md
LICENSE
CHANGELOG.md
.gitignore
.pre-commit-config.yaml
REPO_CONTENT.txt
CLEANUP.txt
llms.txt
```

# Repository Files


## cleanup.py

```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = [
#   "ruff>=0.9.6",
#   "pytest>=8.3.4",
#   "mypy>=1.15.0",
# ]
# ///
# this_file: cleanup.py

"""
Cleanup tool for managing repository tasks and maintaining code quality.

This script provides a comprehensive set of commands for repository maintenance:

When to use each command:

- `cleanup.py status`: Use this FIRST when starting work to check the current state
  of the repository. It shows file structure, git status, and runs all code quality
  checks. Run this before making any changes to ensure you're starting from a clean state.

- `cleanup.py venv`: Run this when setting up the project for the first time or if
  your virtual environment is corrupted/missing. Creates a new virtual environment
  using uv.

- `cleanup.py install`: Use after `venv` or when dependencies have changed. Installs
  the package and all development dependencies in editable mode.

- `cleanup.py update`: Run this when you've made changes and want to commit them.
  It will:
  1. Show current status (like `status` command)
  2. Stage and commit any changes with a generic message
  Use this for routine maintenance commits.

- `cleanup.py push`: Run this after `update` when you want to push your committed
  changes to the remote repository.

Workflow Example:
1. Start work: `cleanup.py status`
2. Make changes to code
3. Commit changes: `cleanup.py update`
4. Push to remote: `cleanup.py push`

The script maintains a CLEANUP.txt file that records all operations with timestamps.
It also includes content from README.md at the start and TODO.md at the end of logs
for context.

Required Files:
- LOG.md: Project changelog
- README.md: Project documentation
- TODO.md: Pending tasks and future plans
"""

import subprocess
import os
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import NoReturn
from shutil import which

# Configuration
IGNORE_PATTERNS = [
    ".git",
    ".venv",
    "__pycache__",
    "*.pyc",
    "dist",
    "build",
    "*.egg-info",
]
REQUIRED_FILES = ["LOG.md", ".cursor/rules/0project.mdc", "TODO.md"]
LOG_FILE = Path("CLEANUP.txt")

# Ensure we're working from the script's directory
os.chdir(Path(__file__).parent)


def new() -> None:
    """Remove existing log file."""
    if LOG_FILE.exists():
        LOG_FILE.unlink()


def prefix() -> None:
    """Write README.md content to log file."""
    readme = Path(".cursor/rules/0project.mdc")
    if readme.exists():
        log_message("\n=== PROJECT STATEMENT ===")
        content = readme.read_text()
        log_message(content)


def suffix() -> None:
    """Write TODO.md content to log file."""
    todo = Path("TODO.md")
    if todo.exists():
        log_message("\n=== TODO.md ===")
        content = todo.read_text()
        log_message(content)


def log_message(message: str) -> None:
    """Log a message to file and console with timestamp."""
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
    log_line = f"{timestamp} - {message}\n"
    with LOG_FILE.open("a") as f:
        f.write(log_line)


def run_command(cmd: list[str], check: bool = True) -> subprocess.CompletedProcess:
    """Run a shell command and return the result."""
    try:
        result = subprocess.run(
            cmd,
            check=check,
            capture_output=True,
            text=True,
            shell=False,  # Explicitly set shell=False for security
        )
        if result.stdout:
            log_message(result.stdout)
        return result
    except subprocess.CalledProcessError as e:
        log_message(f"Command failed: {' '.join(cmd)}")
        log_message(f"Error: {e.stderr}")
        if check:
            raise
        return subprocess.CompletedProcess(cmd, 1, "", str(e))


def check_command_exists(cmd: str) -> bool:
    """Check if a command exists in the system."""
    try:
        return which(cmd) is not None
    except Exception:
        return False


class Cleanup:
    """Main cleanup tool class."""

    def __init__(self) -> None:
        self.workspace = Path.cwd()

    def _print_header(self, message: str) -> None:
        """Print a section header."""
        log_message(f"\n=== {message} ===")

    def _check_required_files(self) -> bool:
        """Check if all required files exist."""
        missing = False
        for file in REQUIRED_FILES:
            if not (self.workspace / file).exists():
                log_message(f"Error: {file} is missing")
                missing = True
        return not missing

    def _generate_tree(self) -> None:
        """Generate and display tree structure of the project."""
        if not check_command_exists("tree"):
            log_message("Warning: 'tree' command not found. Skipping tree generation.")
            return

        try:
            # Create/overwrite the file with YAML frontmatter
            rules_dir = Path(".cursor/rules")
            rules_dir.mkdir(parents=True, exist_ok=True)
            # Get tree output
            tree_result = run_command(["tree", "-a", "-I", ".git", "--gitignore", "-n", "-h", "-I", "*_cache"])
            tree_text = tree_result.stdout
            # Write frontmatter and tree output to file
            with open(rules_dir / "filetree.mdc", "w") as f:
                f.write("---\ndescription: File tree of the project\nglobs: \n---\n")
                f.write(tree_text)

            # Log the contents
            log_message("\nProject structure:")
            log_message(tree_text)

        except Exception as e:
            log_message(f"Failed to generate tree: {e}")
        return

    def _git_status(self) -> bool:
        """Check git status and return True if there are changes."""
        result = run_command(["git", "status", "--porcelain"], check=False)
        return bool(result.stdout.strip())

    def _venv(self) -> None:
        """Create and activate virtual environment using uv."""
        log_message("Setting up virtual environment")
        try:
            run_command(["uv", "venv"])
            # Activate the virtual environment
            venv_path = self.workspace / ".venv" / "bin" / "activate"
            if venv_path.exists():
                os.environ["VIRTUAL_ENV"] = str(self.workspace / ".venv")
                os.environ["PATH"] = f"{self.workspace / '.venv' / 'bin'}{os.pathsep}{os.environ['PATH']}"
                log_message("Virtual environment created and activated")
            else:
                log_message("Virtual environment created but activation failed")
        except Exception as e:
            log_message(f"Failed to create virtual environment: {e}")

    def _install(self) -> None:
        """Install package in development mode with all extras."""
        log_message("Installing package with all extras")
        try:
            self._venv()
            run_command(["uv", "pip", "install", "-e", ".[test,dev]"])
            log_message("Package installed successfully")
        except Exception as e:
            log_message(f"Failed to install package: {e}")

    def _run_checks(self) -> None:
        """Run code quality checks using ruff and pytest."""
        log_message("Running code quality checks")

        try:
            # Run ruff checks
            log_message(">>> Running code fixes...")
            run_command(
                [
                    "python",
                    "-m",
                    "ruff",
                    "check",
                    "--fix",
                    "--unsafe-fixes",
                    "src",
                    "tests",
                ],
                check=False,
            )
            run_command(
                [
                    "python",
                    "-m",
                    "ruff",
                    "format",
                    "--respect-gitignore",
                    "src",
                    "tests",
                ],
                check=False,
            )

            # Run type checks
            log_message(">>>Running type checks...")
            run_command(["python", "-m", "mypy", "src", "tests"], check=False)

            # Run tests
            log_message(">>> Running tests...")
            run_command(["python", "-m", "pytest", "tests"], check=False)

            log_message("All checks completed")
        except Exception as e:
            log_message(f"Failed during checks: {e}")

    def status(self) -> None:
        """Show current repository status: tree structure, git status, and run checks."""
        prefix()  # Add README.md content at start
        self._print_header("Current Status")

        # Check required files
        self._check_required_files()

        # Show tree structure
        self._generate_tree()

        # Show git status
        result = run_command(["git", "status"], check=False)
        log_message(result.stdout)

        # Run additional checks
        self._print_header("Environment Status")
        self._venv()
        self._install()
        self._run_checks()

        suffix()  # Add TODO.md content at end

    def venv(self) -> None:
        """Create and activate virtual environment."""
        self._print_header("Virtual Environment Setup")
        self._venv()

    def install(self) -> None:
        """Install package with all extras."""
        self._print_header("Package Installation")
        self._install()

    def update(self) -> None:
        """Show status and commit any changes if needed."""
        # First show current status
        self.status()

        # Then handle git changes if any
        if self._git_status():
            log_message("Changes detected in repository")
            try:
                # Add all changes
                run_command(["git", "add", "."])
                # Commit changes
                commit_msg = "Update repository files"
                run_command(["git", "commit", "-m", commit_msg])
                log_message("Changes committed successfully")
            except Exception as e:
                log_message(f"Failed to commit changes: {e}")
        else:
            log_message("No changes to commit")

    def push(self) -> None:
        """Push changes to remote repository."""
        self._print_header("Pushing Changes")
        try:
            run_command(["git", "push"])
            log_message("Changes pushed successfully")
        except Exception as e:
            log_message(f"Failed to push changes: {e}")


def print_usage() -> None:
    """Print usage information."""
    log_message("Usage:")
    log_message("  cleanup.py status   # Show current status and run all checks")
    log_message("  cleanup.py venv     # Create virtual environment")
    log_message("  cleanup.py install  # Install package with all extras")
    log_message("  cleanup.py update   # Update and commit changes")
    log_message("  cleanup.py push     # Push changes to remote")


def main() -> NoReturn:
    """Main entry point."""
    new()  # Clear log file

    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)

    command = sys.argv[1]
    cleanup = Cleanup()

    try:
        if command == "status":
            cleanup.status()
        elif command == "venv":
            cleanup.venv()
        elif command == "install":
            cleanup.install()
        elif command == "update":
            cleanup.update()
        elif command == "push":
            cleanup.push()
        else:
            print_usage()
    except Exception as e:
        log_message(f"Error: {e}")
    # Call the system-installed repomix to generate llms.txt
    run_command(["repomix", "-o", "llms.txt", "."])
    log_message("Repository content mixed into llms.txt by system repomix call.")
    sys.stdout.write(Path("CLEANUP.txt").read_text())
    sys.exit(0)  # Ensure we exit with a status code


if __name__ == "__main__":
    main()
```

## src/twat_os/__init__.py

```python
"""twat os plugin"""

from importlib import metadata

__version__ = metadata.version(__name__)
```

## src/twat_os/paths.toml

```text
[cache]
# Base directory for all cache operations
base_dir = "~/.cache/twat"
# Directory for storing package-specific cache data
package_dir = "~/.cache/twat/{package_name}"

[config]
# Base directory for configuration files
base_dir = "~/.config/twat"
# Directory for package-specific configuration
package_dir = "~/.config/twat/{package_name}"

[data]
# Base directory for user data
base_dir = "~/.local/share/twat"
# Directory for package-specific data
package_dir = "~/.local/share/twat/{package_name}"

[temp]
# Base directory for temporary files
base_dir = "~/tmp/twat"
# Directory for package-specific temporary files
package_dir = "~/tmp/twat/{package_name}"

[genai]
# Directory for storing LoRA files
lora_dir = "~/.local/share/twat/genai/loras"
# Directory for model weights
model_dir = "~/.local/share/twat/genai/models"
# Directory for generated images
output_dir = "~/Pictures/twat_genai"

[logs]
# Base directory for log files
base_dir = "~/.local/state/twat/logs"
# Directory for package-specific logs
package_dir = "~/.local/state/twat/logs/{package_name}"
```

## src/twat_os/paths.py

```python
#!/usr/bin/env -S uv run
# /// script
# dependencies = ["pydantic", "platformdirs"]
# ///
"""Path management for twat packages.

This module provides a centralized way to manage paths for various twat packages.
It handles path resolution, validation, and creation of directories as needed.
"""

from __future__ import annotations

import os
from pathlib import Path
from typing import TYPE_CHECKING, cast

import platformdirs
import tomli
from pydantic import BaseModel, Field, field_validator, model_validator

if TYPE_CHECKING:
    from typing_extensions import Self

# Load default paths from TOML
PATHS_TOML = Path(__file__).parent / "paths.toml"
DEFAULT_PATHS = tomli.loads(PATHS_TOML.read_text())


class PathConfig(BaseModel):
    """Base configuration for path settings."""

    base_dir: Path
    package_dir: Path | None = None
    create_if_missing: bool = True

    @field_validator("base_dir", "package_dir")
    @classmethod
    def expand_path(cls, v: str | Path | None) -> Path | None:
        """Expand user and environment variables in paths."""
        if v is None:
            return None
        if isinstance(v, str):
            # Expand both ~ and environment variables
            expanded_user = Path(v).expanduser()
            expanded_vars = os.path.expandvars(str(expanded_user))
            return Path(expanded_vars)
        return v

    @model_validator(mode="after")
    def validate_and_create_dirs(self) -> Self:
        """Create directories if they don't exist and creation is enabled."""
        if self.create_if_missing:
            self.base_dir.mkdir(parents=True, exist_ok=True)
            if self.package_dir:
                self.package_dir.mkdir(parents=True, exist_ok=True)
        return self


class CacheConfig(PathConfig):
    """Configuration for cache directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_cache_dir()) / "twat"
    )


class ConfigDirConfig(PathConfig):
    """Configuration for config directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_config_dir()) / "twat"
    )


class DataDirConfig(PathConfig):
    """Configuration for data directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat"
    )


class TempDirConfig(PathConfig):
    """Configuration for temporary directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_runtime_dir()) / "twat"
    )


class GenAIConfig(PathConfig):
    """Configuration for GenAI-specific paths."""

    lora_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/loras"
    )
    model_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/models"
    )
    output_dir: Path = Field(
        default_factory=lambda: Path.home() / "Pictures/twat_genai"
    )

    @model_validator(mode="after")
    def validate_and_create_all_dirs(self) -> Self:
        """Create all GenAI directories if enabled."""
        if self.create_if_missing:
            self.base_dir.mkdir(parents=True, exist_ok=True)
            self.lora_dir.mkdir(parents=True, exist_ok=True)
            self.model_dir.mkdir(parents=True, exist_ok=True)
            self.output_dir.mkdir(parents=True, exist_ok=True)
        return self


class LogConfig(PathConfig):
    """Configuration for log directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_state_dir()) / "twat/logs"
    )


class PathManager:
    """Central manager for all path configurations."""

    def __init__(
        self,
        package_name: str | None = None,
        config_file: str | Path | None = None,
        *,
        create_dirs: bool = True,
    ) -> None:
        """Initialize path manager.

        Args:
            package_name: Optional package name for package-specific paths
            config_file: Optional path to custom config file
            create_dirs: Whether to create directories if they don't exist
        """
        self.package_name = package_name
        self.create_dirs = create_dirs

        # Load config
        if config_file:
            config_path = Path(config_file)
            if not config_path.exists():
                msg = f"Config file not found: {config_file}"
                raise FileNotFoundError(msg)
            self.config = tomli.loads(config_path.read_text())
        else:
            self.config = DEFAULT_PATHS

        # Initialize path configurations
        self._init_paths()

    def _init_paths(self) -> None:
        """Initialize all path configurations."""

        # Helper to format package-specific paths
        def format_path(path_str: str) -> Path | None:
            if not self.package_name:
                return None
            expanded_user = Path(path_str).expanduser()
            expanded_vars = os.path.expandvars(str(expanded_user))
            return Path(expanded_vars.format(package_name=self.package_name))

        # Initialize configurations
        self.cache = CacheConfig(
            base_dir=self.config["cache"]["base_dir"],
            package_dir=format_path(self.config["cache"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.config_dir = ConfigDirConfig(
            base_dir=self.config["config"]["base_dir"],
            package_dir=format_path(self.config["config"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.data = DataDirConfig(
            base_dir=self.config["data"]["base_dir"],
            package_dir=format_path(self.config["data"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.temp = TempDirConfig(
            base_dir=self.config["temp"]["base_dir"],
            package_dir=format_path(self.config["temp"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.genai = GenAIConfig(
            base_dir=self.config["data"]["base_dir"],
            lora_dir=self.config["genai"]["lora_dir"],
            model_dir=self.config["genai"]["model_dir"],
            output_dir=self.config["genai"]["output_dir"],
            create_if_missing=self.create_dirs,
        )

        self.logs = LogConfig(
            base_dir=self.config["logs"]["base_dir"],
            package_dir=format_path(self.config["logs"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

    def get_path(self, category: str, key: str = "base_dir") -> Path:
        """Get a specific path by category and key.

        Args:
            category: Path category (cache, config, data, temp, genai, logs)
            key: Path key within the category (base_dir, package_dir, etc.)

        Returns:
            Resolved path

        Raises:
            AttributeError: If category or key doesn't exist
        """
        config = getattr(self, category)
        path_value = getattr(config, key)
        if not isinstance(path_value, Path):
            # This case should ideally not happen if Pydantic models are correct
            # and keys always point to Path objects or None (for package_dir sometimes).
            # However, to satisfy type checker for dynamic getattr:
            if path_value is None and key == "package_dir":  # package_dir can be None
                # This function is typed to return Path, so None is not allowed here.
                # This indicates a potential design issue or misuse of get_path for optional paths.
                # For now, raising an error is safer than returning None.
                msg = (
                    f"Path for '{category}.{key}' is None, but Path type was expected."
                )
                raise ValueError(msg)
            msg = f"Unexpected type for '{category}.{key}': {type(path_value)}. Expected Path."
            raise TypeError(msg)
        return path_value  # Cast is redundant due to isinstance check

    @classmethod
    def for_package(
        cls, package_name: str, config_file: str | Path | None = None
    ) -> PathManager:
        """Create a PathManager instance for a specific package.

        Args:
            package_name: Package name
            config_file: Optional path to custom config file

        Returns:
            PathManager instance configured for the package
        """
        return cls(package_name=package_name, config_file=config_file)

    def __repr__(self) -> str:
        """Return string representation of PathManager."""
        package_info = (
            f" for package '{self.package_name}'" if self.package_name else ""
        )
        return f"PathManager{package_info}"
```

## pyproject.toml

```text
#==============================================================================
# TWAT_OS PACKAGE CONFIGURATION
# This pyproject.toml defines the package metadata, dependencies, build system,
# and development environment for the twat-os package, which provides operating
# system utilities for the twat framework.
#==============================================================================

#------------------------------------------------------------------------------
# PROJECT METADATA
# Core package information used by PyPI and package managers.
#------------------------------------------------------------------------------
[project]
name = "twat-os" # Package name on PyPI
dynamic = ["version"] # Fields set dynamically at build time
description = "Operating system utilities for twat" # Short description
readme = "README.md" # Path to README file
requires-python = ">=3.10" # Minimum Python version
license = "MIT" # License type

# Keywords for PyPI search
keywords = [
    "os",
    "system",
    "twat",
    "utilities",
    "operating-system",
]

# PyPI classifiers for package categorization
classifiers = [
    "Development Status :: 4 - Beta", # Package maturity level
    "Programming Language :: Python",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
    "Operating System :: OS Independent",
    "License :: OSI Approved :: MIT License",
    "Intended Audience :: Developers",
]

# Core dependencies
dependencies = [
    "fire>=0.6.0",      # CLI framework
    "loguru>=0.7.2",    # Structured logging
    "twat>=1.8.1",       # Core twat package
    "pydantic>=2.0",    # Data validation and settings management
    "platformdirs>=3.0.0" # Platform-specific user directories
]

#------------------------------------------------------------------------------
# OPTIONAL DEPENDENCIES
# Additional dependencies for optional features, development, and testing.
#------------------------------------------------------------------------------
[project.optional-dependencies]

# Development tools
dev = [
    "hatch>=1.14.0",         # Build tool
    "hatchling>=1.27.0",     # Build backend
    "hatch-vcs>=0.4.0",      # Version control integration
    "mypy>=1.15.0",          # Type checking
    "pre-commit>=4.1.0",     # Pre-commit hooks
    "pyupgrade>=3.19.1",     # Python syntax upgrader
    "ruff>=0.9.7",           # Linting and formatting
    "absolufy-imports>=0.3.1", # Absolute imports
    "isort>=6.0.1",           # Import sorting
    "typing-extensions>=4.0.0" # For Self type hint and other backports
]

# Testing tools
test = [
    "pytest>=8.3.4",           # Testing framework
    "pytest-cov>=6.0.0",       # Coverage reporting
    "pytest-xdist>=3.6.1",     # Parallel testing
    "pytest-benchmark[histogram]>=5.1.0",  # Benchmarking with histogram
    "pytest-mock>=3.14.0",     # Mocking
    "pytest-asyncio>=0.25.3",  # Async testing
    "pytest-timeout>=2.3.1",   # Test timeouts
    "coverage[toml]>=7.6.12"   # Coverage with TOML support
]

# Documentation tools
docs = [
    "sphinx>=7.2.6",
    "sphinx-rtd-theme>=2.0.0",
    "sphinx-autodoc-typehints>=2.0.0",
    "myst-parser>=3.0.0", # Markdown support in Sphinx
]

#------------------------------------------------------------------------------
# COMMAND-LINE SCRIPTS
# Entry points for command-line executables installed with the package.
#------------------------------------------------------------------------------
[project.scripts]
twat-os = "twat_os.__main__:main"

[project.entry-points."twat.plugins"]
os = "twat_os"

# Author information
[[project.authors]]
name = "Adam Twardoch"
email = "adam+github@twardoch.com"

# Project URLs
[project.urls]
Documentation = "https://github.com/twardoch/twat-os#readme"
Issues = "https://github.com/twardoch/twat-os/issues"
Source = "https://github.com/twardoch/twat-os"

#------------------------------------------------------------------------------
# BUILD SYSTEM CONFIGURATION
# Defines the tools required to build the package.
#------------------------------------------------------------------------------
[build-system]
build-backend = "hatchling.build"
requires = [
    "hatchling>=1.27.0",
    "hatch-vcs>=0.4.0"
]

#------------------------------------------------------------------------------
# COVERAGE CONFIGURATION
# Settings for test coverage measurement and reporting.
#------------------------------------------------------------------------------
[tool.coverage.paths]
twat_os = ["src/twat_os", "*/twat-os/src/twat_os"]
tests = ["tests", "*/twat-os/tests"]

[tool.coverage.report]
exclude_lines = [
    "no cov",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:"
]

[tool.coverage.run]
source_pkgs = ["twat_os", "tests"]
branch = true
parallel = true
omit = ["src/twat_os/__about__.py"]

#------------------------------------------------------------------------------
# HATCH BUILD CONFIGURATION
# Configures the build process and development environments.
#------------------------------------------------------------------------------
[tool.hatch.build.hooks.vcs]
version-file = "src/twat_os/__version__.py"

[tool.hatch.build.targets.wheel]
packages = ["src/twat_os"]
include = [
    "src/twat_os/**/*.py",
    "src/twat_os/py.typed"
]
reproducible = true

[tool.hatch.envs.default]
features = ["dev", "test"]

[tool.hatch.envs.default.scripts]
test = "pytest {args:tests}"
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
type-check = "mypy src/twat_os tests"
lint = ["ruff check src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]
fix = ["ruff check --fix --unsafe-fixes src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]

[[tool.hatch.envs.all.matrix]]
python = ["3.10", "3.11", "3.12"]

[tool.hatch.envs.lint]
detached = true
features = ["dev"]

[tool.hatch.envs.lint.scripts]
typing = "mypy --install-types --non-interactive {args:src/twat_os tests}"
style = ["ruff check {args:.}", "ruff format --respect-gitignore {args:.}"]
fmt = ["ruff format --respect-gitignore {args:.}", "ruff check --fix {args:.}"]
all = ["style", "typing"]

[tool.hatch.envs.test]
features = ["test"]

[tool.hatch.envs.test.scripts]
test = "python -m pytest -n auto -p no:briefcase {args:tests}"
test-cov = "python -m pytest -n auto -p no:briefcase --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
bench = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only"
bench-save = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only --benchmark-json=benchmark/results.json"

# Documentation environment
[tool.hatch.envs.docs]
features = ["docs"]

# Documentation environment commands
[tool.hatch.envs.docs.scripts]
build = "sphinx-build -b html docs/source docs/build"

# GitHub Actions workflow configuration
[tool.hatch.envs.ci]
features = ["test"]

[tool.hatch.envs.ci.scripts]
test = "pytest --cov=src/twat_os --cov-report=xml"

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
version_scheme = "post-release"

#------------------------------------------------------------------------------
# MYPY CONFIGURATION
# Configuration for type checking with mypy.
#------------------------------------------------------------------------------
[tool.mypy]
python_version = "3.10"
check_untyped_defs = true
disallow_incomplete_defs = true
disallow_untyped_decorators = true
disallow_untyped_defs = true
no_implicit_optional = true
warn_no_return = true
warn_redundant_casts = true
warn_return_any = true
warn_unreachable = true
warn_unused_configs = true
warn_unused_ignores = true

#------------------------------------------------------------------------------
# RUFF CONFIGURATION
# Configuration for Ruff linting and formatting.
#------------------------------------------------------------------------------
[tool.ruff]
line-length = 88
target-version = "py310"

[tool.ruff.lint]
extend-select = [
    "A",     # flake8-builtins
    "ARG",   # flake8-unused-arguments
    "ASYNC", # flake8-async
    "B",     # flake8-bugbear
    "C",     # flake8-comprehensions
    "DTZ",   # flake8-datetimez
    "E",     # pycodestyle errors
    "EM",    # flake8-errmsg
    "F",     # pyflakes
    "FBT",   # flake8-boolean-trap
    "I",     # isort
    "ICN",   # flake8-import-conventions
    "ISC",   # flake8-implicit-str-concat
    "LOG",   # flake8-logging
    "N",     # pep8-naming
    "PLC",   # pylint convention
    "PLE",   # pylint error
    "PLR",   # pylint refactor
    "PLW",   # pylint warning
    "PT",    # flake8-pytest-style
    "PTH",   # flake8-use-pathlib
    "PYI",   # flake8-pyi
    "RET",   # flake8-return
    "RSE",   # flake8-raise
    "RUF",   # Ruff-specific
    "S",     # flake8-bandit
    "SIM",   # flake8-simplify
    "T",     # flake8-print
    "TCH",   # flake8-type-checking
    "TID",   # flake8-tidy-imports
    "UP",    # pyupgrade
    "W",     # pycodestyle warnings
    "YTT"    # flake8-2020
]

ignore = [
    "ARG001",  # Unused function argument
    "E501",    # Line too long
    "I001",    # Import block formatting
    "RUF001",  # String formatting
    "PLR2004", # Magic numbers
    "EXE003",  # Shebang formatting
    "ISC001",  # Implicit string concatenation
    "B027",    # Empty method in abstract base class
    "C901",    # Function complexity
    "FBT003",  # Boolean positional args
    "PLR0911", # Too many returns
    "PLR0912", # Too many branches
    "PLR0913", # Too many arguments
    "PLR0915", # Too many statements
    "PLW0603", # Global statement usage
    "S105",    # Possible hardcoded password
    "S106",    # Possible hardcoded password
    "S107",    # Possible hardcoded password
    "SIM102"   # Nested if statements
]

unfixable = ["F401"]  # Don't remove unused imports automatically

[tool.ruff.lint.isort]
known-first-party = ["twat_os"]

[tool.ruff.lint.flake8-tidy-imports]
ban-relative-imports = "all"

[tool.ruff.lint.per-file-ignores]
"tests/*" = ["S101", "PLR2004", "TID252"]

#------------------------------------------------------------------------------
# PYTEST CONFIGURATION
# Configuration for pytest testing framework.
#------------------------------------------------------------------------------
[tool.pytest.ini_options]
addopts = "-v --durations=10 -p no:briefcase"
asyncio_mode = "auto"
console_output_style = "progress"
filterwarnings = [
    "ignore::DeprecationWarning",
    "ignore::UserWarning"
]
log_cli = true
log_cli_level = "INFO"
markers = [
    "benchmark: marks tests as benchmarks (select with '-m benchmark')",
    "unit: mark a test as a unit test",
    "integration: mark a test as an integration test",
    "permutation: tests for permutation functionality",
    "parameter: tests for parameter parsing",
    "prompt: tests for prompt parsing"
]
norecursedirs = [
    ".*",
    "build",
    "dist",
    "venv",
    "__pycache__",
    "*.egg-info",
    "_private"
]
python_classes = ["Test*"]
python_files = ["test_*.py"]
python_functions = ["test_*"]
testpaths = ["tests"]

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",    # Minimum time
    "max",    # Maximum time
    "mean",   # Mean time
    "stddev", # Standard deviation
    "median", # Median time
    "iqr",    # Inter-quartile range
    "ops",    # Operations per second
    "rounds"  # Number of rounds
]
```

## TODO.md

```markdown
# TODO

- [ ] Initial task setup.
```

## VERSION.txt

```text
v2.7.5
```

## LOG.md

```markdown
# Log

This file is intended for manual log entries about development progress or significant events. For automated logs from the `cleanup.py` script, please refer to `CLEANUP.txt`.

---
```

## tests/test_package.py

```python
"""Test suite for twat_os."""

import twat_os


def test_version() -> None:
    """Verify package exposes version."""
    assert twat_os.__version__
```

## .github/workflows/release.yml

```yaml
name: Release

on:
  push:
    tags: ["v*"]

permissions:
  contents: write
  id-token: write

jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/twat-os
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

## .github/workflows/push.yml

```yaml
name: Build & Test

on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"

      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"

  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}

      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"

      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/twat_os --cov=tests tests/

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml

  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5
```

## .cursor/rules/cleanup.mdc

```text
---
description: Run `cleanup.py` script before and after changes
globs:
---
Before you do any changes or if I say "cleanup", run the `cleanup.py update` script in the main folder. Analyze the results, describe recent changes in @LOG.md and edit @TODO.md to update priorities and plan next changes. PERFORM THE CHANGES, then run the `cleanup.py status` script and react to the results.

When you edit @TODO.md, lead in lines with empty GFM checkboxes if things aren't done (`- [ ] `) vs. filled (`- [x] `) if done.
```

## .cursor/rules/0project.mdc

```text
---
description: About the twat-os project
globs:
---
# About twat-os

`twat-os` is a Python package providing operating system related utilities for the `twat` ecosystem. Its primary focus is on robust and configurable path management for applications and plugins.

## Key Features:
- **Path Management**: Centralized system for managing application paths (cache, config, data, logs, etc.) using `platformdirs` for cross-platform compatibility and `pydantic` for validation.
- **Configurable**: Path definitions can be customized via a `paths.toml` file.
- **Integration with `twat`**: Designed to function as a plugin within the `twat` framework.
- **Developer Experience**: Clean API with type hints.

## Development Notes
- Uses `uv` for Python package management.
- Quality tools: `ruff` for linting/formatting, `mypy` for type checking, `pytest` for testing.
- Built with Hatch and includes CI/CD setup using GitHub Actions.
- Strong typing and runtime checks are encouraged.
```

## .cursor/rules/filetree.mdc

```text
---
description: File tree of the project
globs:
---
[4.0K]  .
├── [4.0K]  .benchmarks
├── [4.0K]  .cursor
│   └── [4.0K]  rules
│       ├── [ 982]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.2K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [4.0K]  .github
│   └── [4.0K]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.1K]  CHANGELOG.md
├── [1.1K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 187]  LOG.md
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [  34]  TODO.md
├── [   7]  VERSION.txt
├── [ 12K]  cleanup.py
├── [4.0K]  dist
│   └── [   1]  .gitkeep
├── [365K]  llms.txt
├── [ 11K]  pyproject.toml
├── [4.0K]  src
│   └── [4.0K]  twat_os
│       ├── [  95]  __init__.py
│       ├── [4.0K]  __pycache__
│       ├── [8.6K]  paths.py
│       └── [1.0K]  paths.toml
└── [4.0K]  tests
    ├── [4.0K]  __pycache__
    └── [ 149]  test_package.py

12 directories, 24 files
```

## .cursor/rules/quality.mdc

```text
---
description: Quality
globs:
---
- **Verify Information**: Always verify information before presenting it. Do not make assumptions or speculate without clear evidence.
- **No Apologies**: Never use apologies.
- **No Whitespace Suggestions**: Don't suggest whitespace changes.
- **No Inventions**: Don't invent major changes other than what's explicitly requested.
- **No Unnecessary Confirmations**: Don't ask for confirmation of information already provided in the context.
- **Preserve Existing Code**: Don't remove unrelated code or functionalities. Pay attention to preserving existing structures.
- **No Implementation Checks**: Don't ask the user to verify implementations that are visible in the provided context.
- **No Unnecessary Updates**: Don't suggest updates or changes to files when there are no actual modifications needed.
- **No Current Implementation**: Don't show or discuss the current implementation unless specifically requested.
- **Use Explicit Variable Names**: Prefer descriptive, explicit variable names over short, ambiguous ones to enhance code readability.
- **Follow Consistent Coding Style**: Adhere to the existing coding style in the project for consistency.
- **Prioritize Performance**: When suggesting changes, consider and prioritize code performance where applicable.
- **Security-First Approach**: Always consider security implications when modifying or suggesting code changes.
- **Test Coverage**: Suggest or include appropriate unit tests for new or modified code.
- **Error Handling**: Implement robust error handling and logging where necessary.
- **Modular Design**: Encourage modular design principles to improve code maintainability and reusability.
- **Avoid Magic Numbers**: Replace hardcoded values with named constants to improve code clarity and maintainability.
- **Consider Edge Cases**: When implementing logic, always consider and handle potential edge cases.
- **Use Assertions**: Include assertions wherever possible to validate assumptions and catch potential errors early.
```

## README.md

````markdown
#



## Features

- Plugin for twat
- Modern Python packaging with PEP 621 compliance
- Type hints and runtime type checking
- Comprehensive test suite and documentation
- CI/CD ready configuration

## Installation

```bash
pip install twat-os
```

## Usage

```python
import twat_os
plugin = twat_os.plugin
```

## Development

This project uses [Hatch](https://hatch.pypa.io/) for development workflow management.

### Setup Development Environment

```bash
# Install hatch if you haven't already
pip install hatch

# Create and activate development environment
hatch shell

# Run tests
hatch run test

# Run tests with coverage
hatch run test-cov

# Run linting
hatch run lint

# Format code
hatch run format
```

## License

MIT License
````

## LICENSE

```text
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## CHANGELOG.md

```markdown
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]
### Added
- Created `TODO.md`, `LOG.md`, and `CHANGELOG.md`.

### Changed
- Corrected project description in `.cursor/rules/0project.mdc` to accurately describe `twat-os`.

### Refactored
- Simplified `cleanup.py`:
    - Removed internal `repomix` function.
    - Modified the script to call the system `repomix` command and output to `llms.txt` instead of `REPO_CONTENT.txt`.
- Improved `src/twat_os/paths.py`:
    - Added `from typing_extensions import Self` for compatibility.
    - Changed `create_dirs` parameter in `PathManager.__init__` to be keyword-only, resolving Ruff FBT001/FBT002 warnings.
- Updated `pyproject.toml`:
    - Added `pydantic` and `platformdirs` to core project dependencies.
    - Added `typing-extensions` to `dev` dependencies.
    - Removed the `[project.optional-dependencies.all]` group.
    - Updated `tool.hatch.envs.default.features` to exclude `all`.
```

## .gitignore

```text
*_autogen/
.DS_Store
__version__.py
__pycache__/
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
!?*.[Cc]ache/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!**/[Pp]ackages/build/
!Directory.Build.rsp
.*crunch*.local.xml
.axoCover/*
.builds
.cr/personal
.fake/
.history/
.ionide/
.localhistory/
.mfractor/
.ntvs_analysis.dat
.paket/paket.exe
.sass-cache/
.vs/
.vscode
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim_*.settings
*.bim.layout
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
**/[Pp]ackages/*
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
*~
~$*
$tf/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
coverage*.info
coverage*.json
coverage*.xml
csx/
CTestTestfile.cmake
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
ecf/
FakesAssemblies/
FodyWeavers.xsd
Generated_Code/
Generated\ Files/
healthchecksdb
install_manifest.txt
ipch/
Makefile
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
UpgradeLog*.htm
UpgradeLog*.XML
x64/
x86/
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Distribution / packaging
!dist/.gitkeep

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
.ruff_cache/

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Project specific
__version__.py
_private
```

## .pre-commit-config.yaml

```yaml
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]
```

## REPO_CONTENT.txt

````text
This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix. The content has been processed where empty lines have been removed.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: .specstory/**/*.md, .venv/**, _private/**, CLEANUP.txt, **/*.json, *.lock
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.cursor/
  rules/
    0project.mdc
    cleanup.mdc
    filetree.mdc
    quality.mdc
.github/
  workflows/
    push.yml
    release.yml
src/
  twat_os/
    __init__.py
    paths.py
    paths.toml
tests/
  test_package.py
.gitignore
.pre-commit-config.yaml
cleanup.py
LICENSE
pyproject.toml
README.md
VERSION.txt

================================================================
Files
================================================================

================
File: .cursor/rules/0project.mdc
================
---
description: About this project
globs:
---
# About this project

`twat-fs` is a file system utility library focused on robust and extensible file upload capabilities with multiple provider support. It provides:

- Multi-provider upload system with smart fallback (catbox.moe default, plus Dropbox, S3, etc.)
- Automatic retry for temporary failures, fallback for permanent ones
- URL validation and clean developer experience with type hints
- Simple CLI: `python -m twat_fs upload_file path/to/file.txt`
- Easy installation: `uv pip install twat-fs` (basic) or `uv pip install 'twat-fs[all,dev]'` (all features)

## Development Notes
- Uses `uv` for Python package management
- Quality tools: ruff, mypy, pytest
- Clear provider protocol for adding new storage backends
- Strong typing and runtime checks throughout

================
File: .cursor/rules/cleanup.mdc
================
---
description: Run `cleanup.py` script before and after changes
globs:
---
Before you do any changes or if I say "cleanup", run the `cleanup.py update` script in the main folder. Analyze the results, describe recent changes in @LOG.md and edit @TODO.md to update priorities and plan next changes. PERFORM THE CHANGES, then run the `cleanup.py status` script and react to the results.

When you edit @TODO.md, lead in lines with empty GFM checkboxes if things aren't done (`- [ ] `) vs. filled (`- [x] `) if done.

================
File: .cursor/rules/filetree.mdc
================
---
description: File tree of the project
globs:
---
[ 736]  .
├── [  64]  .benchmarks
├── [  96]  .cursor
│   └── [ 224]  rules
│       ├── [ 821]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.0K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [  96]  .github
│   └── [ 128]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.0K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [   7]  VERSION.txt
├── [ 13K]  cleanup.py
├── [ 192]  dist
│   └── [   1]  .gitkeep
├── [5.6K]  pyproject.toml
├── [  96]  src
│   └── [ 224]  twat_os
│       ├── [  95]  __init__.py
│       ├── [7.4K]  paths.py
│       └── [1.0K]  paths.toml
└── [ 128]  tests
    └── [ 145]  test_package.py

10 directories, 20 files

================
File: .cursor/rules/quality.mdc
================
---
description: Quality
globs:
---
- **Verify Information**: Always verify information before presenting it. Do not make assumptions or speculate without clear evidence.
- **No Apologies**: Never use apologies.
- **No Whitespace Suggestions**: Don't suggest whitespace changes.
- **No Inventions**: Don't invent major changes other than what's explicitly requested.
- **No Unnecessary Confirmations**: Don't ask for confirmation of information already provided in the context.
- **Preserve Existing Code**: Don't remove unrelated code or functionalities. Pay attention to preserving existing structures.
- **No Implementation Checks**: Don't ask the user to verify implementations that are visible in the provided context.
- **No Unnecessary Updates**: Don't suggest updates or changes to files when there are no actual modifications needed.
- **No Current Implementation**: Don't show or discuss the current implementation unless specifically requested.
- **Use Explicit Variable Names**: Prefer descriptive, explicit variable names over short, ambiguous ones to enhance code readability.
- **Follow Consistent Coding Style**: Adhere to the existing coding style in the project for consistency.
- **Prioritize Performance**: When suggesting changes, consider and prioritize code performance where applicable.
- **Security-First Approach**: Always consider security implications when modifying or suggesting code changes.
- **Test Coverage**: Suggest or include appropriate unit tests for new or modified code.
- **Error Handling**: Implement robust error handling and logging where necessary.
- **Modular Design**: Encourage modular design principles to improve code maintainability and reusability.
- **Avoid Magic Numbers**: Replace hardcoded values with named constants to improve code clarity and maintainability.
- **Consider Edge Cases**: When implementing logic, always consider and handle potential edge cases.
- **Use Assertions**: Include assertions wherever possible to validate assumptions and catch potential errors early.

================
File: .github/workflows/push.yml
================
name: Build & Test
on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:
permissions:
  contents: write
  id-token: write
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true
jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"
      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"
  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}
      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"
      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/twat_os --cov=tests tests/
      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml
  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true
      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs
      - name: Build distributions
        run: uv run python -m build --outdir dist
      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5

================
File: .github/workflows/release.yml
================
name: Release
on:
  push:
    tags: ["v*"]
permissions:
  contents: write
  id-token: write
jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/twat-os
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true
      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs
      - name: Build distributions
        run: uv run python -m build --outdir dist
      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)
      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

================
File: src/twat_os/__init__.py
================
__version__ = metadata.version(__name__)

================
File: src/twat_os/paths.py
================
PATHS_TOML = Path(__file__).parent / "paths.toml"
DEFAULT_PATHS = tomli.loads(PATHS_TOML.read_text())
class PathConfig(BaseModel):
    @field_validator("base_dir", "package_dir")
    def expand_path(cls, v: str | Path | None) -> Path | None:
        if isinstance(v, str):
            expanded = os.path.expandvars(os.path.expanduser(v))
            return Path(expanded)
    @model_validator(mode="after")
    def validate_and_create_dirs(self) -> Self:
            self.base_dir.mkdir(parents=True, exist_ok=True)
                self.package_dir.mkdir(parents=True, exist_ok=True)
class CacheConfig(PathConfig):
    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_cache_dir()) / "twat"
class ConfigDirConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_config_dir()) / "twat"
class DataDirConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat"
class TempDirConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_runtime_dir()) / "twat"
class GenAIConfig(PathConfig):
    lora_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/loras"
    model_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/models"
    output_dir: Path = Field(
        default_factory=lambda: Path.home() / "Pictures/twat_genai"
    def validate_and_create_all_dirs(self) -> Self:
            self.lora_dir.mkdir(parents=True, exist_ok=True)
            self.model_dir.mkdir(parents=True, exist_ok=True)
            self.output_dir.mkdir(parents=True, exist_ok=True)
class LogConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_state_dir()) / "twat/logs"
class PathManager:
    def __init__(
            config_path = Path(config_file)
            if not config_path.exists():
                raise FileNotFoundError(msg)
            self.config = tomli.loads(config_path.read_text())
        self._init_paths()
    def _init_paths(self) -> None:
        def format_path(path_str: str) -> Path | None:
            expanded = os.path.expandvars(os.path.expanduser(path_str))
            return Path(expanded.format(package_name=self.package_name))
        self.cache = CacheConfig(
            package_dir=format_path(self.config["cache"]["package_dir"]),
        self.config_dir = ConfigDirConfig(
            package_dir=format_path(self.config["config"]["package_dir"]),
        self.data = DataDirConfig(
            package_dir=format_path(self.config["data"]["package_dir"]),
        self.temp = TempDirConfig(
            package_dir=format_path(self.config["temp"]["package_dir"]),
        self.genai = GenAIConfig(
        self.logs = LogConfig(
            package_dir=format_path(self.config["logs"]["package_dir"]),
    def get_path(self, category: str, key: str = "base_dir") -> Path:
        config = getattr(self, category)
        return getattr(config, key)
    def for_package(
        return cls(package_name=package_name, config_file=config_file)
    def __repr__(self) -> str:

================
File: src/twat_os/paths.toml
================
[cache]
# Base directory for all cache operations
base_dir = "~/.cache/twat"
# Directory for storing package-specific cache data
package_dir = "~/.cache/twat/{package_name}"

[config]
# Base directory for configuration files
base_dir = "~/.config/twat"
# Directory for package-specific configuration
package_dir = "~/.config/twat/{package_name}"

[data]
# Base directory for user data
base_dir = "~/.local/share/twat"
# Directory for package-specific data
package_dir = "~/.local/share/twat/{package_name}"

[temp]
# Base directory for temporary files
base_dir = "~/tmp/twat"
# Directory for package-specific temporary files
package_dir = "~/tmp/twat/{package_name}"

[genai]
# Directory for storing LoRA files
lora_dir = "~/.local/share/twat/genai/loras"
# Directory for model weights
model_dir = "~/.local/share/twat/genai/models"
# Directory for generated images
output_dir = "~/Pictures/twat_genai"

[logs]
# Base directory for log files
base_dir = "~/.local/state/twat/logs"
# Directory for package-specific logs
package_dir = "~/.local/state/twat/logs/{package_name}"

================
File: tests/test_package.py
================
def test_version():

================
File: .gitignore
================
*_autogen/
.DS_Store
__version__.py
__pycache__/
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
!?*.[Cc]ache/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!**/[Pp]ackages/build/
!Directory.Build.rsp
.*crunch*.local.xml
.axoCover/*
.builds
.cr/personal
.fake/
.history/
.ionide/
.localhistory/
.mfractor/
.ntvs_analysis.dat
.paket/paket.exe
.sass-cache/
.vs/
.vscode
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim_*.settings
*.bim.layout
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
**/[Pp]ackages/*
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
*~
~$*
$tf/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
coverage*.info
coverage*.json
coverage*.xml
csx/
CTestTestfile.cmake
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
ecf/
FakesAssemblies/
FodyWeavers.xsd
Generated_Code/
Generated\ Files/
healthchecksdb
install_manifest.txt
ipch/
Makefile
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
UpgradeLog*.htm
UpgradeLog*.XML
x64/
x86/
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Distribution / packaging
!dist/.gitkeep

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
.ruff_cache/

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Project specific
__version__.py
_private

================
File: .pre-commit-config.yaml
================
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]

================
File: cleanup.py
================
LOG_FILE = Path("CLEANUP.txt")
os.chdir(Path(__file__).parent)
def new() -> None:
    if LOG_FILE.exists():
        LOG_FILE.unlink()
def prefix() -> None:
    readme = Path(".cursor/rules/0project.mdc")
    if readme.exists():
        log_message("\n=== PROJECT STATEMENT ===")
        content = readme.read_text()
        log_message(content)
def suffix() -> None:
    todo = Path("TODO.md")
    if todo.exists():
        log_message("\n=== TODO.md ===")
        content = todo.read_text()
def log_message(message: str) -> None:
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
    with LOG_FILE.open("a") as f:
        f.write(log_line)
def run_command(cmd: list[str], check: bool = True) -> subprocess.CompletedProcess:
        result = subprocess.run(
            log_message(result.stdout)
        log_message(f"Command failed: {' '.join(cmd)}")
        log_message(f"Error: {e.stderr}")
        return subprocess.CompletedProcess(cmd, 1, "", str(e))
def check_command_exists(cmd: str) -> bool:
        return which(cmd) is not None
class Cleanup:
    def __init__(self) -> None:
        self.workspace = Path.cwd()
    def _print_header(self, message: str) -> None:
        log_message(f"\n=== {message} ===")
    def _check_required_files(self) -> bool:
            if not (self.workspace / file).exists():
                log_message(f"Error: {file} is missing")
    def _generate_tree(self) -> None:
        if not check_command_exists("tree"):
            log_message("Warning: 'tree' command not found. Skipping tree generation.")
            rules_dir = Path(".cursor/rules")
            rules_dir.mkdir(parents=True, exist_ok=True)
            tree_result = run_command(["tree", "-a", "-I", ".git", "--gitignore", "-n", "-h", "-I", "*_cache"])
            with open(rules_dir / "filetree.mdc", "w") as f:
                f.write("---\ndescription: File tree of the project\nglobs: \n---\n")
                f.write(tree_text)
            log_message("\nProject structure:")
            log_message(tree_text)
            log_message(f"Failed to generate tree: {e}")
    def _git_status(self) -> bool:
        result = run_command(["git", "status", "--porcelain"], check=False)
        return bool(result.stdout.strip())
    def _venv(self) -> None:
        log_message("Setting up virtual environment")
            run_command(["uv", "venv"])
            if venv_path.exists():
                os.environ["VIRTUAL_ENV"] = str(self.workspace / ".venv")
                log_message("Virtual environment created and activated")
                log_message("Virtual environment created but activation failed")
            log_message(f"Failed to create virtual environment: {e}")
    def _install(self) -> None:
        log_message("Installing package with all extras")
            self._venv()
            run_command(["uv", "pip", "install", "-e", ".[test,dev]"])
            log_message("Package installed successfully")
            log_message(f"Failed to install package: {e}")
    def _run_checks(self) -> None:
        log_message("Running code quality checks")
            log_message(">>> Running code fixes...")
            run_command(
            log_message(">>>Running type checks...")
            run_command(["python", "-m", "mypy", "src", "tests"], check=False)
            log_message(">>> Running tests...")
            run_command(["python", "-m", "pytest", "tests"], check=False)
            log_message("All checks completed")
            log_message(f"Failed during checks: {e}")
    def status(self) -> None:
        prefix()  # Add README.md content at start
        self._print_header("Current Status")
        self._check_required_files()
        self._generate_tree()
        result = run_command(["git", "status"], check=False)
        self._print_header("Environment Status")
        self._install()
        self._run_checks()
        suffix()  # Add TODO.md content at end
    def venv(self) -> None:
        self._print_header("Virtual Environment Setup")
    def install(self) -> None:
        self._print_header("Package Installation")
    def update(self) -> None:
        self.status()
        if self._git_status():
            log_message("Changes detected in repository")
                run_command(["git", "add", "."])
                run_command(["git", "commit", "-m", commit_msg])
                log_message("Changes committed successfully")
                log_message(f"Failed to commit changes: {e}")
            log_message("No changes to commit")
    def push(self) -> None:
        self._print_header("Pushing Changes")
            run_command(["git", "push"])
            log_message("Changes pushed successfully")
            log_message(f"Failed to push changes: {e}")
def repomix(
            cmd.append("--compress")
            cmd.append("--remove-empty-lines")
            cmd.append("-i")
            cmd.append(ignore_patterns)
        cmd.extend(["-o", output_file])
        run_command(cmd)
        log_message(f"Repository content mixed into {output_file}")
        log_message(f"Failed to mix repository: {e}")
def print_usage() -> None:
    log_message("Usage:")
    log_message("  cleanup.py status   # Show current status and run all checks")
    log_message("  cleanup.py venv     # Create virtual environment")
    log_message("  cleanup.py install  # Install package with all extras")
    log_message("  cleanup.py update   # Update and commit changes")
    log_message("  cleanup.py push     # Push changes to remote")
def main() -> NoReturn:
    new()  # Clear log file
    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)
    cleanup = Cleanup()
            cleanup.status()
            cleanup.venv()
            cleanup.install()
            cleanup.update()
            cleanup.push()
        log_message(f"Error: {e}")
    repomix()
    sys.stdout.write(Path("CLEANUP.txt").read_text())
    sys.exit(0)  # Ensure we exit with a status code
    main()

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: pyproject.toml
================
# this_file: pyproject.toml
# this_project: twat_os
[project]
name = "twat-os"
dynamic = ["version"]
description = "Operating system utilities for twat"
readme = "README.md"
requires-python = ">=3.10"
license = "MIT"
keywords = [
    "os",
    "system",
    "twat"
]
classifiers = [
    "Development Status :: 4 - Beta",
    "Programming Language :: Python",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
]

dependencies = [
    "fire>=0.6.0",
    "loguru>=0.7.2",
    "twat>=1.8.1"
]

[project.optional-dependencies]
dev = [
    "hatch>=1.14.0",
    "hatchling>=1.27.0",
    "hatch-vcs>=0.4.0",
    "mypy>=1.15.0",
    "pre-commit>=4.1.0",
    "pyupgrade>=3.19.1",
    "ruff>=0.9.6"
]

test = [
    "pytest>=8.3.4",
    "pytest-cov>=6.0.0",
    "pytest-benchmark>=5.1.0",
    "pytest-mock>=3.14.0",
    "pytest-asyncio>=0.25.3",
    "pytest-timeout>=2.3.1"
]

all = [
    "fire>=0.6.0",
    "loguru>=0.7.2",
    "twat>=1.8.1"
]

[project.scripts]
twat-os = "twat_os.__main__:main"

[project.entry-points."twat.plugins"]
os = "twat_os"

[[project.authors]]
name = "Adam Twardoch"
email = "adam+github@twardoch.com"

[project.urls]
Documentation = "https://github.com/twardoch/twat-os#readme"
Issues = "https://github.com/twardoch/twat-os/issues"
Source = "https://github.com/twardoch/twat-os"

[build-system]
build-backend = "hatchling.build"
requires = [
    "hatchling>=1.27.0",
    "hatch-vcs>=0.4.0"
]

[tool.coverage.paths]
twat_os = ["src/twat_os", "*/twat-os/src/twat_os"]
tests = ["tests", "*/twat-os/tests"]

[tool.coverage.report]
exclude_lines = [
    "no cov",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:"
]

[tool.coverage.run]
source_pkgs = ["twat_os", "tests"]
branch = true
parallel = true
omit = ["src/twat_os/__about__.py"]

[tool.hatch.build.hooks.vcs]
version-file = "src/twat_os/__version__.py"

[tool.hatch.build.targets.wheel]
packages = ["src/twat_os"]
include = [
    "src/twat_os/**/*.py",
    "src/twat_os/py.typed"
]

[tool.hatch.envs.default]
dependencies = [
    "pytest>=8.3.4",
    "pytest-cov>=6.0.0",
    "ruff>=0.9.6",
    "mypy>=1.15.0"
]

[tool.hatch.envs.default.scripts]
test = "pytest {args:tests}"
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
type-check = "mypy src/twat_os tests"
lint = ["ruff check src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]
fix = ["ruff check --fix --unsafe-fixes src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]

[[tool.hatch.envs.all.matrix]]
python = ["3.10", "3.11", "3.12"]

[tool.hatch.envs.lint]
detached = true
dependencies = [
    "pytest>=8.3.4",
    "pytest-cov>=6.0.0",
    "ruff>=0.9.6",
    "mypy>=1.15.0"
]

[tool.hatch.envs.lint.scripts]
typing = "mypy --install-types --non-interactive {args:src/twat_os tests}"
style = ["ruff check {args:.}", "ruff format --respect-gitignore {args:.}"]
fmt = ["ruff format --respect-gitignore {args:.}", "ruff check --fix {args:.}"]
all = ["style", "typing"]

[tool.hatch.envs.test]
dependencies = []

[tool.hatch.envs.test.scripts]
test = "python -m pytest -n auto -p no:briefcase {args:tests}"
test-cov = "python -m pytest -n auto -p no:briefcase --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
bench = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only"
bench-save = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only --benchmark-json=benchmark/results.json"

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
version_scheme = "post-release"

[tool.mypy]
python_version = "3.10"
check_untyped_defs = true
disallow_incomplete_defs = true
disallow_untyped_decorators = true
disallow_untyped_defs = true
no_implicit_optional = true
warn_no_return = true
warn_redundant_casts = true
warn_return_any = true
warn_unreachable = true
warn_unused_configs = true
warn_unused_ignores = true

[tool.ruff]
line-length = 88
target-version = "py310"

[tool.ruff.lint]
extend-select = [
    "A",
    "ARG",
    "B",
    "C",
    "DTZ",
    "E",
    "EM",
    "F",
    "FBT",
    "I",
    "ICN",
    "ISC",
    "N",
    "PLC",
    "PLE",
    "PLR",
    "PLW",
    "Q",
    "RUF",
    "S",
    "T",
    "TID",
    "UP",
    "W",
    "YTT"
]
ignore = [
    "ARG001",
    "E501",
    "I001",
    "RUF001",
    "PLR2004",
    "EXE003",
    "ISC001"
]

[tool.ruff.per-file-ignores]
"tests/*" = ["S101"]

[tool.pytest.ini_options]
addopts = "-v --durations=10 -p no:briefcase"
asyncio_mode = "auto"
console_output_style = "progress"
filterwarnings = [
    "ignore::DeprecationWarning",
    "ignore::UserWarning"
]
log_cli = true
log_cli_level = "INFO"
markers = [
    "benchmark: marks tests as benchmarks (select with '-m benchmark')",
    "unit: mark a test as a unit test",
    "integration: mark a test as an integration test",
    "permutation: tests for permutation functionality",
    "parameter: tests for parameter parsing",
    "prompt: tests for prompt parsing"
]
norecursedirs = [
    ".*",
    "build",
    "dist",
    "venv",
    "__pycache__",
    "*.egg-info",
    "_private"
]
python_classes = ["Test*"]
python_files = ["test_*.py"]
python_functions = ["test_*"]
testpaths = ["tests"]

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",
    "max",
    "mean",
    "stddev",
    "median",
    "iqr",
    "ops",
    "rounds"
]

================
File: README.md
================
#



## Features

- Plugin for twat
- Modern Python packaging with PEP 621 compliance
- Type hints and runtime type checking
- Comprehensive test suite and documentation
- CI/CD ready configuration

## Installation

```bash
pip install twat-os
```

## Usage

```python
import twat_os
plugin = twat_os.plugin
```

## Development

This project uses [Hatch](https://hatch.pypa.io/) for development workflow management.

### Setup Development Environment

```bash
# Install hatch if you haven't already
pip install hatch

# Create and activate development environment
hatch shell

# Run tests
hatch run test

# Run tests with coverage
hatch run test-cov

# Run linting
hatch run lint

# Format code
hatch run format
```

## License

MIT License

================
File: VERSION.txt
================
v2.6.2



================================================================
End of Codebase
================================================================
````

## CLEANUP.txt

```text
2025-06-25 10:55:47 -
=== PROJECT STATEMENT ===
2025-06-25 10:55:47 - ---
description: About the twat-os project
globs:
---
# About twat-os

`twat-os` is a Python package providing operating system related utilities for the `twat` ecosystem. Its primary focus is on robust and configurable path management for applications and plugins.

## Key Features:
- **Path Management**: Centralized system for managing application paths (cache, config, data, logs, etc.) using `platformdirs` for cross-platform compatibility and `pydantic` for validation.
- **Configurable**: Path definitions can be customized via a `paths.toml` file.
- **Integration with `twat`**: Designed to function as a plugin within the `twat` framework.
- **Developer Experience**: Clean API with type hints.

## Development Notes
- Uses `uv` for Python package management.
- Quality tools: `ruff` for linting/formatting, `mypy` for type checking, `pytest` for testing.
- Built with Hatch and includes CI/CD setup using GitHub Actions.
- Strong typing and runtime checks are encouraged.

2025-06-25 10:55:47 -
=== Current Status ===
2025-06-25 10:55:47 - [4.0K]  .
├── [4.0K]  .benchmarks
├── [4.0K]  .cursor
│   └── [4.0K]  rules
│       ├── [ 982]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.2K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [4.0K]  .github
│   └── [4.0K]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.1K]  CHANGELOG.md
├── [1.1K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 187]  LOG.md
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [  34]  TODO.md
├── [   7]  VERSION.txt
├── [ 12K]  cleanup.py
├── [4.0K]  dist
│   └── [   1]  .gitkeep
├── [365K]  llms.txt
├── [ 11K]  pyproject.toml
├── [4.0K]  src
│   └── [4.0K]  twat_os
│       ├── [  95]  __init__.py
│       ├── [4.0K]  __pycache__
│       ├── [8.6K]  paths.py
│       └── [1.0K]  paths.toml
└── [4.0K]  tests
    ├── [4.0K]  __pycache__
    └── [ 149]  test_package.py

12 directories, 24 files

2025-06-25 10:55:47 -
Project structure:
2025-06-25 10:55:47 - [4.0K]  .
├── [4.0K]  .benchmarks
├── [4.0K]  .cursor
│   └── [4.0K]  rules
│       ├── [ 982]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.2K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [4.0K]  .github
│   └── [4.0K]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.1K]  CHANGELOG.md
├── [1.1K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 187]  LOG.md
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [  34]  TODO.md
├── [   7]  VERSION.txt
├── [ 12K]  cleanup.py
├── [4.0K]  dist
│   └── [   1]  .gitkeep
├── [365K]  llms.txt
├── [ 11K]  pyproject.toml
├── [4.0K]  src
│   └── [4.0K]  twat_os
│       ├── [  95]  __init__.py
│       ├── [4.0K]  __pycache__
│       ├── [8.6K]  paths.py
│       └── [1.0K]  paths.toml
└── [4.0K]  tests
    ├── [4.0K]  __pycache__
    └── [ 149]  test_package.py

12 directories, 24 files

2025-06-25 10:55:47 - HEAD detached from 23e0688
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   .cursor/rules/filetree.mdc
	modified:   CLEANUP.txt

no changes added to commit (use "git add" and/or "git commit -a")

2025-06-25 10:55:47 - HEAD detached from 23e0688
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   .cursor/rules/filetree.mdc
	modified:   CLEANUP.txt

no changes added to commit (use "git add" and/or "git commit -a")

2025-06-25 10:55:47 -
=== Environment Status ===
2025-06-25 10:55:47 - Setting up virtual environment
2025-06-25 10:55:47 - Virtual environment created and activated
2025-06-25 10:55:47 - Installing package with all extras
2025-06-25 10:55:47 - Setting up virtual environment
2025-06-25 10:55:47 - Virtual environment created and activated
2025-06-25 10:55:49 - Package installed successfully
2025-06-25 10:55:49 - Running code quality checks
2025-06-25 10:55:49 - >>> Running code fixes...
2025-06-25 10:55:49 - src/twat_os/paths.py:15:35: F401 `typing.cast` imported but unused
   |
13 | import os
14 | from pathlib import Path
15 | from typing import TYPE_CHECKING, cast
   |                                   ^^^^ F401
16 |
17 | import platformdirs
   |
   = help: Remove unused import: `typing.cast`

Found 1 error.

2025-06-25 10:55:49 - 1 file reformatted, 2 files left unchanged

2025-06-25 10:55:49 - >>>Running type checks...
2025-06-25 10:55:50 - Success: no issues found in 4 source files

2025-06-25 10:55:50 - >>> Running tests...
2025-06-25 10:55:52 - ============================= test session starts ==============================
platform linux -- Python 3.12.11, pytest-8.4.1, pluggy-1.6.0 -- /app/.venv/bin/python
cachedir: .pytest_cache
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /app
configfile: pyproject.toml
plugins: asyncio-1.0.0, benchmark-5.1.0, mock-3.14.1, timeout-2.4.0, cov-6.2.1, anyio-4.9.0, xdist-3.7.0
asyncio: mode=Mode.AUTO, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 1 item

tests/test_package.py::test_version PASSED                               [100%]

============================= slowest 10 durations =============================

(3 durations < 0.005s hidden.  Use -vv to show these durations.)
============================== 1 passed in 0.02s ===============================

2025-06-25 10:55:52 - All checks completed
2025-06-25 10:55:52 -
=== TODO.md ===
2025-06-25 10:55:52 - # TODO

- [ ] Initial task setup.
```

## llms.txt

````````text
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-06-25 10:55:32

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
cleanup.py
src
  twat_os
    __init__.py
    paths.toml
    paths.py
pyproject.toml
TODO.md
VERSION.txt
LOG.md
tests
  test_package.py
.github
  workflows
    release.yml
    push.yml
.cursor
  rules
    cleanup.mdc
    0project.mdc
    filetree.mdc
    quality.mdc
README.md
LICENSE
CHANGELOG.md
.gitignore
.pre-commit-config.yaml
REPO_CONTENT.txt
CLEANUP.txt
llms.txt
```

# Repository Files


## cleanup.py

```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = [
#   "ruff>=0.9.6",
#   "pytest>=8.3.4",
#   "mypy>=1.15.0",
# ]
# ///
# this_file: cleanup.py

"""
Cleanup tool for managing repository tasks and maintaining code quality.

This script provides a comprehensive set of commands for repository maintenance:

When to use each command:

- `cleanup.py status`: Use this FIRST when starting work to check the current state
  of the repository. It shows file structure, git status, and runs all code quality
  checks. Run this before making any changes to ensure you're starting from a clean state.

- `cleanup.py venv`: Run this when setting up the project for the first time or if
  your virtual environment is corrupted/missing. Creates a new virtual environment
  using uv.

- `cleanup.py install`: Use after `venv` or when dependencies have changed. Installs
  the package and all development dependencies in editable mode.

- `cleanup.py update`: Run this when you've made changes and want to commit them.
  It will:
  1. Show current status (like `status` command)
  2. Stage and commit any changes with a generic message
  Use this for routine maintenance commits.

- `cleanup.py push`: Run this after `update` when you want to push your committed
  changes to the remote repository.

Workflow Example:
1. Start work: `cleanup.py status`
2. Make changes to code
3. Commit changes: `cleanup.py update`
4. Push to remote: `cleanup.py push`

The script maintains a CLEANUP.txt file that records all operations with timestamps.
It also includes content from README.md at the start and TODO.md at the end of logs
for context.

Required Files:
- LOG.md: Project changelog
- README.md: Project documentation
- TODO.md: Pending tasks and future plans
"""

import subprocess
import os
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import NoReturn
from shutil import which

# Configuration
IGNORE_PATTERNS = [
    ".git",
    ".venv",
    "__pycache__",
    "*.pyc",
    "dist",
    "build",
    "*.egg-info",
]
REQUIRED_FILES = ["LOG.md", ".cursor/rules/0project.mdc", "TODO.md"]
LOG_FILE = Path("CLEANUP.txt")

# Ensure we're working from the script's directory
os.chdir(Path(__file__).parent)


def new() -> None:
    """Remove existing log file."""
    if LOG_FILE.exists():
        LOG_FILE.unlink()


def prefix() -> None:
    """Write README.md content to log file."""
    readme = Path(".cursor/rules/0project.mdc")
    if readme.exists():
        log_message("\n=== PROJECT STATEMENT ===")
        content = readme.read_text()
        log_message(content)


def suffix() -> None:
    """Write TODO.md content to log file."""
    todo = Path("TODO.md")
    if todo.exists():
        log_message("\n=== TODO.md ===")
        content = todo.read_text()
        log_message(content)


def log_message(message: str) -> None:
    """Log a message to file and console with timestamp."""
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
    log_line = f"{timestamp} - {message}\n"
    with LOG_FILE.open("a") as f:
        f.write(log_line)


def run_command(cmd: list[str], check: bool = True) -> subprocess.CompletedProcess:
    """Run a shell command and return the result."""
    try:
        result = subprocess.run(
            cmd,
            check=check,
            capture_output=True,
            text=True,
            shell=False,  # Explicitly set shell=False for security
        )
        if result.stdout:
            log_message(result.stdout)
        return result
    except subprocess.CalledProcessError as e:
        log_message(f"Command failed: {' '.join(cmd)}")
        log_message(f"Error: {e.stderr}")
        if check:
            raise
        return subprocess.CompletedProcess(cmd, 1, "", str(e))


def check_command_exists(cmd: str) -> bool:
    """Check if a command exists in the system."""
    try:
        return which(cmd) is not None
    except Exception:
        return False


class Cleanup:
    """Main cleanup tool class."""

    def __init__(self) -> None:
        self.workspace = Path.cwd()

    def _print_header(self, message: str) -> None:
        """Print a section header."""
        log_message(f"\n=== {message} ===")

    def _check_required_files(self) -> bool:
        """Check if all required files exist."""
        missing = False
        for file in REQUIRED_FILES:
            if not (self.workspace / file).exists():
                log_message(f"Error: {file} is missing")
                missing = True
        return not missing

    def _generate_tree(self) -> None:
        """Generate and display tree structure of the project."""
        if not check_command_exists("tree"):
            log_message("Warning: 'tree' command not found. Skipping tree generation.")
            return

        try:
            # Create/overwrite the file with YAML frontmatter
            rules_dir = Path(".cursor/rules")
            rules_dir.mkdir(parents=True, exist_ok=True)
            # Get tree output
            tree_result = run_command(["tree", "-a", "-I", ".git", "--gitignore", "-n", "-h", "-I", "*_cache"])
            tree_text = tree_result.stdout
            # Write frontmatter and tree output to file
            with open(rules_dir / "filetree.mdc", "w") as f:
                f.write("---\ndescription: File tree of the project\nglobs: \n---\n")
                f.write(tree_text)

            # Log the contents
            log_message("\nProject structure:")
            log_message(tree_text)

        except Exception as e:
            log_message(f"Failed to generate tree: {e}")
        return

    def _git_status(self) -> bool:
        """Check git status and return True if there are changes."""
        result = run_command(["git", "status", "--porcelain"], check=False)
        return bool(result.stdout.strip())

    def _venv(self) -> None:
        """Create and activate virtual environment using uv."""
        log_message("Setting up virtual environment")
        try:
            run_command(["uv", "venv"])
            # Activate the virtual environment
            venv_path = self.workspace / ".venv" / "bin" / "activate"
            if venv_path.exists():
                os.environ["VIRTUAL_ENV"] = str(self.workspace / ".venv")
                os.environ["PATH"] = f"{self.workspace / '.venv' / 'bin'}{os.pathsep}{os.environ['PATH']}"
                log_message("Virtual environment created and activated")
            else:
                log_message("Virtual environment created but activation failed")
        except Exception as e:
            log_message(f"Failed to create virtual environment: {e}")

    def _install(self) -> None:
        """Install package in development mode with all extras."""
        log_message("Installing package with all extras")
        try:
            self._venv()
            run_command(["uv", "pip", "install", "-e", ".[test,dev]"])
            log_message("Package installed successfully")
        except Exception as e:
            log_message(f"Failed to install package: {e}")

    def _run_checks(self) -> None:
        """Run code quality checks using ruff and pytest."""
        log_message("Running code quality checks")

        try:
            # Run ruff checks
            log_message(">>> Running code fixes...")
            run_command(
                [
                    "python",
                    "-m",
                    "ruff",
                    "check",
                    "--fix",
                    "--unsafe-fixes",
                    "src",
                    "tests",
                ],
                check=False,
            )
            run_command(
                [
                    "python",
                    "-m",
                    "ruff",
                    "format",
                    "--respect-gitignore",
                    "src",
                    "tests",
                ],
                check=False,
            )

            # Run type checks
            log_message(">>>Running type checks...")
            run_command(["python", "-m", "mypy", "src", "tests"], check=False)

            # Run tests
            log_message(">>> Running tests...")
            run_command(["python", "-m", "pytest", "tests"], check=False)

            log_message("All checks completed")
        except Exception as e:
            log_message(f"Failed during checks: {e}")

    def status(self) -> None:
        """Show current repository status: tree structure, git status, and run checks."""
        prefix()  # Add README.md content at start
        self._print_header("Current Status")

        # Check required files
        self._check_required_files()

        # Show tree structure
        self._generate_tree()

        # Show git status
        result = run_command(["git", "status"], check=False)
        log_message(result.stdout)

        # Run additional checks
        self._print_header("Environment Status")
        self._venv()
        self._install()
        self._run_checks()

        suffix()  # Add TODO.md content at end

    def venv(self) -> None:
        """Create and activate virtual environment."""
        self._print_header("Virtual Environment Setup")
        self._venv()

    def install(self) -> None:
        """Install package with all extras."""
        self._print_header("Package Installation")
        self._install()

    def update(self) -> None:
        """Show status and commit any changes if needed."""
        # First show current status
        self.status()

        # Then handle git changes if any
        if self._git_status():
            log_message("Changes detected in repository")
            try:
                # Add all changes
                run_command(["git", "add", "."])
                # Commit changes
                commit_msg = "Update repository files"
                run_command(["git", "commit", "-m", commit_msg])
                log_message("Changes committed successfully")
            except Exception as e:
                log_message(f"Failed to commit changes: {e}")
        else:
            log_message("No changes to commit")

    def push(self) -> None:
        """Push changes to remote repository."""
        self._print_header("Pushing Changes")
        try:
            run_command(["git", "push"])
            log_message("Changes pushed successfully")
        except Exception as e:
            log_message(f"Failed to push changes: {e}")


def print_usage() -> None:
    """Print usage information."""
    log_message("Usage:")
    log_message("  cleanup.py status   # Show current status and run all checks")
    log_message("  cleanup.py venv     # Create virtual environment")
    log_message("  cleanup.py install  # Install package with all extras")
    log_message("  cleanup.py update   # Update and commit changes")
    log_message("  cleanup.py push     # Push changes to remote")


def main() -> NoReturn:
    """Main entry point."""
    new()  # Clear log file

    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)

    command = sys.argv[1]
    cleanup = Cleanup()

    try:
        if command == "status":
            cleanup.status()
        elif command == "venv":
            cleanup.venv()
        elif command == "install":
            cleanup.install()
        elif command == "update":
            cleanup.update()
        elif command == "push":
            cleanup.push()
        else:
            print_usage()
    except Exception as e:
        log_message(f"Error: {e}")
    # Call the system-installed repomix to generate llms.txt
    run_command(["repomix", "-o", "llms.txt", "."])
    log_message("Repository content mixed into llms.txt by system repomix call.")
    sys.stdout.write(Path("CLEANUP.txt").read_text())
    sys.exit(0)  # Ensure we exit with a status code


if __name__ == "__main__":
    main()
```

## src/twat_os/__init__.py

```python
"""twat os plugin"""

from importlib import metadata

__version__ = metadata.version(__name__)
```

## src/twat_os/paths.toml

```text
[cache]
# Base directory for all cache operations
base_dir = "~/.cache/twat"
# Directory for storing package-specific cache data
package_dir = "~/.cache/twat/{package_name}"

[config]
# Base directory for configuration files
base_dir = "~/.config/twat"
# Directory for package-specific configuration
package_dir = "~/.config/twat/{package_name}"

[data]
# Base directory for user data
base_dir = "~/.local/share/twat"
# Directory for package-specific data
package_dir = "~/.local/share/twat/{package_name}"

[temp]
# Base directory for temporary files
base_dir = "~/tmp/twat"
# Directory for package-specific temporary files
package_dir = "~/tmp/twat/{package_name}"

[genai]
# Directory for storing LoRA files
lora_dir = "~/.local/share/twat/genai/loras"
# Directory for model weights
model_dir = "~/.local/share/twat/genai/models"
# Directory for generated images
output_dir = "~/Pictures/twat_genai"

[logs]
# Base directory for log files
base_dir = "~/.local/state/twat/logs"
# Directory for package-specific logs
package_dir = "~/.local/state/twat/logs/{package_name}"
```

## src/twat_os/paths.py

```python
#!/usr/bin/env -S uv run
# /// script
# dependencies = ["pydantic", "platformdirs"]
# ///
"""Path management for twat packages.

This module provides a centralized way to manage paths for various twat packages.
It handles path resolution, validation, and creation of directories as needed.
"""

from __future__ import annotations

import os
from pathlib import Path
from typing import TYPE_CHECKING, cast

import platformdirs
import tomli
from pydantic import BaseModel, Field, field_validator, model_validator

if TYPE_CHECKING:
    from typing_extensions import Self

# Load default paths from TOML
PATHS_TOML = Path(__file__).parent / "paths.toml"
DEFAULT_PATHS = tomli.loads(PATHS_TOML.read_text())


class PathConfig(BaseModel):
    """Base configuration for path settings."""

    base_dir: Path
    package_dir: Path | None = None
    create_if_missing: bool = True

    @field_validator("base_dir", "package_dir")
    @classmethod
    def expand_path(cls, v: str | Path | None) -> Path | None:
        """Expand user and environment variables in paths."""
        if v is None:
            return None
        if isinstance(v, str):
            # Expand both ~ and environment variables
            expanded_user = Path(v).expanduser()
            expanded_vars = os.path.expandvars(str(expanded_user))
            return Path(expanded_vars)
        return v

    @model_validator(mode="after")
    def validate_and_create_dirs(self) -> Self:
        """Create directories if they don't exist and creation is enabled."""
        if self.create_if_missing:
            self.base_dir.mkdir(parents=True, exist_ok=True)
            if self.package_dir:
                self.package_dir.mkdir(parents=True, exist_ok=True)
        return self


class CacheConfig(PathConfig):
    """Configuration for cache directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_cache_dir()) / "twat"
    )


class ConfigDirConfig(PathConfig):
    """Configuration for config directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_config_dir()) / "twat"
    )


class DataDirConfig(PathConfig):
    """Configuration for data directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat"
    )


class TempDirConfig(PathConfig):
    """Configuration for temporary directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_runtime_dir()) / "twat"
    )


class GenAIConfig(PathConfig):
    """Configuration for GenAI-specific paths."""

    lora_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/loras"
    )
    model_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/models"
    )
    output_dir: Path = Field(
        default_factory=lambda: Path.home() / "Pictures/twat_genai"
    )

    @model_validator(mode="after")
    def validate_and_create_all_dirs(self) -> Self:
        """Create all GenAI directories if enabled."""
        if self.create_if_missing:
            self.base_dir.mkdir(parents=True, exist_ok=True)
            self.lora_dir.mkdir(parents=True, exist_ok=True)
            self.model_dir.mkdir(parents=True, exist_ok=True)
            self.output_dir.mkdir(parents=True, exist_ok=True)
        return self


class LogConfig(PathConfig):
    """Configuration for log directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_state_dir()) / "twat/logs"
    )


class PathManager:
    """Central manager for all path configurations."""

    def __init__(
        self,
        package_name: str | None = None,
        config_file: str | Path | None = None,
        *,
        create_dirs: bool = True,
    ) -> None:
        """Initialize path manager.

        Args:
            package_name: Optional package name for package-specific paths
            config_file: Optional path to custom config file
            create_dirs: Whether to create directories if they don't exist
        """
        self.package_name = package_name
        self.create_dirs = create_dirs

        # Load config
        if config_file:
            config_path = Path(config_file)
            if not config_path.exists():
                msg = f"Config file not found: {config_file}"
                raise FileNotFoundError(msg)
            self.config = tomli.loads(config_path.read_text())
        else:
            self.config = DEFAULT_PATHS

        # Initialize path configurations
        self._init_paths()

    def _init_paths(self) -> None:
        """Initialize all path configurations."""

        # Helper to format package-specific paths
        def format_path(path_str: str) -> Path | None:
            if not self.package_name:
                return None
            expanded_user = Path(path_str).expanduser()
            expanded_vars = os.path.expandvars(str(expanded_user))
            return Path(expanded_vars.format(package_name=self.package_name))

        # Initialize configurations
        self.cache = CacheConfig(
            base_dir=self.config["cache"]["base_dir"],
            package_dir=format_path(self.config["cache"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.config_dir = ConfigDirConfig(
            base_dir=self.config["config"]["base_dir"],
            package_dir=format_path(self.config["config"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.data = DataDirConfig(
            base_dir=self.config["data"]["base_dir"],
            package_dir=format_path(self.config["data"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.temp = TempDirConfig(
            base_dir=self.config["temp"]["base_dir"],
            package_dir=format_path(self.config["temp"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.genai = GenAIConfig(
            base_dir=self.config["data"]["base_dir"],
            lora_dir=self.config["genai"]["lora_dir"],
            model_dir=self.config["genai"]["model_dir"],
            output_dir=self.config["genai"]["output_dir"],
            create_if_missing=self.create_dirs,
        )

        self.logs = LogConfig(
            base_dir=self.config["logs"]["base_dir"],
            package_dir=format_path(self.config["logs"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

    def get_path(self, category: str, key: str = "base_dir") -> Path:
        """Get a specific path by category and key.

        Args:
            category: Path category (cache, config, data, temp, genai, logs)
            key: Path key within the category (base_dir, package_dir, etc.)

        Returns:
            Resolved path

        Raises:
            AttributeError: If category or key doesn't exist
        """
        config = getattr(self, category)
        path_value = getattr(config, key)
        if not isinstance(path_value, Path):
            # This case should ideally not happen if Pydantic models are correct
            # and keys always point to Path objects or None (for package_dir sometimes).
            # However, to satisfy type checker for dynamic getattr:
            if path_value is None and key == "package_dir":  # package_dir can be None
                # This function is typed to return Path, so None is not allowed here.
                # This indicates a potential design issue or misuse of get_path for optional paths.
                # For now, raising an error is safer than returning None.
                msg = (
                    f"Path for '{category}.{key}' is None, but Path type was expected."
                )
                raise ValueError(msg)
            msg = f"Unexpected type for '{category}.{key}': {type(path_value)}. Expected Path."
            raise TypeError(msg)
        return cast("Path", path_value)

    @classmethod
    def for_package(
        cls, package_name: str, config_file: str | Path | None = None
    ) -> PathManager:
        """Create a PathManager instance for a specific package.

        Args:
            package_name: Package name
            config_file: Optional path to custom config file

        Returns:
            PathManager instance configured for the package
        """
        return cls(package_name=package_name, config_file=config_file)

    def __repr__(self) -> str:
        """Return string representation of PathManager."""
        package_info = (
            f" for package '{self.package_name}'" if self.package_name else ""
        )
        return f"PathManager{package_info}"
```

## pyproject.toml

```text
#==============================================================================
# TWAT_OS PACKAGE CONFIGURATION
# This pyproject.toml defines the package metadata, dependencies, build system,
# and development environment for the twat-os package, which provides operating
# system utilities for the twat framework.
#==============================================================================

#------------------------------------------------------------------------------
# PROJECT METADATA
# Core package information used by PyPI and package managers.
#------------------------------------------------------------------------------
[project]
name = "twat-os" # Package name on PyPI
dynamic = ["version"] # Fields set dynamically at build time
description = "Operating system utilities for twat" # Short description
readme = "README.md" # Path to README file
requires-python = ">=3.10" # Minimum Python version
license = "MIT" # License type

# Keywords for PyPI search
keywords = [
    "os",
    "system",
    "twat",
    "utilities",
    "operating-system",
]

# PyPI classifiers for package categorization
classifiers = [
    "Development Status :: 4 - Beta", # Package maturity level
    "Programming Language :: Python",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
    "Operating System :: OS Independent",
    "License :: OSI Approved :: MIT License",
    "Intended Audience :: Developers",
]

# Core dependencies
dependencies = [
    "fire>=0.6.0",      # CLI framework
    "loguru>=0.7.2",    # Structured logging
    "twat>=1.8.1",       # Core twat package
    "pydantic>=2.0",    # Data validation and settings management
    "platformdirs>=3.0.0" # Platform-specific user directories
]

#------------------------------------------------------------------------------
# OPTIONAL DEPENDENCIES
# Additional dependencies for optional features, development, and testing.
#------------------------------------------------------------------------------
[project.optional-dependencies]

# Development tools
dev = [
    "hatch>=1.14.0",         # Build tool
    "hatchling>=1.27.0",     # Build backend
    "hatch-vcs>=0.4.0",      # Version control integration
    "mypy>=1.15.0",          # Type checking
    "pre-commit>=4.1.0",     # Pre-commit hooks
    "pyupgrade>=3.19.1",     # Python syntax upgrader
    "ruff>=0.9.7",           # Linting and formatting
    "absolufy-imports>=0.3.1", # Absolute imports
    "isort>=6.0.1",           # Import sorting
    "typing-extensions>=4.0.0" # For Self type hint and other backports
]

# Testing tools
test = [
    "pytest>=8.3.4",           # Testing framework
    "pytest-cov>=6.0.0",       # Coverage reporting
    "pytest-xdist>=3.6.1",     # Parallel testing
    "pytest-benchmark[histogram]>=5.1.0",  # Benchmarking with histogram
    "pytest-mock>=3.14.0",     # Mocking
    "pytest-asyncio>=0.25.3",  # Async testing
    "pytest-timeout>=2.3.1",   # Test timeouts
    "coverage[toml]>=7.6.12"   # Coverage with TOML support
]

# Documentation tools
docs = [
    "sphinx>=7.2.6",
    "sphinx-rtd-theme>=2.0.0",
    "sphinx-autodoc-typehints>=2.0.0",
    "myst-parser>=3.0.0", # Markdown support in Sphinx
]

#------------------------------------------------------------------------------
# COMMAND-LINE SCRIPTS
# Entry points for command-line executables installed with the package.
#------------------------------------------------------------------------------
[project.scripts]
twat-os = "twat_os.__main__:main"

[project.entry-points."twat.plugins"]
os = "twat_os"

# Author information
[[project.authors]]
name = "Adam Twardoch"
email = "adam+github@twardoch.com"

# Project URLs
[project.urls]
Documentation = "https://github.com/twardoch/twat-os#readme"
Issues = "https://github.com/twardoch/twat-os/issues"
Source = "https://github.com/twardoch/twat-os"

#------------------------------------------------------------------------------
# BUILD SYSTEM CONFIGURATION
# Defines the tools required to build the package.
#------------------------------------------------------------------------------
[build-system]
build-backend = "hatchling.build"
requires = [
    "hatchling>=1.27.0",
    "hatch-vcs>=0.4.0"
]

#------------------------------------------------------------------------------
# COVERAGE CONFIGURATION
# Settings for test coverage measurement and reporting.
#------------------------------------------------------------------------------
[tool.coverage.paths]
twat_os = ["src/twat_os", "*/twat-os/src/twat_os"]
tests = ["tests", "*/twat-os/tests"]

[tool.coverage.report]
exclude_lines = [
    "no cov",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:"
]

[tool.coverage.run]
source_pkgs = ["twat_os", "tests"]
branch = true
parallel = true
omit = ["src/twat_os/__about__.py"]

#------------------------------------------------------------------------------
# HATCH BUILD CONFIGURATION
# Configures the build process and development environments.
#------------------------------------------------------------------------------
[tool.hatch.build.hooks.vcs]
version-file = "src/twat_os/__version__.py"

[tool.hatch.build.targets.wheel]
packages = ["src/twat_os"]
include = [
    "src/twat_os/**/*.py",
    "src/twat_os/py.typed"
]
reproducible = true

[tool.hatch.envs.default]
features = ["dev", "test"]

[tool.hatch.envs.default.scripts]
test = "pytest {args:tests}"
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
type-check = "mypy src/twat_os tests"
lint = ["ruff check src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]
fix = ["ruff check --fix --unsafe-fixes src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]

[[tool.hatch.envs.all.matrix]]
python = ["3.10", "3.11", "3.12"]

[tool.hatch.envs.lint]
detached = true
features = ["dev"]

[tool.hatch.envs.lint.scripts]
typing = "mypy --install-types --non-interactive {args:src/twat_os tests}"
style = ["ruff check {args:.}", "ruff format --respect-gitignore {args:.}"]
fmt = ["ruff format --respect-gitignore {args:.}", "ruff check --fix {args:.}"]
all = ["style", "typing"]

[tool.hatch.envs.test]
features = ["test"]

[tool.hatch.envs.test.scripts]
test = "python -m pytest -n auto -p no:briefcase {args:tests}"
test-cov = "python -m pytest -n auto -p no:briefcase --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
bench = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only"
bench-save = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only --benchmark-json=benchmark/results.json"

# Documentation environment
[tool.hatch.envs.docs]
features = ["docs"]

# Documentation environment commands
[tool.hatch.envs.docs.scripts]
build = "sphinx-build -b html docs/source docs/build"

# GitHub Actions workflow configuration
[tool.hatch.envs.ci]
features = ["test"]

[tool.hatch.envs.ci.scripts]
test = "pytest --cov=src/twat_os --cov-report=xml"

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
version_scheme = "post-release"

#------------------------------------------------------------------------------
# MYPY CONFIGURATION
# Configuration for type checking with mypy.
#------------------------------------------------------------------------------
[tool.mypy]
python_version = "3.10"
check_untyped_defs = true
disallow_incomplete_defs = true
disallow_untyped_decorators = true
disallow_untyped_defs = true
no_implicit_optional = true
warn_no_return = true
warn_redundant_casts = true
warn_return_any = true
warn_unreachable = true
warn_unused_configs = true
warn_unused_ignores = true

#------------------------------------------------------------------------------
# RUFF CONFIGURATION
# Configuration for Ruff linting and formatting.
#------------------------------------------------------------------------------
[tool.ruff]
line-length = 88
target-version = "py310"

[tool.ruff.lint]
extend-select = [
    "A",     # flake8-builtins
    "ARG",   # flake8-unused-arguments
    "ASYNC", # flake8-async
    "B",     # flake8-bugbear
    "C",     # flake8-comprehensions
    "DTZ",   # flake8-datetimez
    "E",     # pycodestyle errors
    "EM",    # flake8-errmsg
    "F",     # pyflakes
    "FBT",   # flake8-boolean-trap
    "I",     # isort
    "ICN",   # flake8-import-conventions
    "ISC",   # flake8-implicit-str-concat
    "LOG",   # flake8-logging
    "N",     # pep8-naming
    "PLC",   # pylint convention
    "PLE",   # pylint error
    "PLR",   # pylint refactor
    "PLW",   # pylint warning
    "PT",    # flake8-pytest-style
    "PTH",   # flake8-use-pathlib
    "PYI",   # flake8-pyi
    "RET",   # flake8-return
    "RSE",   # flake8-raise
    "RUF",   # Ruff-specific
    "S",     # flake8-bandit
    "SIM",   # flake8-simplify
    "T",     # flake8-print
    "TCH",   # flake8-type-checking
    "TID",   # flake8-tidy-imports
    "UP",    # pyupgrade
    "W",     # pycodestyle warnings
    "YTT"    # flake8-2020
]

ignore = [
    "ARG001",  # Unused function argument
    "E501",    # Line too long
    "I001",    # Import block formatting
    "RUF001",  # String formatting
    "PLR2004", # Magic numbers
    "EXE003",  # Shebang formatting
    "ISC001",  # Implicit string concatenation
    "B027",    # Empty method in abstract base class
    "C901",    # Function complexity
    "FBT003",  # Boolean positional args
    "PLR0911", # Too many returns
    "PLR0912", # Too many branches
    "PLR0913", # Too many arguments
    "PLR0915", # Too many statements
    "PLW0603", # Global statement usage
    "S105",    # Possible hardcoded password
    "S106",    # Possible hardcoded password
    "S107",    # Possible hardcoded password
    "SIM102"   # Nested if statements
]

unfixable = ["F401"]  # Don't remove unused imports automatically

[tool.ruff.lint.isort]
known-first-party = ["twat_os"]

[tool.ruff.lint.flake8-tidy-imports]
ban-relative-imports = "all"

[tool.ruff.lint.per-file-ignores]
"tests/*" = ["S101", "PLR2004", "TID252"]

#------------------------------------------------------------------------------
# PYTEST CONFIGURATION
# Configuration for pytest testing framework.
#------------------------------------------------------------------------------
[tool.pytest.ini_options]
addopts = "-v --durations=10 -p no:briefcase"
asyncio_mode = "auto"
console_output_style = "progress"
filterwarnings = [
    "ignore::DeprecationWarning",
    "ignore::UserWarning"
]
log_cli = true
log_cli_level = "INFO"
markers = [
    "benchmark: marks tests as benchmarks (select with '-m benchmark')",
    "unit: mark a test as a unit test",
    "integration: mark a test as an integration test",
    "permutation: tests for permutation functionality",
    "parameter: tests for parameter parsing",
    "prompt: tests for prompt parsing"
]
norecursedirs = [
    ".*",
    "build",
    "dist",
    "venv",
    "__pycache__",
    "*.egg-info",
    "_private"
]
python_classes = ["Test*"]
python_files = ["test_*.py"]
python_functions = ["test_*"]
testpaths = ["tests"]

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",    # Minimum time
    "max",    # Maximum time
    "mean",   # Mean time
    "stddev", # Standard deviation
    "median", # Median time
    "iqr",    # Inter-quartile range
    "ops",    # Operations per second
    "rounds"  # Number of rounds
]
```

## TODO.md

```markdown
# TODO

- [ ] Initial task setup.
```

## VERSION.txt

```text
v2.7.5
```

## LOG.md

```markdown
# Log

This file is intended for manual log entries about development progress or significant events. For automated logs from the `cleanup.py` script, please refer to `CLEANUP.txt`.

---
```

## tests/test_package.py

```python
"""Test suite for twat_os."""

import twat_os


def test_version() -> None:
    """Verify package exposes version."""
    assert twat_os.__version__
```

## .github/workflows/release.yml

```yaml
name: Release

on:
  push:
    tags: ["v*"]

permissions:
  contents: write
  id-token: write

jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/twat-os
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

## .github/workflows/push.yml

```yaml
name: Build & Test

on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"

      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"

  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}

      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"

      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/twat_os --cov=tests tests/

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml

  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5
```

## .cursor/rules/cleanup.mdc

```text
---
description: Run `cleanup.py` script before and after changes
globs:
---
Before you do any changes or if I say "cleanup", run the `cleanup.py update` script in the main folder. Analyze the results, describe recent changes in @LOG.md and edit @TODO.md to update priorities and plan next changes. PERFORM THE CHANGES, then run the `cleanup.py status` script and react to the results.

When you edit @TODO.md, lead in lines with empty GFM checkboxes if things aren't done (`- [ ] `) vs. filled (`- [x] `) if done.
```

## .cursor/rules/0project.mdc

```text
---
description: About the twat-os project
globs:
---
# About twat-os

`twat-os` is a Python package providing operating system related utilities for the `twat` ecosystem. Its primary focus is on robust and configurable path management for applications and plugins.

## Key Features:
- **Path Management**: Centralized system for managing application paths (cache, config, data, logs, etc.) using `platformdirs` for cross-platform compatibility and `pydantic` for validation.
- **Configurable**: Path definitions can be customized via a `paths.toml` file.
- **Integration with `twat`**: Designed to function as a plugin within the `twat` framework.
- **Developer Experience**: Clean API with type hints.

## Development Notes
- Uses `uv` for Python package management.
- Quality tools: `ruff` for linting/formatting, `mypy` for type checking, `pytest` for testing.
- Built with Hatch and includes CI/CD setup using GitHub Actions.
- Strong typing and runtime checks are encouraged.
```

## .cursor/rules/filetree.mdc

```text
---
description: File tree of the project
globs:
---
[4.0K]  .
├── [4.0K]  .benchmarks
├── [4.0K]  .cursor
│   └── [4.0K]  rules
│       ├── [ 982]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.2K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [4.0K]  .github
│   └── [4.0K]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.1K]  CHANGELOG.md
├── [1.1K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 187]  LOG.md
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [  34]  TODO.md
├── [   7]  VERSION.txt
├── [ 12K]  cleanup.py
├── [4.0K]  dist
│   └── [   1]  .gitkeep
├── [274K]  llms.txt
├── [ 11K]  pyproject.toml
├── [4.0K]  src
│   └── [4.0K]  twat_os
│       ├── [  95]  __init__.py
│       ├── [4.0K]  __pycache__
│       ├── [8.6K]  paths.py
│       └── [1.0K]  paths.toml
└── [4.0K]  tests
    ├── [4.0K]  __pycache__
    └── [ 149]  test_package.py

12 directories, 24 files
```

## .cursor/rules/quality.mdc

```text
---
description: Quality
globs:
---
- **Verify Information**: Always verify information before presenting it. Do not make assumptions or speculate without clear evidence.
- **No Apologies**: Never use apologies.
- **No Whitespace Suggestions**: Don't suggest whitespace changes.
- **No Inventions**: Don't invent major changes other than what's explicitly requested.
- **No Unnecessary Confirmations**: Don't ask for confirmation of information already provided in the context.
- **Preserve Existing Code**: Don't remove unrelated code or functionalities. Pay attention to preserving existing structures.
- **No Implementation Checks**: Don't ask the user to verify implementations that are visible in the provided context.
- **No Unnecessary Updates**: Don't suggest updates or changes to files when there are no actual modifications needed.
- **No Current Implementation**: Don't show or discuss the current implementation unless specifically requested.
- **Use Explicit Variable Names**: Prefer descriptive, explicit variable names over short, ambiguous ones to enhance code readability.
- **Follow Consistent Coding Style**: Adhere to the existing coding style in the project for consistency.
- **Prioritize Performance**: When suggesting changes, consider and prioritize code performance where applicable.
- **Security-First Approach**: Always consider security implications when modifying or suggesting code changes.
- **Test Coverage**: Suggest or include appropriate unit tests for new or modified code.
- **Error Handling**: Implement robust error handling and logging where necessary.
- **Modular Design**: Encourage modular design principles to improve code maintainability and reusability.
- **Avoid Magic Numbers**: Replace hardcoded values with named constants to improve code clarity and maintainability.
- **Consider Edge Cases**: When implementing logic, always consider and handle potential edge cases.
- **Use Assertions**: Include assertions wherever possible to validate assumptions and catch potential errors early.
```

## README.md

````markdown
#



## Features

- Plugin for twat
- Modern Python packaging with PEP 621 compliance
- Type hints and runtime type checking
- Comprehensive test suite and documentation
- CI/CD ready configuration

## Installation

```bash
pip install twat-os
```

## Usage

```python
import twat_os
plugin = twat_os.plugin
```

## Development

This project uses [Hatch](https://hatch.pypa.io/) for development workflow management.

### Setup Development Environment

```bash
# Install hatch if you haven't already
pip install hatch

# Create and activate development environment
hatch shell

# Run tests
hatch run test

# Run tests with coverage
hatch run test-cov

# Run linting
hatch run lint

# Format code
hatch run format
```

## License

MIT License
````

## LICENSE

```text
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## CHANGELOG.md

```markdown
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]
### Added
- Created `TODO.md`, `LOG.md`, and `CHANGELOG.md`.

### Changed
- Corrected project description in `.cursor/rules/0project.mdc` to accurately describe `twat-os`.

### Refactored
- Simplified `cleanup.py`:
    - Removed internal `repomix` function.
    - Modified the script to call the system `repomix` command and output to `llms.txt` instead of `REPO_CONTENT.txt`.
- Improved `src/twat_os/paths.py`:
    - Added `from typing_extensions import Self` for compatibility.
    - Changed `create_dirs` parameter in `PathManager.__init__` to be keyword-only, resolving Ruff FBT001/FBT002 warnings.
- Updated `pyproject.toml`:
    - Added `pydantic` and `platformdirs` to core project dependencies.
    - Added `typing-extensions` to `dev` dependencies.
    - Removed the `[project.optional-dependencies.all]` group.
    - Updated `tool.hatch.envs.default.features` to exclude `all`.
```

## .gitignore

```text
*_autogen/
.DS_Store
__version__.py
__pycache__/
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
!?*.[Cc]ache/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!**/[Pp]ackages/build/
!Directory.Build.rsp
.*crunch*.local.xml
.axoCover/*
.builds
.cr/personal
.fake/
.history/
.ionide/
.localhistory/
.mfractor/
.ntvs_analysis.dat
.paket/paket.exe
.sass-cache/
.vs/
.vscode
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim_*.settings
*.bim.layout
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
**/[Pp]ackages/*
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
*~
~$*
$tf/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
coverage*.info
coverage*.json
coverage*.xml
csx/
CTestTestfile.cmake
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
ecf/
FakesAssemblies/
FodyWeavers.xsd
Generated_Code/
Generated\ Files/
healthchecksdb
install_manifest.txt
ipch/
Makefile
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
UpgradeLog*.htm
UpgradeLog*.XML
x64/
x86/
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Distribution / packaging
!dist/.gitkeep

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
.ruff_cache/

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Project specific
__version__.py
_private
```

## .pre-commit-config.yaml

```yaml
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]
```

## REPO_CONTENT.txt

````text
This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix. The content has been processed where empty lines have been removed.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: .specstory/**/*.md, .venv/**, _private/**, CLEANUP.txt, **/*.json, *.lock
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.cursor/
  rules/
    0project.mdc
    cleanup.mdc
    filetree.mdc
    quality.mdc
.github/
  workflows/
    push.yml
    release.yml
src/
  twat_os/
    __init__.py
    paths.py
    paths.toml
tests/
  test_package.py
.gitignore
.pre-commit-config.yaml
cleanup.py
LICENSE
pyproject.toml
README.md
VERSION.txt

================================================================
Files
================================================================

================
File: .cursor/rules/0project.mdc
================
---
description: About this project
globs:
---
# About this project

`twat-fs` is a file system utility library focused on robust and extensible file upload capabilities with multiple provider support. It provides:

- Multi-provider upload system with smart fallback (catbox.moe default, plus Dropbox, S3, etc.)
- Automatic retry for temporary failures, fallback for permanent ones
- URL validation and clean developer experience with type hints
- Simple CLI: `python -m twat_fs upload_file path/to/file.txt`
- Easy installation: `uv pip install twat-fs` (basic) or `uv pip install 'twat-fs[all,dev]'` (all features)

## Development Notes
- Uses `uv` for Python package management
- Quality tools: ruff, mypy, pytest
- Clear provider protocol for adding new storage backends
- Strong typing and runtime checks throughout

================
File: .cursor/rules/cleanup.mdc
================
---
description: Run `cleanup.py` script before and after changes
globs:
---
Before you do any changes or if I say "cleanup", run the `cleanup.py update` script in the main folder. Analyze the results, describe recent changes in @LOG.md and edit @TODO.md to update priorities and plan next changes. PERFORM THE CHANGES, then run the `cleanup.py status` script and react to the results.

When you edit @TODO.md, lead in lines with empty GFM checkboxes if things aren't done (`- [ ] `) vs. filled (`- [x] `) if done.

================
File: .cursor/rules/filetree.mdc
================
---
description: File tree of the project
globs:
---
[ 736]  .
├── [  64]  .benchmarks
├── [  96]  .cursor
│   └── [ 224]  rules
│       ├── [ 821]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.0K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [  96]  .github
│   └── [ 128]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.0K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [   7]  VERSION.txt
├── [ 13K]  cleanup.py
├── [ 192]  dist
│   └── [   1]  .gitkeep
├── [5.6K]  pyproject.toml
├── [  96]  src
│   └── [ 224]  twat_os
│       ├── [  95]  __init__.py
│       ├── [7.4K]  paths.py
│       └── [1.0K]  paths.toml
└── [ 128]  tests
    └── [ 145]  test_package.py

10 directories, 20 files

================
File: .cursor/rules/quality.mdc
================
---
description: Quality
globs:
---
- **Verify Information**: Always verify information before presenting it. Do not make assumptions or speculate without clear evidence.
- **No Apologies**: Never use apologies.
- **No Whitespace Suggestions**: Don't suggest whitespace changes.
- **No Inventions**: Don't invent major changes other than what's explicitly requested.
- **No Unnecessary Confirmations**: Don't ask for confirmation of information already provided in the context.
- **Preserve Existing Code**: Don't remove unrelated code or functionalities. Pay attention to preserving existing structures.
- **No Implementation Checks**: Don't ask the user to verify implementations that are visible in the provided context.
- **No Unnecessary Updates**: Don't suggest updates or changes to files when there are no actual modifications needed.
- **No Current Implementation**: Don't show or discuss the current implementation unless specifically requested.
- **Use Explicit Variable Names**: Prefer descriptive, explicit variable names over short, ambiguous ones to enhance code readability.
- **Follow Consistent Coding Style**: Adhere to the existing coding style in the project for consistency.
- **Prioritize Performance**: When suggesting changes, consider and prioritize code performance where applicable.
- **Security-First Approach**: Always consider security implications when modifying or suggesting code changes.
- **Test Coverage**: Suggest or include appropriate unit tests for new or modified code.
- **Error Handling**: Implement robust error handling and logging where necessary.
- **Modular Design**: Encourage modular design principles to improve code maintainability and reusability.
- **Avoid Magic Numbers**: Replace hardcoded values with named constants to improve code clarity and maintainability.
- **Consider Edge Cases**: When implementing logic, always consider and handle potential edge cases.
- **Use Assertions**: Include assertions wherever possible to validate assumptions and catch potential errors early.

================
File: .github/workflows/push.yml
================
name: Build & Test
on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:
permissions:
  contents: write
  id-token: write
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true
jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"
      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"
  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}
      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"
      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/twat_os --cov=tests tests/
      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml
  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true
      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs
      - name: Build distributions
        run: uv run python -m build --outdir dist
      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5

================
File: .github/workflows/release.yml
================
name: Release
on:
  push:
    tags: ["v*"]
permissions:
  contents: write
  id-token: write
jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/twat-os
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true
      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs
      - name: Build distributions
        run: uv run python -m build --outdir dist
      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)
      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

================
File: src/twat_os/__init__.py
================
__version__ = metadata.version(__name__)

================
File: src/twat_os/paths.py
================
PATHS_TOML = Path(__file__).parent / "paths.toml"
DEFAULT_PATHS = tomli.loads(PATHS_TOML.read_text())
class PathConfig(BaseModel):
    @field_validator("base_dir", "package_dir")
    def expand_path(cls, v: str | Path | None) -> Path | None:
        if isinstance(v, str):
            expanded = os.path.expandvars(os.path.expanduser(v))
            return Path(expanded)
    @model_validator(mode="after")
    def validate_and_create_dirs(self) -> Self:
            self.base_dir.mkdir(parents=True, exist_ok=True)
                self.package_dir.mkdir(parents=True, exist_ok=True)
class CacheConfig(PathConfig):
    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_cache_dir()) / "twat"
class ConfigDirConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_config_dir()) / "twat"
class DataDirConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat"
class TempDirConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_runtime_dir()) / "twat"
class GenAIConfig(PathConfig):
    lora_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/loras"
    model_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/models"
    output_dir: Path = Field(
        default_factory=lambda: Path.home() / "Pictures/twat_genai"
    def validate_and_create_all_dirs(self) -> Self:
            self.lora_dir.mkdir(parents=True, exist_ok=True)
            self.model_dir.mkdir(parents=True, exist_ok=True)
            self.output_dir.mkdir(parents=True, exist_ok=True)
class LogConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_state_dir()) / "twat/logs"
class PathManager:
    def __init__(
            config_path = Path(config_file)
            if not config_path.exists():
                raise FileNotFoundError(msg)
            self.config = tomli.loads(config_path.read_text())
        self._init_paths()
    def _init_paths(self) -> None:
        def format_path(path_str: str) -> Path | None:
            expanded = os.path.expandvars(os.path.expanduser(path_str))
            return Path(expanded.format(package_name=self.package_name))
        self.cache = CacheConfig(
            package_dir=format_path(self.config["cache"]["package_dir"]),
        self.config_dir = ConfigDirConfig(
            package_dir=format_path(self.config["config"]["package_dir"]),
        self.data = DataDirConfig(
            package_dir=format_path(self.config["data"]["package_dir"]),
        self.temp = TempDirConfig(
            package_dir=format_path(self.config["temp"]["package_dir"]),
        self.genai = GenAIConfig(
        self.logs = LogConfig(
            package_dir=format_path(self.config["logs"]["package_dir"]),
    def get_path(self, category: str, key: str = "base_dir") -> Path:
        config = getattr(self, category)
        return getattr(config, key)
    def for_package(
        return cls(package_name=package_name, config_file=config_file)
    def __repr__(self) -> str:

================
File: src/twat_os/paths.toml
================
[cache]
# Base directory for all cache operations
base_dir = "~/.cache/twat"
# Directory for storing package-specific cache data
package_dir = "~/.cache/twat/{package_name}"

[config]
# Base directory for configuration files
base_dir = "~/.config/twat"
# Directory for package-specific configuration
package_dir = "~/.config/twat/{package_name}"

[data]
# Base directory for user data
base_dir = "~/.local/share/twat"
# Directory for package-specific data
package_dir = "~/.local/share/twat/{package_name}"

[temp]
# Base directory for temporary files
base_dir = "~/tmp/twat"
# Directory for package-specific temporary files
package_dir = "~/tmp/twat/{package_name}"

[genai]
# Directory for storing LoRA files
lora_dir = "~/.local/share/twat/genai/loras"
# Directory for model weights
model_dir = "~/.local/share/twat/genai/models"
# Directory for generated images
output_dir = "~/Pictures/twat_genai"

[logs]
# Base directory for log files
base_dir = "~/.local/state/twat/logs"
# Directory for package-specific logs
package_dir = "~/.local/state/twat/logs/{package_name}"

================
File: tests/test_package.py
================
def test_version():

================
File: .gitignore
================
*_autogen/
.DS_Store
__version__.py
__pycache__/
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
!?*.[Cc]ache/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!**/[Pp]ackages/build/
!Directory.Build.rsp
.*crunch*.local.xml
.axoCover/*
.builds
.cr/personal
.fake/
.history/
.ionide/
.localhistory/
.mfractor/
.ntvs_analysis.dat
.paket/paket.exe
.sass-cache/
.vs/
.vscode
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim_*.settings
*.bim.layout
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
**/[Pp]ackages/*
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
*~
~$*
$tf/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
coverage*.info
coverage*.json
coverage*.xml
csx/
CTestTestfile.cmake
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
ecf/
FakesAssemblies/
FodyWeavers.xsd
Generated_Code/
Generated\ Files/
healthchecksdb
install_manifest.txt
ipch/
Makefile
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
UpgradeLog*.htm
UpgradeLog*.XML
x64/
x86/
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Distribution / packaging
!dist/.gitkeep

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
.ruff_cache/

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Project specific
__version__.py
_private

================
File: .pre-commit-config.yaml
================
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]

================
File: cleanup.py
================
LOG_FILE = Path("CLEANUP.txt")
os.chdir(Path(__file__).parent)
def new() -> None:
    if LOG_FILE.exists():
        LOG_FILE.unlink()
def prefix() -> None:
    readme = Path(".cursor/rules/0project.mdc")
    if readme.exists():
        log_message("\n=== PROJECT STATEMENT ===")
        content = readme.read_text()
        log_message(content)
def suffix() -> None:
    todo = Path("TODO.md")
    if todo.exists():
        log_message("\n=== TODO.md ===")
        content = todo.read_text()
def log_message(message: str) -> None:
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
    with LOG_FILE.open("a") as f:
        f.write(log_line)
def run_command(cmd: list[str], check: bool = True) -> subprocess.CompletedProcess:
        result = subprocess.run(
            log_message(result.stdout)
        log_message(f"Command failed: {' '.join(cmd)}")
        log_message(f"Error: {e.stderr}")
        return subprocess.CompletedProcess(cmd, 1, "", str(e))
def check_command_exists(cmd: str) -> bool:
        return which(cmd) is not None
class Cleanup:
    def __init__(self) -> None:
        self.workspace = Path.cwd()
    def _print_header(self, message: str) -> None:
        log_message(f"\n=== {message} ===")
    def _check_required_files(self) -> bool:
            if not (self.workspace / file).exists():
                log_message(f"Error: {file} is missing")
    def _generate_tree(self) -> None:
        if not check_command_exists("tree"):
            log_message("Warning: 'tree' command not found. Skipping tree generation.")
            rules_dir = Path(".cursor/rules")
            rules_dir.mkdir(parents=True, exist_ok=True)
            tree_result = run_command(["tree", "-a", "-I", ".git", "--gitignore", "-n", "-h", "-I", "*_cache"])
            with open(rules_dir / "filetree.mdc", "w") as f:
                f.write("---\ndescription: File tree of the project\nglobs: \n---\n")
                f.write(tree_text)
            log_message("\nProject structure:")
            log_message(tree_text)
            log_message(f"Failed to generate tree: {e}")
    def _git_status(self) -> bool:
        result = run_command(["git", "status", "--porcelain"], check=False)
        return bool(result.stdout.strip())
    def _venv(self) -> None:
        log_message("Setting up virtual environment")
            run_command(["uv", "venv"])
            if venv_path.exists():
                os.environ["VIRTUAL_ENV"] = str(self.workspace / ".venv")
                log_message("Virtual environment created and activated")
                log_message("Virtual environment created but activation failed")
            log_message(f"Failed to create virtual environment: {e}")
    def _install(self) -> None:
        log_message("Installing package with all extras")
            self._venv()
            run_command(["uv", "pip", "install", "-e", ".[test,dev]"])
            log_message("Package installed successfully")
            log_message(f"Failed to install package: {e}")
    def _run_checks(self) -> None:
        log_message("Running code quality checks")
            log_message(">>> Running code fixes...")
            run_command(
            log_message(">>>Running type checks...")
            run_command(["python", "-m", "mypy", "src", "tests"], check=False)
            log_message(">>> Running tests...")
            run_command(["python", "-m", "pytest", "tests"], check=False)
            log_message("All checks completed")
            log_message(f"Failed during checks: {e}")
    def status(self) -> None:
        prefix()  # Add README.md content at start
        self._print_header("Current Status")
        self._check_required_files()
        self._generate_tree()
        result = run_command(["git", "status"], check=False)
        self._print_header("Environment Status")
        self._install()
        self._run_checks()
        suffix()  # Add TODO.md content at end
    def venv(self) -> None:
        self._print_header("Virtual Environment Setup")
    def install(self) -> None:
        self._print_header("Package Installation")
    def update(self) -> None:
        self.status()
        if self._git_status():
            log_message("Changes detected in repository")
                run_command(["git", "add", "."])
                run_command(["git", "commit", "-m", commit_msg])
                log_message("Changes committed successfully")
                log_message(f"Failed to commit changes: {e}")
            log_message("No changes to commit")
    def push(self) -> None:
        self._print_header("Pushing Changes")
            run_command(["git", "push"])
            log_message("Changes pushed successfully")
            log_message(f"Failed to push changes: {e}")
def repomix(
            cmd.append("--compress")
            cmd.append("--remove-empty-lines")
            cmd.append("-i")
            cmd.append(ignore_patterns)
        cmd.extend(["-o", output_file])
        run_command(cmd)
        log_message(f"Repository content mixed into {output_file}")
        log_message(f"Failed to mix repository: {e}")
def print_usage() -> None:
    log_message("Usage:")
    log_message("  cleanup.py status   # Show current status and run all checks")
    log_message("  cleanup.py venv     # Create virtual environment")
    log_message("  cleanup.py install  # Install package with all extras")
    log_message("  cleanup.py update   # Update and commit changes")
    log_message("  cleanup.py push     # Push changes to remote")
def main() -> NoReturn:
    new()  # Clear log file
    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)
    cleanup = Cleanup()
            cleanup.status()
            cleanup.venv()
            cleanup.install()
            cleanup.update()
            cleanup.push()
        log_message(f"Error: {e}")
    repomix()
    sys.stdout.write(Path("CLEANUP.txt").read_text())
    sys.exit(0)  # Ensure we exit with a status code
    main()

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: pyproject.toml
================
# this_file: pyproject.toml
# this_project: twat_os
[project]
name = "twat-os"
dynamic = ["version"]
description = "Operating system utilities for twat"
readme = "README.md"
requires-python = ">=3.10"
license = "MIT"
keywords = [
    "os",
    "system",
    "twat"
]
classifiers = [
    "Development Status :: 4 - Beta",
    "Programming Language :: Python",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
]

dependencies = [
    "fire>=0.6.0",
    "loguru>=0.7.2",
    "twat>=1.8.1"
]

[project.optional-dependencies]
dev = [
    "hatch>=1.14.0",
    "hatchling>=1.27.0",
    "hatch-vcs>=0.4.0",
    "mypy>=1.15.0",
    "pre-commit>=4.1.0",
    "pyupgrade>=3.19.1",
    "ruff>=0.9.6"
]

test = [
    "pytest>=8.3.4",
    "pytest-cov>=6.0.0",
    "pytest-benchmark>=5.1.0",
    "pytest-mock>=3.14.0",
    "pytest-asyncio>=0.25.3",
    "pytest-timeout>=2.3.1"
]

all = [
    "fire>=0.6.0",
    "loguru>=0.7.2",
    "twat>=1.8.1"
]

[project.scripts]
twat-os = "twat_os.__main__:main"

[project.entry-points."twat.plugins"]
os = "twat_os"

[[project.authors]]
name = "Adam Twardoch"
email = "adam+github@twardoch.com"

[project.urls]
Documentation = "https://github.com/twardoch/twat-os#readme"
Issues = "https://github.com/twardoch/twat-os/issues"
Source = "https://github.com/twardoch/twat-os"

[build-system]
build-backend = "hatchling.build"
requires = [
    "hatchling>=1.27.0",
    "hatch-vcs>=0.4.0"
]

[tool.coverage.paths]
twat_os = ["src/twat_os", "*/twat-os/src/twat_os"]
tests = ["tests", "*/twat-os/tests"]

[tool.coverage.report]
exclude_lines = [
    "no cov",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:"
]

[tool.coverage.run]
source_pkgs = ["twat_os", "tests"]
branch = true
parallel = true
omit = ["src/twat_os/__about__.py"]

[tool.hatch.build.hooks.vcs]
version-file = "src/twat_os/__version__.py"

[tool.hatch.build.targets.wheel]
packages = ["src/twat_os"]
include = [
    "src/twat_os/**/*.py",
    "src/twat_os/py.typed"
]

[tool.hatch.envs.default]
dependencies = [
    "pytest>=8.3.4",
    "pytest-cov>=6.0.0",
    "ruff>=0.9.6",
    "mypy>=1.15.0"
]

[tool.hatch.envs.default.scripts]
test = "pytest {args:tests}"
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
type-check = "mypy src/twat_os tests"
lint = ["ruff check src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]
fix = ["ruff check --fix --unsafe-fixes src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]

[[tool.hatch.envs.all.matrix]]
python = ["3.10", "3.11", "3.12"]

[tool.hatch.envs.lint]
detached = true
dependencies = [
    "pytest>=8.3.4",
    "pytest-cov>=6.0.0",
    "ruff>=0.9.6",
    "mypy>=1.15.0"
]

[tool.hatch.envs.lint.scripts]
typing = "mypy --install-types --non-interactive {args:src/twat_os tests}"
style = ["ruff check {args:.}", "ruff format --respect-gitignore {args:.}"]
fmt = ["ruff format --respect-gitignore {args:.}", "ruff check --fix {args:.}"]
all = ["style", "typing"]

[tool.hatch.envs.test]
dependencies = []

[tool.hatch.envs.test.scripts]
test = "python -m pytest -n auto -p no:briefcase {args:tests}"
test-cov = "python -m pytest -n auto -p no:briefcase --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
bench = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only"
bench-save = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only --benchmark-json=benchmark/results.json"

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
version_scheme = "post-release"

[tool.mypy]
python_version = "3.10"
check_untyped_defs = true
disallow_incomplete_defs = true
disallow_untyped_decorators = true
disallow_untyped_defs = true
no_implicit_optional = true
warn_no_return = true
warn_redundant_casts = true
warn_return_any = true
warn_unreachable = true
warn_unused_configs = true
warn_unused_ignores = true

[tool.ruff]
line-length = 88
target-version = "py310"

[tool.ruff.lint]
extend-select = [
    "A",
    "ARG",
    "B",
    "C",
    "DTZ",
    "E",
    "EM",
    "F",
    "FBT",
    "I",
    "ICN",
    "ISC",
    "N",
    "PLC",
    "PLE",
    "PLR",
    "PLW",
    "Q",
    "RUF",
    "S",
    "T",
    "TID",
    "UP",
    "W",
    "YTT"
]
ignore = [
    "ARG001",
    "E501",
    "I001",
    "RUF001",
    "PLR2004",
    "EXE003",
    "ISC001"
]

[tool.ruff.per-file-ignores]
"tests/*" = ["S101"]

[tool.pytest.ini_options]
addopts = "-v --durations=10 -p no:briefcase"
asyncio_mode = "auto"
console_output_style = "progress"
filterwarnings = [
    "ignore::DeprecationWarning",
    "ignore::UserWarning"
]
log_cli = true
log_cli_level = "INFO"
markers = [
    "benchmark: marks tests as benchmarks (select with '-m benchmark')",
    "unit: mark a test as a unit test",
    "integration: mark a test as an integration test",
    "permutation: tests for permutation functionality",
    "parameter: tests for parameter parsing",
    "prompt: tests for prompt parsing"
]
norecursedirs = [
    ".*",
    "build",
    "dist",
    "venv",
    "__pycache__",
    "*.egg-info",
    "_private"
]
python_classes = ["Test*"]
python_files = ["test_*.py"]
python_functions = ["test_*"]
testpaths = ["tests"]

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",
    "max",
    "mean",
    "stddev",
    "median",
    "iqr",
    "ops",
    "rounds"
]

================
File: README.md
================
#



## Features

- Plugin for twat
- Modern Python packaging with PEP 621 compliance
- Type hints and runtime type checking
- Comprehensive test suite and documentation
- CI/CD ready configuration

## Installation

```bash
pip install twat-os
```

## Usage

```python
import twat_os
plugin = twat_os.plugin
```

## Development

This project uses [Hatch](https://hatch.pypa.io/) for development workflow management.

### Setup Development Environment

```bash
# Install hatch if you haven't already
pip install hatch

# Create and activate development environment
hatch shell

# Run tests
hatch run test

# Run tests with coverage
hatch run test-cov

# Run linting
hatch run lint

# Format code
hatch run format
```

## License

MIT License

================
File: VERSION.txt
================
v2.6.2



================================================================
End of Codebase
================================================================
````

## CLEANUP.txt

```text
2025-06-25 10:55:23 -
=== PROJECT STATEMENT ===
2025-06-25 10:55:23 - ---
description: About the twat-os project
globs:
---
# About twat-os

`twat-os` is a Python package providing operating system related utilities for the `twat` ecosystem. Its primary focus is on robust and configurable path management for applications and plugins.

## Key Features:
- **Path Management**: Centralized system for managing application paths (cache, config, data, logs, etc.) using `platformdirs` for cross-platform compatibility and `pydantic` for validation.
- **Configurable**: Path definitions can be customized via a `paths.toml` file.
- **Integration with `twat`**: Designed to function as a plugin within the `twat` framework.
- **Developer Experience**: Clean API with type hints.

## Development Notes
- Uses `uv` for Python package management.
- Quality tools: `ruff` for linting/formatting, `mypy` for type checking, `pytest` for testing.
- Built with Hatch and includes CI/CD setup using GitHub Actions.
- Strong typing and runtime checks are encouraged.

2025-06-25 10:55:23 -
=== Current Status ===
2025-06-25 10:55:23 - [4.0K]  .
├── [4.0K]  .benchmarks
├── [4.0K]  .cursor
│   └── [4.0K]  rules
│       ├── [ 982]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.2K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [4.0K]  .github
│   └── [4.0K]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.1K]  CHANGELOG.md
├── [1.1K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 187]  LOG.md
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [  34]  TODO.md
├── [   7]  VERSION.txt
├── [ 12K]  cleanup.py
├── [4.0K]  dist
│   └── [   1]  .gitkeep
├── [274K]  llms.txt
├── [ 11K]  pyproject.toml
├── [4.0K]  src
│   └── [4.0K]  twat_os
│       ├── [  95]  __init__.py
│       ├── [4.0K]  __pycache__
│       ├── [8.6K]  paths.py
│       └── [1.0K]  paths.toml
└── [4.0K]  tests
    ├── [4.0K]  __pycache__
    └── [ 149]  test_package.py

12 directories, 24 files

2025-06-25 10:55:23 -
Project structure:
2025-06-25 10:55:23 - [4.0K]  .
├── [4.0K]  .benchmarks
├── [4.0K]  .cursor
│   └── [4.0K]  rules
│       ├── [ 982]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.2K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [4.0K]  .github
│   └── [4.0K]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.1K]  CHANGELOG.md
├── [1.1K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 187]  LOG.md
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [  34]  TODO.md
├── [   7]  VERSION.txt
├── [ 12K]  cleanup.py
├── [4.0K]  dist
│   └── [   1]  .gitkeep
├── [274K]  llms.txt
├── [ 11K]  pyproject.toml
├── [4.0K]  src
│   └── [4.0K]  twat_os
│       ├── [  95]  __init__.py
│       ├── [4.0K]  __pycache__
│       ├── [8.6K]  paths.py
│       └── [1.0K]  paths.toml
└── [4.0K]  tests
    ├── [4.0K]  __pycache__
    └── [ 149]  test_package.py

12 directories, 24 files

2025-06-25 10:55:23 - HEAD detached from 23e0688
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   .cursor/rules/filetree.mdc
	modified:   CLEANUP.txt

no changes added to commit (use "git add" and/or "git commit -a")

2025-06-25 10:55:23 - HEAD detached from 23e0688
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   .cursor/rules/filetree.mdc
	modified:   CLEANUP.txt

no changes added to commit (use "git add" and/or "git commit -a")

2025-06-25 10:55:23 -
=== Environment Status ===
2025-06-25 10:55:23 - Setting up virtual environment
2025-06-25 10:55:23 - Virtual environment created and activated
2025-06-25 10:55:23 - Installing package with all extras
2025-06-25 10:55:23 - Setting up virtual environment
2025-06-25 10:55:23 - Virtual environment created and activated
2025-06-25 10:55:25 - Package installed successfully
2025-06-25 10:55:25 - Running code quality checks
2025-06-25 10:55:25 - >>> Running code fixes...
2025-06-25 10:55:25 - All checks passed!

2025-06-25 10:55:25 - 3 files left unchanged

2025-06-25 10:55:25 - >>>Running type checks...
2025-06-25 10:55:26 - src/twat_os/paths.py:235: error: Redundant cast to "Path"  [redundant-cast]
Found 1 error in 1 file (checked 4 source files)

2025-06-25 10:55:26 - >>> Running tests...
2025-06-25 10:55:28 - ============================= test session starts ==============================
platform linux -- Python 3.12.11, pytest-8.4.1, pluggy-1.6.0 -- /app/.venv/bin/python
cachedir: .pytest_cache
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /app
configfile: pyproject.toml
plugins: asyncio-1.0.0, benchmark-5.1.0, mock-3.14.1, timeout-2.4.0, cov-6.2.1, anyio-4.9.0, xdist-3.7.0
asyncio: mode=Mode.AUTO, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 1 item

tests/test_package.py::test_version PASSED                               [100%]

============================= slowest 10 durations =============================

(3 durations < 0.005s hidden.  Use -vv to show these durations.)
============================== 1 passed in 0.02s ===============================

2025-06-25 10:55:28 - All checks completed
2025-06-25 10:55:28 -
=== TODO.md ===
2025-06-25 10:55:28 - # TODO

- [ ] Initial task setup.
```

## llms.txt

```````text
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-06-25 10:55:13

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
cleanup.py
src
  twat_os
    __init__.py
    paths.toml
    paths.py
pyproject.toml
TODO.md
VERSION.txt
LOG.md
tests
  test_package.py
.github
  workflows
    release.yml
    push.yml
.cursor
  rules
    cleanup.mdc
    0project.mdc
    filetree.mdc
    quality.mdc
README.md
LICENSE
CHANGELOG.md
.gitignore
.pre-commit-config.yaml
REPO_CONTENT.txt
CLEANUP.txt
llms.txt
```

# Repository Files


## cleanup.py

```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = [
#   "ruff>=0.9.6",
#   "pytest>=8.3.4",
#   "mypy>=1.15.0",
# ]
# ///
# this_file: cleanup.py

"""
Cleanup tool for managing repository tasks and maintaining code quality.

This script provides a comprehensive set of commands for repository maintenance:

When to use each command:

- `cleanup.py status`: Use this FIRST when starting work to check the current state
  of the repository. It shows file structure, git status, and runs all code quality
  checks. Run this before making any changes to ensure you're starting from a clean state.

- `cleanup.py venv`: Run this when setting up the project for the first time or if
  your virtual environment is corrupted/missing. Creates a new virtual environment
  using uv.

- `cleanup.py install`: Use after `venv` or when dependencies have changed. Installs
  the package and all development dependencies in editable mode.

- `cleanup.py update`: Run this when you've made changes and want to commit them.
  It will:
  1. Show current status (like `status` command)
  2. Stage and commit any changes with a generic message
  Use this for routine maintenance commits.

- `cleanup.py push`: Run this after `update` when you want to push your committed
  changes to the remote repository.

Workflow Example:
1. Start work: `cleanup.py status`
2. Make changes to code
3. Commit changes: `cleanup.py update`
4. Push to remote: `cleanup.py push`

The script maintains a CLEANUP.txt file that records all operations with timestamps.
It also includes content from README.md at the start and TODO.md at the end of logs
for context.

Required Files:
- LOG.md: Project changelog
- README.md: Project documentation
- TODO.md: Pending tasks and future plans
"""

import subprocess
import os
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import NoReturn
from shutil import which

# Configuration
IGNORE_PATTERNS = [
    ".git",
    ".venv",
    "__pycache__",
    "*.pyc",
    "dist",
    "build",
    "*.egg-info",
]
REQUIRED_FILES = ["LOG.md", ".cursor/rules/0project.mdc", "TODO.md"]
LOG_FILE = Path("CLEANUP.txt")

# Ensure we're working from the script's directory
os.chdir(Path(__file__).parent)


def new() -> None:
    """Remove existing log file."""
    if LOG_FILE.exists():
        LOG_FILE.unlink()


def prefix() -> None:
    """Write README.md content to log file."""
    readme = Path(".cursor/rules/0project.mdc")
    if readme.exists():
        log_message("\n=== PROJECT STATEMENT ===")
        content = readme.read_text()
        log_message(content)


def suffix() -> None:
    """Write TODO.md content to log file."""
    todo = Path("TODO.md")
    if todo.exists():
        log_message("\n=== TODO.md ===")
        content = todo.read_text()
        log_message(content)


def log_message(message: str) -> None:
    """Log a message to file and console with timestamp."""
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
    log_line = f"{timestamp} - {message}\n"
    with LOG_FILE.open("a") as f:
        f.write(log_line)


def run_command(cmd: list[str], check: bool = True) -> subprocess.CompletedProcess:
    """Run a shell command and return the result."""
    try:
        result = subprocess.run(
            cmd,
            check=check,
            capture_output=True,
            text=True,
            shell=False,  # Explicitly set shell=False for security
        )
        if result.stdout:
            log_message(result.stdout)
        return result
    except subprocess.CalledProcessError as e:
        log_message(f"Command failed: {' '.join(cmd)}")
        log_message(f"Error: {e.stderr}")
        if check:
            raise
        return subprocess.CompletedProcess(cmd, 1, "", str(e))


def check_command_exists(cmd: str) -> bool:
    """Check if a command exists in the system."""
    try:
        return which(cmd) is not None
    except Exception:
        return False


class Cleanup:
    """Main cleanup tool class."""

    def __init__(self) -> None:
        self.workspace = Path.cwd()

    def _print_header(self, message: str) -> None:
        """Print a section header."""
        log_message(f"\n=== {message} ===")

    def _check_required_files(self) -> bool:
        """Check if all required files exist."""
        missing = False
        for file in REQUIRED_FILES:
            if not (self.workspace / file).exists():
                log_message(f"Error: {file} is missing")
                missing = True
        return not missing

    def _generate_tree(self) -> None:
        """Generate and display tree structure of the project."""
        if not check_command_exists("tree"):
            log_message("Warning: 'tree' command not found. Skipping tree generation.")
            return

        try:
            # Create/overwrite the file with YAML frontmatter
            rules_dir = Path(".cursor/rules")
            rules_dir.mkdir(parents=True, exist_ok=True)
            # Get tree output
            tree_result = run_command(["tree", "-a", "-I", ".git", "--gitignore", "-n", "-h", "-I", "*_cache"])
            tree_text = tree_result.stdout
            # Write frontmatter and tree output to file
            with open(rules_dir / "filetree.mdc", "w") as f:
                f.write("---\ndescription: File tree of the project\nglobs: \n---\n")
                f.write(tree_text)

            # Log the contents
            log_message("\nProject structure:")
            log_message(tree_text)

        except Exception as e:
            log_message(f"Failed to generate tree: {e}")
        return

    def _git_status(self) -> bool:
        """Check git status and return True if there are changes."""
        result = run_command(["git", "status", "--porcelain"], check=False)
        return bool(result.stdout.strip())

    def _venv(self) -> None:
        """Create and activate virtual environment using uv."""
        log_message("Setting up virtual environment")
        try:
            run_command(["uv", "venv"])
            # Activate the virtual environment
            venv_path = self.workspace / ".venv" / "bin" / "activate"
            if venv_path.exists():
                os.environ["VIRTUAL_ENV"] = str(self.workspace / ".venv")
                os.environ["PATH"] = f"{self.workspace / '.venv' / 'bin'}{os.pathsep}{os.environ['PATH']}"
                log_message("Virtual environment created and activated")
            else:
                log_message("Virtual environment created but activation failed")
        except Exception as e:
            log_message(f"Failed to create virtual environment: {e}")

    def _install(self) -> None:
        """Install package in development mode with all extras."""
        log_message("Installing package with all extras")
        try:
            self._venv()
            run_command(["uv", "pip", "install", "-e", ".[test,dev]"])
            log_message("Package installed successfully")
        except Exception as e:
            log_message(f"Failed to install package: {e}")

    def _run_checks(self) -> None:
        """Run code quality checks using ruff and pytest."""
        log_message("Running code quality checks")

        try:
            # Run ruff checks
            log_message(">>> Running code fixes...")
            run_command(
                [
                    "python",
                    "-m",
                    "ruff",
                    "check",
                    "--fix",
                    "--unsafe-fixes",
                    "src",
                    "tests",
                ],
                check=False,
            )
            run_command(
                [
                    "python",
                    "-m",
                    "ruff",
                    "format",
                    "--respect-gitignore",
                    "src",
                    "tests",
                ],
                check=False,
            )

            # Run type checks
            log_message(">>>Running type checks...")
            run_command(["python", "-m", "mypy", "src", "tests"], check=False)

            # Run tests
            log_message(">>> Running tests...")
            run_command(["python", "-m", "pytest", "tests"], check=False)

            log_message("All checks completed")
        except Exception as e:
            log_message(f"Failed during checks: {e}")

    def status(self) -> None:
        """Show current repository status: tree structure, git status, and run checks."""
        prefix()  # Add README.md content at start
        self._print_header("Current Status")

        # Check required files
        self._check_required_files()

        # Show tree structure
        self._generate_tree()

        # Show git status
        result = run_command(["git", "status"], check=False)
        log_message(result.stdout)

        # Run additional checks
        self._print_header("Environment Status")
        self._venv()
        self._install()
        self._run_checks()

        suffix()  # Add TODO.md content at end

    def venv(self) -> None:
        """Create and activate virtual environment."""
        self._print_header("Virtual Environment Setup")
        self._venv()

    def install(self) -> None:
        """Install package with all extras."""
        self._print_header("Package Installation")
        self._install()

    def update(self) -> None:
        """Show status and commit any changes if needed."""
        # First show current status
        self.status()

        # Then handle git changes if any
        if self._git_status():
            log_message("Changes detected in repository")
            try:
                # Add all changes
                run_command(["git", "add", "."])
                # Commit changes
                commit_msg = "Update repository files"
                run_command(["git", "commit", "-m", commit_msg])
                log_message("Changes committed successfully")
            except Exception as e:
                log_message(f"Failed to commit changes: {e}")
        else:
            log_message("No changes to commit")

    def push(self) -> None:
        """Push changes to remote repository."""
        self._print_header("Pushing Changes")
        try:
            run_command(["git", "push"])
            log_message("Changes pushed successfully")
        except Exception as e:
            log_message(f"Failed to push changes: {e}")


def print_usage() -> None:
    """Print usage information."""
    log_message("Usage:")
    log_message("  cleanup.py status   # Show current status and run all checks")
    log_message("  cleanup.py venv     # Create virtual environment")
    log_message("  cleanup.py install  # Install package with all extras")
    log_message("  cleanup.py update   # Update and commit changes")
    log_message("  cleanup.py push     # Push changes to remote")


def main() -> NoReturn:
    """Main entry point."""
    new()  # Clear log file

    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)

    command = sys.argv[1]
    cleanup = Cleanup()

    try:
        if command == "status":
            cleanup.status()
        elif command == "venv":
            cleanup.venv()
        elif command == "install":
            cleanup.install()
        elif command == "update":
            cleanup.update()
        elif command == "push":
            cleanup.push()
        else:
            print_usage()
    except Exception as e:
        log_message(f"Error: {e}")
    # Call the system-installed repomix to generate llms.txt
    run_command(["repomix", "-o", "llms.txt", "."])
    log_message("Repository content mixed into llms.txt by system repomix call.")
    sys.stdout.write(Path("CLEANUP.txt").read_text())
    sys.exit(0)  # Ensure we exit with a status code


if __name__ == "__main__":
    main()
```

## src/twat_os/__init__.py

```python
"""twat os plugin"""

from importlib import metadata

__version__ = metadata.version(__name__)
```

## src/twat_os/paths.toml

```text
[cache]
# Base directory for all cache operations
base_dir = "~/.cache/twat"
# Directory for storing package-specific cache data
package_dir = "~/.cache/twat/{package_name}"

[config]
# Base directory for configuration files
base_dir = "~/.config/twat"
# Directory for package-specific configuration
package_dir = "~/.config/twat/{package_name}"

[data]
# Base directory for user data
base_dir = "~/.local/share/twat"
# Directory for package-specific data
package_dir = "~/.local/share/twat/{package_name}"

[temp]
# Base directory for temporary files
base_dir = "~/tmp/twat"
# Directory for package-specific temporary files
package_dir = "~/tmp/twat/{package_name}"

[genai]
# Directory for storing LoRA files
lora_dir = "~/.local/share/twat/genai/loras"
# Directory for model weights
model_dir = "~/.local/share/twat/genai/models"
# Directory for generated images
output_dir = "~/Pictures/twat_genai"

[logs]
# Base directory for log files
base_dir = "~/.local/state/twat/logs"
# Directory for package-specific logs
package_dir = "~/.local/state/twat/logs/{package_name}"
```

## src/twat_os/paths.py

```python
#!/usr/bin/env -S uv run
# /// script
# dependencies = ["pydantic", "platformdirs"]
# ///
"""Path management for twat packages.

This module provides a centralized way to manage paths for various twat packages.
It handles path resolution, validation, and creation of directories as needed.
"""

from __future__ import annotations

import os
from pathlib import Path
from typing import TYPE_CHECKING, cast

import platformdirs
import tomli
from pydantic import BaseModel, Field, field_validator, model_validator

if TYPE_CHECKING:
    from typing_extensions import Self

# Load default paths from TOML
PATHS_TOML = Path(__file__).parent / "paths.toml"
DEFAULT_PATHS = tomli.loads(PATHS_TOML.read_text())


class PathConfig(BaseModel):
    """Base configuration for path settings."""

    base_dir: Path
    package_dir: Path | None = None
    create_if_missing: bool = True

    @field_validator("base_dir", "package_dir")
    @classmethod
    def expand_path(cls, v: str | Path | None) -> Path | None:
        """Expand user and environment variables in paths."""
        if v is None:
            return None
        if isinstance(v, str):
            # Expand both ~ and environment variables
            expanded_user = Path(v).expanduser()
            expanded_vars = os.path.expandvars(str(expanded_user))
            return Path(expanded_vars)
        return v

    @model_validator(mode="after")
    def validate_and_create_dirs(self) -> Self:
        """Create directories if they don't exist and creation is enabled."""
        if self.create_if_missing:
            self.base_dir.mkdir(parents=True, exist_ok=True)
            if self.package_dir:
                self.package_dir.mkdir(parents=True, exist_ok=True)
        return self


class CacheConfig(PathConfig):
    """Configuration for cache directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_cache_dir()) / "twat"
    )


class ConfigDirConfig(PathConfig):
    """Configuration for config directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_config_dir()) / "twat"
    )


class DataDirConfig(PathConfig):
    """Configuration for data directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat"
    )


class TempDirConfig(PathConfig):
    """Configuration for temporary directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_runtime_dir()) / "twat"
    )


class GenAIConfig(PathConfig):
    """Configuration for GenAI-specific paths."""

    lora_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/loras"
    )
    model_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/models"
    )
    output_dir: Path = Field(
        default_factory=lambda: Path.home() / "Pictures/twat_genai"
    )

    @model_validator(mode="after")
    def validate_and_create_all_dirs(self) -> Self:
        """Create all GenAI directories if enabled."""
        if self.create_if_missing:
            self.base_dir.mkdir(parents=True, exist_ok=True)
            self.lora_dir.mkdir(parents=True, exist_ok=True)
            self.model_dir.mkdir(parents=True, exist_ok=True)
            self.output_dir.mkdir(parents=True, exist_ok=True)
        return self


class LogConfig(PathConfig):
    """Configuration for log directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_state_dir()) / "twat/logs"
    )


class PathManager:
    """Central manager for all path configurations."""

    def __init__(
        self,
        package_name: str | None = None,
        config_file: str | Path | None = None,
        *,
        create_dirs: bool = True,
    ) -> None:
        """Initialize path manager.

        Args:
            package_name: Optional package name for package-specific paths
            config_file: Optional path to custom config file
            create_dirs: Whether to create directories if they don't exist
        """
        self.package_name = package_name
        self.create_dirs = create_dirs

        # Load config
        if config_file:
            config_path = Path(config_file)
            if not config_path.exists():
                msg = f"Config file not found: {config_file}"
                raise FileNotFoundError(msg)
            self.config = tomli.loads(config_path.read_text())
        else:
            self.config = DEFAULT_PATHS

        # Initialize path configurations
        self._init_paths()

    def _init_paths(self) -> None:
        """Initialize all path configurations."""

        # Helper to format package-specific paths
        def format_path(path_str: str) -> Path | None:
            if not self.package_name:
                return None
            expanded_user = Path(path_str).expanduser()
            expanded_vars = os.path.expandvars(str(expanded_user))
            return Path(expanded_vars.format(package_name=self.package_name))

        # Initialize configurations
        self.cache = CacheConfig(
            base_dir=self.config["cache"]["base_dir"],
            package_dir=format_path(self.config["cache"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.config_dir = ConfigDirConfig(
            base_dir=self.config["config"]["base_dir"],
            package_dir=format_path(self.config["config"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.data = DataDirConfig(
            base_dir=self.config["data"]["base_dir"],
            package_dir=format_path(self.config["data"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.temp = TempDirConfig(
            base_dir=self.config["temp"]["base_dir"],
            package_dir=format_path(self.config["temp"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.genai = GenAIConfig(
            base_dir=self.config["data"]["base_dir"],
            lora_dir=self.config["genai"]["lora_dir"],
            model_dir=self.config["genai"]["model_dir"],
            output_dir=self.config["genai"]["output_dir"],
            create_if_missing=self.create_dirs,
        )

        self.logs = LogConfig(
            base_dir=self.config["logs"]["base_dir"],
            package_dir=format_path(self.config["logs"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

    def get_path(self, category: str, key: str = "base_dir") -> Path:
        """Get a specific path by category and key.

        Args:
            category: Path category (cache, config, data, temp, genai, logs)
            key: Path key within the category (base_dir, package_dir, etc.)

        Returns:
            Resolved path

        Raises:
            AttributeError: If category or key doesn't exist
        """
        config = getattr(self, category)
        path_value = getattr(config, key)
        if not isinstance(path_value, Path):
            # This case should ideally not happen if Pydantic models are correct
            # and keys always point to Path objects or None (for package_dir sometimes).
            # However, to satisfy type checker for dynamic getattr:
            if path_value is None and key == "package_dir":  # package_dir can be None
                # This function is typed to return Path, so None is not allowed here.
                # This indicates a potential design issue or misuse of get_path for optional paths.
                # For now, raising an error is safer than returning None.
                msg = (
                    f"Path for '{category}.{key}' is None, but Path type was expected."
                )
                raise ValueError(msg)
            msg = f"Unexpected type for '{category}.{key}': {type(path_value)}. Expected Path."
            raise TypeError(msg)
        return cast("Path", path_value)

    @classmethod
    def for_package(
        cls, package_name: str, config_file: str | Path | None = None
    ) -> PathManager:
        """Create a PathManager instance for a specific package.

        Args:
            package_name: Package name
            config_file: Optional path to custom config file

        Returns:
            PathManager instance configured for the package
        """
        return cls(package_name=package_name, config_file=config_file)

    def __repr__(self) -> str:
        """Return string representation of PathManager."""
        package_info = (
            f" for package '{self.package_name}'" if self.package_name else ""
        )
        return f"PathManager{package_info}"
```

## pyproject.toml

```text
#==============================================================================
# TWAT_OS PACKAGE CONFIGURATION
# This pyproject.toml defines the package metadata, dependencies, build system,
# and development environment for the twat-os package, which provides operating
# system utilities for the twat framework.
#==============================================================================

#------------------------------------------------------------------------------
# PROJECT METADATA
# Core package information used by PyPI and package managers.
#------------------------------------------------------------------------------
[project]
name = "twat-os" # Package name on PyPI
dynamic = ["version"] # Fields set dynamically at build time
description = "Operating system utilities for twat" # Short description
readme = "README.md" # Path to README file
requires-python = ">=3.10" # Minimum Python version
license = "MIT" # License type

# Keywords for PyPI search
keywords = [
    "os",
    "system",
    "twat",
    "utilities",
    "operating-system",
]

# PyPI classifiers for package categorization
classifiers = [
    "Development Status :: 4 - Beta", # Package maturity level
    "Programming Language :: Python",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
    "Operating System :: OS Independent",
    "License :: OSI Approved :: MIT License",
    "Intended Audience :: Developers",
]

# Core dependencies
dependencies = [
    "fire>=0.6.0",      # CLI framework
    "loguru>=0.7.2",    # Structured logging
    "twat>=1.8.1",       # Core twat package
    "pydantic>=2.0",    # Data validation and settings management
    "platformdirs>=3.0.0" # Platform-specific user directories
]

#------------------------------------------------------------------------------
# OPTIONAL DEPENDENCIES
# Additional dependencies for optional features, development, and testing.
#------------------------------------------------------------------------------
[project.optional-dependencies]

# Development tools
dev = [
    "hatch>=1.14.0",         # Build tool
    "hatchling>=1.27.0",     # Build backend
    "hatch-vcs>=0.4.0",      # Version control integration
    "mypy>=1.15.0",          # Type checking
    "pre-commit>=4.1.0",     # Pre-commit hooks
    "pyupgrade>=3.19.1",     # Python syntax upgrader
    "ruff>=0.9.7",           # Linting and formatting
    "absolufy-imports>=0.3.1", # Absolute imports
    "isort>=6.0.1",           # Import sorting
    "typing-extensions>=4.0.0" # For Self type hint and other backports
]

# Testing tools
test = [
    "pytest>=8.3.4",           # Testing framework
    "pytest-cov>=6.0.0",       # Coverage reporting
    "pytest-xdist>=3.6.1",     # Parallel testing
    "pytest-benchmark[histogram]>=5.1.0",  # Benchmarking with histogram
    "pytest-mock>=3.14.0",     # Mocking
    "pytest-asyncio>=0.25.3",  # Async testing
    "pytest-timeout>=2.3.1",   # Test timeouts
    "coverage[toml]>=7.6.12"   # Coverage with TOML support
]

# Documentation tools
docs = [
    "sphinx>=7.2.6",
    "sphinx-rtd-theme>=2.0.0",
    "sphinx-autodoc-typehints>=2.0.0",
    "myst-parser>=3.0.0", # Markdown support in Sphinx
]

#------------------------------------------------------------------------------
# COMMAND-LINE SCRIPTS
# Entry points for command-line executables installed with the package.
#------------------------------------------------------------------------------
[project.scripts]
twat-os = "twat_os.__main__:main"

[project.entry-points."twat.plugins"]
os = "twat_os"

# Author information
[[project.authors]]
name = "Adam Twardoch"
email = "adam+github@twardoch.com"

# Project URLs
[project.urls]
Documentation = "https://github.com/twardoch/twat-os#readme"
Issues = "https://github.com/twardoch/twat-os/issues"
Source = "https://github.com/twardoch/twat-os"

#------------------------------------------------------------------------------
# BUILD SYSTEM CONFIGURATION
# Defines the tools required to build the package.
#------------------------------------------------------------------------------
[build-system]
build-backend = "hatchling.build"
requires = [
    "hatchling>=1.27.0",
    "hatch-vcs>=0.4.0"
]

#------------------------------------------------------------------------------
# COVERAGE CONFIGURATION
# Settings for test coverage measurement and reporting.
#------------------------------------------------------------------------------
[tool.coverage.paths]
twat_os = ["src/twat_os", "*/twat-os/src/twat_os"]
tests = ["tests", "*/twat-os/tests"]

[tool.coverage.report]
exclude_lines = [
    "no cov",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:"
]

[tool.coverage.run]
source_pkgs = ["twat_os", "tests"]
branch = true
parallel = true
omit = ["src/twat_os/__about__.py"]

#------------------------------------------------------------------------------
# HATCH BUILD CONFIGURATION
# Configures the build process and development environments.
#------------------------------------------------------------------------------
[tool.hatch.build.hooks.vcs]
version-file = "src/twat_os/__version__.py"

[tool.hatch.build.targets.wheel]
packages = ["src/twat_os"]
include = [
    "src/twat_os/**/*.py",
    "src/twat_os/py.typed"
]
reproducible = true

[tool.hatch.envs.default]
features = ["dev", "test"]

[tool.hatch.envs.default.scripts]
test = "pytest {args:tests}"
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
type-check = "mypy src/twat_os tests"
lint = ["ruff check src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]
fix = ["ruff check --fix --unsafe-fixes src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]

[[tool.hatch.envs.all.matrix]]
python = ["3.10", "3.11", "3.12"]

[tool.hatch.envs.lint]
detached = true
features = ["dev"]

[tool.hatch.envs.lint.scripts]
typing = "mypy --install-types --non-interactive {args:src/twat_os tests}"
style = ["ruff check {args:.}", "ruff format --respect-gitignore {args:.}"]
fmt = ["ruff format --respect-gitignore {args:.}", "ruff check --fix {args:.}"]
all = ["style", "typing"]

[tool.hatch.envs.test]
features = ["test"]

[tool.hatch.envs.test.scripts]
test = "python -m pytest -n auto -p no:briefcase {args:tests}"
test-cov = "python -m pytest -n auto -p no:briefcase --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
bench = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only"
bench-save = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only --benchmark-json=benchmark/results.json"

# Documentation environment
[tool.hatch.envs.docs]
features = ["docs"]

# Documentation environment commands
[tool.hatch.envs.docs.scripts]
build = "sphinx-build -b html docs/source docs/build"

# GitHub Actions workflow configuration
[tool.hatch.envs.ci]
features = ["test"]

[tool.hatch.envs.ci.scripts]
test = "pytest --cov=src/twat_os --cov-report=xml"

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
version_scheme = "post-release"

#------------------------------------------------------------------------------
# MYPY CONFIGURATION
# Configuration for type checking with mypy.
#------------------------------------------------------------------------------
[tool.mypy]
python_version = "3.10"
check_untyped_defs = true
disallow_incomplete_defs = true
disallow_untyped_decorators = true
disallow_untyped_defs = true
no_implicit_optional = true
warn_no_return = true
warn_redundant_casts = true
warn_return_any = true
warn_unreachable = true
warn_unused_configs = true
warn_unused_ignores = true

#------------------------------------------------------------------------------
# RUFF CONFIGURATION
# Configuration for Ruff linting and formatting.
#------------------------------------------------------------------------------
[tool.ruff]
line-length = 88
target-version = "py310"

[tool.ruff.lint]
extend-select = [
    "A",     # flake8-builtins
    "ARG",   # flake8-unused-arguments
    "ASYNC", # flake8-async
    "B",     # flake8-bugbear
    "C",     # flake8-comprehensions
    "DTZ",   # flake8-datetimez
    "E",     # pycodestyle errors
    "EM",    # flake8-errmsg
    "F",     # pyflakes
    "FBT",   # flake8-boolean-trap
    "I",     # isort
    "ICN",   # flake8-import-conventions
    "ISC",   # flake8-implicit-str-concat
    "LOG",   # flake8-logging
    "N",     # pep8-naming
    "PLC",   # pylint convention
    "PLE",   # pylint error
    "PLR",   # pylint refactor
    "PLW",   # pylint warning
    "PT",    # flake8-pytest-style
    "PTH",   # flake8-use-pathlib
    "PYI",   # flake8-pyi
    "RET",   # flake8-return
    "RSE",   # flake8-raise
    "RUF",   # Ruff-specific
    "S",     # flake8-bandit
    "SIM",   # flake8-simplify
    "T",     # flake8-print
    "TCH",   # flake8-type-checking
    "TID",   # flake8-tidy-imports
    "UP",    # pyupgrade
    "W",     # pycodestyle warnings
    "YTT"    # flake8-2020
]

ignore = [
    "ARG001",  # Unused function argument
    "E501",    # Line too long
    "I001",    # Import block formatting
    "RUF001",  # String formatting
    "PLR2004", # Magic numbers
    "EXE003",  # Shebang formatting
    "ISC001",  # Implicit string concatenation
    "B027",    # Empty method in abstract base class
    "C901",    # Function complexity
    "FBT003",  # Boolean positional args
    "PLR0911", # Too many returns
    "PLR0912", # Too many branches
    "PLR0913", # Too many arguments
    "PLR0915", # Too many statements
    "PLW0603", # Global statement usage
    "S105",    # Possible hardcoded password
    "S106",    # Possible hardcoded password
    "S107",    # Possible hardcoded password
    "SIM102"   # Nested if statements
]

unfixable = ["F401"]  # Don't remove unused imports automatically

[tool.ruff.lint.isort]
known-first-party = ["twat_os"]

[tool.ruff.lint.flake8-tidy-imports]
ban-relative-imports = "all"

[tool.ruff.lint.per-file-ignores]
"tests/*" = ["S101", "PLR2004", "TID252"]

#------------------------------------------------------------------------------
# PYTEST CONFIGURATION
# Configuration for pytest testing framework.
#------------------------------------------------------------------------------
[tool.pytest.ini_options]
addopts = "-v --durations=10 -p no:briefcase"
asyncio_mode = "auto"
console_output_style = "progress"
filterwarnings = [
    "ignore::DeprecationWarning",
    "ignore::UserWarning"
]
log_cli = true
log_cli_level = "INFO"
markers = [
    "benchmark: marks tests as benchmarks (select with '-m benchmark')",
    "unit: mark a test as a unit test",
    "integration: mark a test as an integration test",
    "permutation: tests for permutation functionality",
    "parameter: tests for parameter parsing",
    "prompt: tests for prompt parsing"
]
norecursedirs = [
    ".*",
    "build",
    "dist",
    "venv",
    "__pycache__",
    "*.egg-info",
    "_private"
]
python_classes = ["Test*"]
python_files = ["test_*.py"]
python_functions = ["test_*"]
testpaths = ["tests"]

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",    # Minimum time
    "max",    # Maximum time
    "mean",   # Mean time
    "stddev", # Standard deviation
    "median", # Median time
    "iqr",    # Inter-quartile range
    "ops",    # Operations per second
    "rounds"  # Number of rounds
]
```

## TODO.md

```markdown
# TODO

- [ ] Initial task setup.
```

## VERSION.txt

```text
v2.7.5
```

## LOG.md

```markdown
# Log

This file is intended for manual log entries about development progress or significant events. For automated logs from the `cleanup.py` script, please refer to `CLEANUP.txt`.

---
```

## tests/test_package.py

```python
"""Test suite for twat_os."""

import twat_os


def test_version() -> None:
    """Verify package exposes version."""
    assert twat_os.__version__
```

## .github/workflows/release.yml

```yaml
name: Release

on:
  push:
    tags: ["v*"]

permissions:
  contents: write
  id-token: write

jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/twat-os
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

## .github/workflows/push.yml

```yaml
name: Build & Test

on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"

      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"

  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}

      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"

      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/twat_os --cov=tests tests/

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml

  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5
```

## .cursor/rules/cleanup.mdc

```text
---
description: Run `cleanup.py` script before and after changes
globs:
---
Before you do any changes or if I say "cleanup", run the `cleanup.py update` script in the main folder. Analyze the results, describe recent changes in @LOG.md and edit @TODO.md to update priorities and plan next changes. PERFORM THE CHANGES, then run the `cleanup.py status` script and react to the results.

When you edit @TODO.md, lead in lines with empty GFM checkboxes if things aren't done (`- [ ] `) vs. filled (`- [x] `) if done.
```

## .cursor/rules/0project.mdc

```text
---
description: About the twat-os project
globs:
---
# About twat-os

`twat-os` is a Python package providing operating system related utilities for the `twat` ecosystem. Its primary focus is on robust and configurable path management for applications and plugins.

## Key Features:
- **Path Management**: Centralized system for managing application paths (cache, config, data, logs, etc.) using `platformdirs` for cross-platform compatibility and `pydantic` for validation.
- **Configurable**: Path definitions can be customized via a `paths.toml` file.
- **Integration with `twat`**: Designed to function as a plugin within the `twat` framework.
- **Developer Experience**: Clean API with type hints.

## Development Notes
- Uses `uv` for Python package management.
- Quality tools: `ruff` for linting/formatting, `mypy` for type checking, `pytest` for testing.
- Built with Hatch and includes CI/CD setup using GitHub Actions.
- Strong typing and runtime checks are encouraged.
```

## .cursor/rules/filetree.mdc

```text
---
description: File tree of the project
globs:
---
[4.0K]  .
├── [4.0K]  .benchmarks
├── [4.0K]  .cursor
│   └── [4.0K]  rules
│       ├── [ 982]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.1K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [4.0K]  .github
│   └── [4.0K]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.1K]  CHANGELOG.md
├── [1.1K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 187]  LOG.md
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [  34]  TODO.md
├── [   7]  VERSION.txt
├── [ 12K]  cleanup.py
├── [4.0K]  dist
│   └── [   1]  .gitkeep
├── [183K]  llms.txt
├── [ 11K]  pyproject.toml
├── [4.0K]  src
│   └── [4.0K]  twat_os
│       ├── [  95]  __init__.py
│       ├── [4.0K]  __pycache__
│       ├── [8.5K]  paths.py
│       └── [1.0K]  paths.toml
└── [4.0K]  tests
    ├── [4.0K]  __pycache__
    └── [ 149]  test_package.py

12 directories, 24 files
```

## .cursor/rules/quality.mdc

```text
---
description: Quality
globs:
---
- **Verify Information**: Always verify information before presenting it. Do not make assumptions or speculate without clear evidence.
- **No Apologies**: Never use apologies.
- **No Whitespace Suggestions**: Don't suggest whitespace changes.
- **No Inventions**: Don't invent major changes other than what's explicitly requested.
- **No Unnecessary Confirmations**: Don't ask for confirmation of information already provided in the context.
- **Preserve Existing Code**: Don't remove unrelated code or functionalities. Pay attention to preserving existing structures.
- **No Implementation Checks**: Don't ask the user to verify implementations that are visible in the provided context.
- **No Unnecessary Updates**: Don't suggest updates or changes to files when there are no actual modifications needed.
- **No Current Implementation**: Don't show or discuss the current implementation unless specifically requested.
- **Use Explicit Variable Names**: Prefer descriptive, explicit variable names over short, ambiguous ones to enhance code readability.
- **Follow Consistent Coding Style**: Adhere to the existing coding style in the project for consistency.
- **Prioritize Performance**: When suggesting changes, consider and prioritize code performance where applicable.
- **Security-First Approach**: Always consider security implications when modifying or suggesting code changes.
- **Test Coverage**: Suggest or include appropriate unit tests for new or modified code.
- **Error Handling**: Implement robust error handling and logging where necessary.
- **Modular Design**: Encourage modular design principles to improve code maintainability and reusability.
- **Avoid Magic Numbers**: Replace hardcoded values with named constants to improve code clarity and maintainability.
- **Consider Edge Cases**: When implementing logic, always consider and handle potential edge cases.
- **Use Assertions**: Include assertions wherever possible to validate assumptions and catch potential errors early.
```

## README.md

````markdown
#



## Features

- Plugin for twat
- Modern Python packaging with PEP 621 compliance
- Type hints and runtime type checking
- Comprehensive test suite and documentation
- CI/CD ready configuration

## Installation

```bash
pip install twat-os
```

## Usage

```python
import twat_os
plugin = twat_os.plugin
```

## Development

This project uses [Hatch](https://hatch.pypa.io/) for development workflow management.

### Setup Development Environment

```bash
# Install hatch if you haven't already
pip install hatch

# Create and activate development environment
hatch shell

# Run tests
hatch run test

# Run tests with coverage
hatch run test-cov

# Run linting
hatch run lint

# Format code
hatch run format
```

## License

MIT License
````

## LICENSE

```text
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## CHANGELOG.md

```markdown
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]
### Added
- Created `TODO.md`, `LOG.md`, and `CHANGELOG.md`.

### Changed
- Corrected project description in `.cursor/rules/0project.mdc` to accurately describe `twat-os`.

### Refactored
- Simplified `cleanup.py`:
    - Removed internal `repomix` function.
    - Modified the script to call the system `repomix` command and output to `llms.txt` instead of `REPO_CONTENT.txt`.
- Improved `src/twat_os/paths.py`:
    - Added `from typing_extensions import Self` for compatibility.
    - Changed `create_dirs` parameter in `PathManager.__init__` to be keyword-only, resolving Ruff FBT001/FBT002 warnings.
- Updated `pyproject.toml`:
    - Added `pydantic` and `platformdirs` to core project dependencies.
    - Added `typing-extensions` to `dev` dependencies.
    - Removed the `[project.optional-dependencies.all]` group.
    - Updated `tool.hatch.envs.default.features` to exclude `all`.
```

## .gitignore

```text
*_autogen/
.DS_Store
__version__.py
__pycache__/
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
!?*.[Cc]ache/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!**/[Pp]ackages/build/
!Directory.Build.rsp
.*crunch*.local.xml
.axoCover/*
.builds
.cr/personal
.fake/
.history/
.ionide/
.localhistory/
.mfractor/
.ntvs_analysis.dat
.paket/paket.exe
.sass-cache/
.vs/
.vscode
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim_*.settings
*.bim.layout
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
**/[Pp]ackages/*
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
*~
~$*
$tf/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
coverage*.info
coverage*.json
coverage*.xml
csx/
CTestTestfile.cmake
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
ecf/
FakesAssemblies/
FodyWeavers.xsd
Generated_Code/
Generated\ Files/
healthchecksdb
install_manifest.txt
ipch/
Makefile
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
UpgradeLog*.htm
UpgradeLog*.XML
x64/
x86/
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Distribution / packaging
!dist/.gitkeep

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
.ruff_cache/

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Project specific
__version__.py
_private
```

## .pre-commit-config.yaml

```yaml
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]
```

## REPO_CONTENT.txt

````text
This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix. The content has been processed where empty lines have been removed.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: .specstory/**/*.md, .venv/**, _private/**, CLEANUP.txt, **/*.json, *.lock
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.cursor/
  rules/
    0project.mdc
    cleanup.mdc
    filetree.mdc
    quality.mdc
.github/
  workflows/
    push.yml
    release.yml
src/
  twat_os/
    __init__.py
    paths.py
    paths.toml
tests/
  test_package.py
.gitignore
.pre-commit-config.yaml
cleanup.py
LICENSE
pyproject.toml
README.md
VERSION.txt

================================================================
Files
================================================================

================
File: .cursor/rules/0project.mdc
================
---
description: About this project
globs:
---
# About this project

`twat-fs` is a file system utility library focused on robust and extensible file upload capabilities with multiple provider support. It provides:

- Multi-provider upload system with smart fallback (catbox.moe default, plus Dropbox, S3, etc.)
- Automatic retry for temporary failures, fallback for permanent ones
- URL validation and clean developer experience with type hints
- Simple CLI: `python -m twat_fs upload_file path/to/file.txt`
- Easy installation: `uv pip install twat-fs` (basic) or `uv pip install 'twat-fs[all,dev]'` (all features)

## Development Notes
- Uses `uv` for Python package management
- Quality tools: ruff, mypy, pytest
- Clear provider protocol for adding new storage backends
- Strong typing and runtime checks throughout

================
File: .cursor/rules/cleanup.mdc
================
---
description: Run `cleanup.py` script before and after changes
globs:
---
Before you do any changes or if I say "cleanup", run the `cleanup.py update` script in the main folder. Analyze the results, describe recent changes in @LOG.md and edit @TODO.md to update priorities and plan next changes. PERFORM THE CHANGES, then run the `cleanup.py status` script and react to the results.

When you edit @TODO.md, lead in lines with empty GFM checkboxes if things aren't done (`- [ ] `) vs. filled (`- [x] `) if done.

================
File: .cursor/rules/filetree.mdc
================
---
description: File tree of the project
globs:
---
[ 736]  .
├── [  64]  .benchmarks
├── [  96]  .cursor
│   └── [ 224]  rules
│       ├── [ 821]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.0K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [  96]  .github
│   └── [ 128]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.0K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [   7]  VERSION.txt
├── [ 13K]  cleanup.py
├── [ 192]  dist
│   └── [   1]  .gitkeep
├── [5.6K]  pyproject.toml
├── [  96]  src
│   └── [ 224]  twat_os
│       ├── [  95]  __init__.py
│       ├── [7.4K]  paths.py
│       └── [1.0K]  paths.toml
└── [ 128]  tests
    └── [ 145]  test_package.py

10 directories, 20 files

================
File: .cursor/rules/quality.mdc
================
---
description: Quality
globs:
---
- **Verify Information**: Always verify information before presenting it. Do not make assumptions or speculate without clear evidence.
- **No Apologies**: Never use apologies.
- **No Whitespace Suggestions**: Don't suggest whitespace changes.
- **No Inventions**: Don't invent major changes other than what's explicitly requested.
- **No Unnecessary Confirmations**: Don't ask for confirmation of information already provided in the context.
- **Preserve Existing Code**: Don't remove unrelated code or functionalities. Pay attention to preserving existing structures.
- **No Implementation Checks**: Don't ask the user to verify implementations that are visible in the provided context.
- **No Unnecessary Updates**: Don't suggest updates or changes to files when there are no actual modifications needed.
- **No Current Implementation**: Don't show or discuss the current implementation unless specifically requested.
- **Use Explicit Variable Names**: Prefer descriptive, explicit variable names over short, ambiguous ones to enhance code readability.
- **Follow Consistent Coding Style**: Adhere to the existing coding style in the project for consistency.
- **Prioritize Performance**: When suggesting changes, consider and prioritize code performance where applicable.
- **Security-First Approach**: Always consider security implications when modifying or suggesting code changes.
- **Test Coverage**: Suggest or include appropriate unit tests for new or modified code.
- **Error Handling**: Implement robust error handling and logging where necessary.
- **Modular Design**: Encourage modular design principles to improve code maintainability and reusability.
- **Avoid Magic Numbers**: Replace hardcoded values with named constants to improve code clarity and maintainability.
- **Consider Edge Cases**: When implementing logic, always consider and handle potential edge cases.
- **Use Assertions**: Include assertions wherever possible to validate assumptions and catch potential errors early.

================
File: .github/workflows/push.yml
================
name: Build & Test
on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:
permissions:
  contents: write
  id-token: write
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true
jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"
      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"
  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}
      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"
      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/twat_os --cov=tests tests/
      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml
  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true
      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs
      - name: Build distributions
        run: uv run python -m build --outdir dist
      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5

================
File: .github/workflows/release.yml
================
name: Release
on:
  push:
    tags: ["v*"]
permissions:
  contents: write
  id-token: write
jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/twat-os
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true
      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs
      - name: Build distributions
        run: uv run python -m build --outdir dist
      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)
      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

================
File: src/twat_os/__init__.py
================
__version__ = metadata.version(__name__)

================
File: src/twat_os/paths.py
================
PATHS_TOML = Path(__file__).parent / "paths.toml"
DEFAULT_PATHS = tomli.loads(PATHS_TOML.read_text())
class PathConfig(BaseModel):
    @field_validator("base_dir", "package_dir")
    def expand_path(cls, v: str | Path | None) -> Path | None:
        if isinstance(v, str):
            expanded = os.path.expandvars(os.path.expanduser(v))
            return Path(expanded)
    @model_validator(mode="after")
    def validate_and_create_dirs(self) -> Self:
            self.base_dir.mkdir(parents=True, exist_ok=True)
                self.package_dir.mkdir(parents=True, exist_ok=True)
class CacheConfig(PathConfig):
    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_cache_dir()) / "twat"
class ConfigDirConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_config_dir()) / "twat"
class DataDirConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat"
class TempDirConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_runtime_dir()) / "twat"
class GenAIConfig(PathConfig):
    lora_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/loras"
    model_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/models"
    output_dir: Path = Field(
        default_factory=lambda: Path.home() / "Pictures/twat_genai"
    def validate_and_create_all_dirs(self) -> Self:
            self.lora_dir.mkdir(parents=True, exist_ok=True)
            self.model_dir.mkdir(parents=True, exist_ok=True)
            self.output_dir.mkdir(parents=True, exist_ok=True)
class LogConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_state_dir()) / "twat/logs"
class PathManager:
    def __init__(
            config_path = Path(config_file)
            if not config_path.exists():
                raise FileNotFoundError(msg)
            self.config = tomli.loads(config_path.read_text())
        self._init_paths()
    def _init_paths(self) -> None:
        def format_path(path_str: str) -> Path | None:
            expanded = os.path.expandvars(os.path.expanduser(path_str))
            return Path(expanded.format(package_name=self.package_name))
        self.cache = CacheConfig(
            package_dir=format_path(self.config["cache"]["package_dir"]),
        self.config_dir = ConfigDirConfig(
            package_dir=format_path(self.config["config"]["package_dir"]),
        self.data = DataDirConfig(
            package_dir=format_path(self.config["data"]["package_dir"]),
        self.temp = TempDirConfig(
            package_dir=format_path(self.config["temp"]["package_dir"]),
        self.genai = GenAIConfig(
        self.logs = LogConfig(
            package_dir=format_path(self.config["logs"]["package_dir"]),
    def get_path(self, category: str, key: str = "base_dir") -> Path:
        config = getattr(self, category)
        return getattr(config, key)
    def for_package(
        return cls(package_name=package_name, config_file=config_file)
    def __repr__(self) -> str:

================
File: src/twat_os/paths.toml
================
[cache]
# Base directory for all cache operations
base_dir = "~/.cache/twat"
# Directory for storing package-specific cache data
package_dir = "~/.cache/twat/{package_name}"

[config]
# Base directory for configuration files
base_dir = "~/.config/twat"
# Directory for package-specific configuration
package_dir = "~/.config/twat/{package_name}"

[data]
# Base directory for user data
base_dir = "~/.local/share/twat"
# Directory for package-specific data
package_dir = "~/.local/share/twat/{package_name}"

[temp]
# Base directory for temporary files
base_dir = "~/tmp/twat"
# Directory for package-specific temporary files
package_dir = "~/tmp/twat/{package_name}"

[genai]
# Directory for storing LoRA files
lora_dir = "~/.local/share/twat/genai/loras"
# Directory for model weights
model_dir = "~/.local/share/twat/genai/models"
# Directory for generated images
output_dir = "~/Pictures/twat_genai"

[logs]
# Base directory for log files
base_dir = "~/.local/state/twat/logs"
# Directory for package-specific logs
package_dir = "~/.local/state/twat/logs/{package_name}"

================
File: tests/test_package.py
================
def test_version():

================
File: .gitignore
================
*_autogen/
.DS_Store
__version__.py
__pycache__/
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
!?*.[Cc]ache/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!**/[Pp]ackages/build/
!Directory.Build.rsp
.*crunch*.local.xml
.axoCover/*
.builds
.cr/personal
.fake/
.history/
.ionide/
.localhistory/
.mfractor/
.ntvs_analysis.dat
.paket/paket.exe
.sass-cache/
.vs/
.vscode
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim_*.settings
*.bim.layout
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
**/[Pp]ackages/*
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
*~
~$*
$tf/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
coverage*.info
coverage*.json
coverage*.xml
csx/
CTestTestfile.cmake
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
ecf/
FakesAssemblies/
FodyWeavers.xsd
Generated_Code/
Generated\ Files/
healthchecksdb
install_manifest.txt
ipch/
Makefile
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
UpgradeLog*.htm
UpgradeLog*.XML
x64/
x86/
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Distribution / packaging
!dist/.gitkeep

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
.ruff_cache/

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Project specific
__version__.py
_private

================
File: .pre-commit-config.yaml
================
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]

================
File: cleanup.py
================
LOG_FILE = Path("CLEANUP.txt")
os.chdir(Path(__file__).parent)
def new() -> None:
    if LOG_FILE.exists():
        LOG_FILE.unlink()
def prefix() -> None:
    readme = Path(".cursor/rules/0project.mdc")
    if readme.exists():
        log_message("\n=== PROJECT STATEMENT ===")
        content = readme.read_text()
        log_message(content)
def suffix() -> None:
    todo = Path("TODO.md")
    if todo.exists():
        log_message("\n=== TODO.md ===")
        content = todo.read_text()
def log_message(message: str) -> None:
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
    with LOG_FILE.open("a") as f:
        f.write(log_line)
def run_command(cmd: list[str], check: bool = True) -> subprocess.CompletedProcess:
        result = subprocess.run(
            log_message(result.stdout)
        log_message(f"Command failed: {' '.join(cmd)}")
        log_message(f"Error: {e.stderr}")
        return subprocess.CompletedProcess(cmd, 1, "", str(e))
def check_command_exists(cmd: str) -> bool:
        return which(cmd) is not None
class Cleanup:
    def __init__(self) -> None:
        self.workspace = Path.cwd()
    def _print_header(self, message: str) -> None:
        log_message(f"\n=== {message} ===")
    def _check_required_files(self) -> bool:
            if not (self.workspace / file).exists():
                log_message(f"Error: {file} is missing")
    def _generate_tree(self) -> None:
        if not check_command_exists("tree"):
            log_message("Warning: 'tree' command not found. Skipping tree generation.")
            rules_dir = Path(".cursor/rules")
            rules_dir.mkdir(parents=True, exist_ok=True)
            tree_result = run_command(["tree", "-a", "-I", ".git", "--gitignore", "-n", "-h", "-I", "*_cache"])
            with open(rules_dir / "filetree.mdc", "w") as f:
                f.write("---\ndescription: File tree of the project\nglobs: \n---\n")
                f.write(tree_text)
            log_message("\nProject structure:")
            log_message(tree_text)
            log_message(f"Failed to generate tree: {e}")
    def _git_status(self) -> bool:
        result = run_command(["git", "status", "--porcelain"], check=False)
        return bool(result.stdout.strip())
    def _venv(self) -> None:
        log_message("Setting up virtual environment")
            run_command(["uv", "venv"])
            if venv_path.exists():
                os.environ["VIRTUAL_ENV"] = str(self.workspace / ".venv")
                log_message("Virtual environment created and activated")
                log_message("Virtual environment created but activation failed")
            log_message(f"Failed to create virtual environment: {e}")
    def _install(self) -> None:
        log_message("Installing package with all extras")
            self._venv()
            run_command(["uv", "pip", "install", "-e", ".[test,dev]"])
            log_message("Package installed successfully")
            log_message(f"Failed to install package: {e}")
    def _run_checks(self) -> None:
        log_message("Running code quality checks")
            log_message(">>> Running code fixes...")
            run_command(
            log_message(">>>Running type checks...")
            run_command(["python", "-m", "mypy", "src", "tests"], check=False)
            log_message(">>> Running tests...")
            run_command(["python", "-m", "pytest", "tests"], check=False)
            log_message("All checks completed")
            log_message(f"Failed during checks: {e}")
    def status(self) -> None:
        prefix()  # Add README.md content at start
        self._print_header("Current Status")
        self._check_required_files()
        self._generate_tree()
        result = run_command(["git", "status"], check=False)
        self._print_header("Environment Status")
        self._install()
        self._run_checks()
        suffix()  # Add TODO.md content at end
    def venv(self) -> None:
        self._print_header("Virtual Environment Setup")
    def install(self) -> None:
        self._print_header("Package Installation")
    def update(self) -> None:
        self.status()
        if self._git_status():
            log_message("Changes detected in repository")
                run_command(["git", "add", "."])
                run_command(["git", "commit", "-m", commit_msg])
                log_message("Changes committed successfully")
                log_message(f"Failed to commit changes: {e}")
            log_message("No changes to commit")
    def push(self) -> None:
        self._print_header("Pushing Changes")
            run_command(["git", "push"])
            log_message("Changes pushed successfully")
            log_message(f"Failed to push changes: {e}")
def repomix(
            cmd.append("--compress")
            cmd.append("--remove-empty-lines")
            cmd.append("-i")
            cmd.append(ignore_patterns)
        cmd.extend(["-o", output_file])
        run_command(cmd)
        log_message(f"Repository content mixed into {output_file}")
        log_message(f"Failed to mix repository: {e}")
def print_usage() -> None:
    log_message("Usage:")
    log_message("  cleanup.py status   # Show current status and run all checks")
    log_message("  cleanup.py venv     # Create virtual environment")
    log_message("  cleanup.py install  # Install package with all extras")
    log_message("  cleanup.py update   # Update and commit changes")
    log_message("  cleanup.py push     # Push changes to remote")
def main() -> NoReturn:
    new()  # Clear log file
    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)
    cleanup = Cleanup()
            cleanup.status()
            cleanup.venv()
            cleanup.install()
            cleanup.update()
            cleanup.push()
        log_message(f"Error: {e}")
    repomix()
    sys.stdout.write(Path("CLEANUP.txt").read_text())
    sys.exit(0)  # Ensure we exit with a status code
    main()

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: pyproject.toml
================
# this_file: pyproject.toml
# this_project: twat_os
[project]
name = "twat-os"
dynamic = ["version"]
description = "Operating system utilities for twat"
readme = "README.md"
requires-python = ">=3.10"
license = "MIT"
keywords = [
    "os",
    "system",
    "twat"
]
classifiers = [
    "Development Status :: 4 - Beta",
    "Programming Language :: Python",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
]

dependencies = [
    "fire>=0.6.0",
    "loguru>=0.7.2",
    "twat>=1.8.1"
]

[project.optional-dependencies]
dev = [
    "hatch>=1.14.0",
    "hatchling>=1.27.0",
    "hatch-vcs>=0.4.0",
    "mypy>=1.15.0",
    "pre-commit>=4.1.0",
    "pyupgrade>=3.19.1",
    "ruff>=0.9.6"
]

test = [
    "pytest>=8.3.4",
    "pytest-cov>=6.0.0",
    "pytest-benchmark>=5.1.0",
    "pytest-mock>=3.14.0",
    "pytest-asyncio>=0.25.3",
    "pytest-timeout>=2.3.1"
]

all = [
    "fire>=0.6.0",
    "loguru>=0.7.2",
    "twat>=1.8.1"
]

[project.scripts]
twat-os = "twat_os.__main__:main"

[project.entry-points."twat.plugins"]
os = "twat_os"

[[project.authors]]
name = "Adam Twardoch"
email = "adam+github@twardoch.com"

[project.urls]
Documentation = "https://github.com/twardoch/twat-os#readme"
Issues = "https://github.com/twardoch/twat-os/issues"
Source = "https://github.com/twardoch/twat-os"

[build-system]
build-backend = "hatchling.build"
requires = [
    "hatchling>=1.27.0",
    "hatch-vcs>=0.4.0"
]

[tool.coverage.paths]
twat_os = ["src/twat_os", "*/twat-os/src/twat_os"]
tests = ["tests", "*/twat-os/tests"]

[tool.coverage.report]
exclude_lines = [
    "no cov",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:"
]

[tool.coverage.run]
source_pkgs = ["twat_os", "tests"]
branch = true
parallel = true
omit = ["src/twat_os/__about__.py"]

[tool.hatch.build.hooks.vcs]
version-file = "src/twat_os/__version__.py"

[tool.hatch.build.targets.wheel]
packages = ["src/twat_os"]
include = [
    "src/twat_os/**/*.py",
    "src/twat_os/py.typed"
]

[tool.hatch.envs.default]
dependencies = [
    "pytest>=8.3.4",
    "pytest-cov>=6.0.0",
    "ruff>=0.9.6",
    "mypy>=1.15.0"
]

[tool.hatch.envs.default.scripts]
test = "pytest {args:tests}"
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
type-check = "mypy src/twat_os tests"
lint = ["ruff check src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]
fix = ["ruff check --fix --unsafe-fixes src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]

[[tool.hatch.envs.all.matrix]]
python = ["3.10", "3.11", "3.12"]

[tool.hatch.envs.lint]
detached = true
dependencies = [
    "pytest>=8.3.4",
    "pytest-cov>=6.0.0",
    "ruff>=0.9.6",
    "mypy>=1.15.0"
]

[tool.hatch.envs.lint.scripts]
typing = "mypy --install-types --non-interactive {args:src/twat_os tests}"
style = ["ruff check {args:.}", "ruff format --respect-gitignore {args:.}"]
fmt = ["ruff format --respect-gitignore {args:.}", "ruff check --fix {args:.}"]
all = ["style", "typing"]

[tool.hatch.envs.test]
dependencies = []

[tool.hatch.envs.test.scripts]
test = "python -m pytest -n auto -p no:briefcase {args:tests}"
test-cov = "python -m pytest -n auto -p no:briefcase --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
bench = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only"
bench-save = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only --benchmark-json=benchmark/results.json"

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
version_scheme = "post-release"

[tool.mypy]
python_version = "3.10"
check_untyped_defs = true
disallow_incomplete_defs = true
disallow_untyped_decorators = true
disallow_untyped_defs = true
no_implicit_optional = true
warn_no_return = true
warn_redundant_casts = true
warn_return_any = true
warn_unreachable = true
warn_unused_configs = true
warn_unused_ignores = true

[tool.ruff]
line-length = 88
target-version = "py310"

[tool.ruff.lint]
extend-select = [
    "A",
    "ARG",
    "B",
    "C",
    "DTZ",
    "E",
    "EM",
    "F",
    "FBT",
    "I",
    "ICN",
    "ISC",
    "N",
    "PLC",
    "PLE",
    "PLR",
    "PLW",
    "Q",
    "RUF",
    "S",
    "T",
    "TID",
    "UP",
    "W",
    "YTT"
]
ignore = [
    "ARG001",
    "E501",
    "I001",
    "RUF001",
    "PLR2004",
    "EXE003",
    "ISC001"
]

[tool.ruff.per-file-ignores]
"tests/*" = ["S101"]

[tool.pytest.ini_options]
addopts = "-v --durations=10 -p no:briefcase"
asyncio_mode = "auto"
console_output_style = "progress"
filterwarnings = [
    "ignore::DeprecationWarning",
    "ignore::UserWarning"
]
log_cli = true
log_cli_level = "INFO"
markers = [
    "benchmark: marks tests as benchmarks (select with '-m benchmark')",
    "unit: mark a test as a unit test",
    "integration: mark a test as an integration test",
    "permutation: tests for permutation functionality",
    "parameter: tests for parameter parsing",
    "prompt: tests for prompt parsing"
]
norecursedirs = [
    ".*",
    "build",
    "dist",
    "venv",
    "__pycache__",
    "*.egg-info",
    "_private"
]
python_classes = ["Test*"]
python_files = ["test_*.py"]
python_functions = ["test_*"]
testpaths = ["tests"]

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",
    "max",
    "mean",
    "stddev",
    "median",
    "iqr",
    "ops",
    "rounds"
]

================
File: README.md
================
#



## Features

- Plugin for twat
- Modern Python packaging with PEP 621 compliance
- Type hints and runtime type checking
- Comprehensive test suite and documentation
- CI/CD ready configuration

## Installation

```bash
pip install twat-os
```

## Usage

```python
import twat_os
plugin = twat_os.plugin
```

## Development

This project uses [Hatch](https://hatch.pypa.io/) for development workflow management.

### Setup Development Environment

```bash
# Install hatch if you haven't already
pip install hatch

# Create and activate development environment
hatch shell

# Run tests
hatch run test

# Run tests with coverage
hatch run test-cov

# Run linting
hatch run lint

# Format code
hatch run format
```

## License

MIT License

================
File: VERSION.txt
================
v2.6.2



================================================================
End of Codebase
================================================================
````

## CLEANUP.txt

```text
2025-06-25 10:55:02 -
=== PROJECT STATEMENT ===
2025-06-25 10:55:02 - ---
description: About the twat-os project
globs:
---
# About twat-os

`twat-os` is a Python package providing operating system related utilities for the `twat` ecosystem. Its primary focus is on robust and configurable path management for applications and plugins.

## Key Features:
- **Path Management**: Centralized system for managing application paths (cache, config, data, logs, etc.) using `platformdirs` for cross-platform compatibility and `pydantic` for validation.
- **Configurable**: Path definitions can be customized via a `paths.toml` file.
- **Integration with `twat`**: Designed to function as a plugin within the `twat` framework.
- **Developer Experience**: Clean API with type hints.

## Development Notes
- Uses `uv` for Python package management.
- Quality tools: `ruff` for linting/formatting, `mypy` for type checking, `pytest` for testing.
- Built with Hatch and includes CI/CD setup using GitHub Actions.
- Strong typing and runtime checks are encouraged.

2025-06-25 10:55:02 -
=== Current Status ===
2025-06-25 10:55:02 - [4.0K]  .
├── [4.0K]  .benchmarks
├── [4.0K]  .cursor
│   └── [4.0K]  rules
│       ├── [ 982]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.1K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [4.0K]  .github
│   └── [4.0K]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.1K]  CHANGELOG.md
├── [1.1K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 187]  LOG.md
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [  34]  TODO.md
├── [   7]  VERSION.txt
├── [ 12K]  cleanup.py
├── [4.0K]  dist
│   └── [   1]  .gitkeep
├── [183K]  llms.txt
├── [ 11K]  pyproject.toml
├── [4.0K]  src
│   └── [4.0K]  twat_os
│       ├── [  95]  __init__.py
│       ├── [4.0K]  __pycache__
│       ├── [8.5K]  paths.py
│       └── [1.0K]  paths.toml
└── [4.0K]  tests
    ├── [4.0K]  __pycache__
    └── [ 149]  test_package.py

12 directories, 24 files

2025-06-25 10:55:02 -
Project structure:
2025-06-25 10:55:02 - [4.0K]  .
├── [4.0K]  .benchmarks
├── [4.0K]  .cursor
│   └── [4.0K]  rules
│       ├── [ 982]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.1K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [4.0K]  .github
│   └── [4.0K]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.1K]  CHANGELOG.md
├── [1.1K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 187]  LOG.md
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [  34]  TODO.md
├── [   7]  VERSION.txt
├── [ 12K]  cleanup.py
├── [4.0K]  dist
│   └── [   1]  .gitkeep
├── [183K]  llms.txt
├── [ 11K]  pyproject.toml
├── [4.0K]  src
│   └── [4.0K]  twat_os
│       ├── [  95]  __init__.py
│       ├── [4.0K]  __pycache__
│       ├── [8.5K]  paths.py
│       └── [1.0K]  paths.toml
└── [4.0K]  tests
    ├── [4.0K]  __pycache__
    └── [ 149]  test_package.py

12 directories, 24 files

2025-06-25 10:55:02 - HEAD detached from 23e0688
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   .cursor/rules/filetree.mdc
	modified:   CLEANUP.txt

no changes added to commit (use "git add" and/or "git commit -a")

2025-06-25 10:55:02 - HEAD detached from 23e0688
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   .cursor/rules/filetree.mdc
	modified:   CLEANUP.txt

no changes added to commit (use "git add" and/or "git commit -a")

2025-06-25 10:55:02 -
=== Environment Status ===
2025-06-25 10:55:02 - Setting up virtual environment
2025-06-25 10:55:03 - Virtual environment created and activated
2025-06-25 10:55:03 - Installing package with all extras
2025-06-25 10:55:03 - Setting up virtual environment
2025-06-25 10:55:03 - Virtual environment created and activated
2025-06-25 10:55:05 - Package installed successfully
2025-06-25 10:55:05 - Running code quality checks
2025-06-25 10:55:05 - >>> Running code fixes...
2025-06-25 10:55:05 - Found 1 error (1 fixed, 0 remaining).

2025-06-25 10:55:05 - 1 file reformatted, 2 files left unchanged

2025-06-25 10:55:05 - >>>Running type checks...
2025-06-25 10:55:07 - src/twat_os/paths.py:235: error: Redundant cast to "Path"  [redundant-cast]
Found 1 error in 1 file (checked 4 source files)

2025-06-25 10:55:07 - >>> Running tests...
2025-06-25 10:55:09 - ============================= test session starts ==============================
platform linux -- Python 3.12.11, pytest-8.4.1, pluggy-1.6.0 -- /app/.venv/bin/python
cachedir: .pytest_cache
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /app
configfile: pyproject.toml
plugins: asyncio-1.0.0, benchmark-5.1.0, mock-3.14.1, timeout-2.4.0, cov-6.2.1, anyio-4.9.0, xdist-3.7.0
asyncio: mode=Mode.AUTO, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 1 item

tests/test_package.py::test_version PASSED                               [100%]

============================= slowest 10 durations =============================

(3 durations < 0.005s hidden.  Use -vv to show these durations.)
============================== 1 passed in 0.02s ===============================

2025-06-25 10:55:09 - All checks completed
2025-06-25 10:55:09 -
=== TODO.md ===
2025-06-25 10:55:09 - # TODO

- [ ] Initial task setup.
```

## llms.txt

``````text
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-06-25 10:53:51

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
cleanup.py
src
  twat_os
    __init__.py
    paths.toml
    paths.py
pyproject.toml
TODO.md
VERSION.txt
LOG.md
tests
  test_package.py
.github
  workflows
    release.yml
    push.yml
.cursor
  rules
    cleanup.mdc
    0project.mdc
    filetree.mdc
    quality.mdc
README.md
LICENSE
CHANGELOG.md
.gitignore
.pre-commit-config.yaml
REPO_CONTENT.txt
CLEANUP.txt
llms.txt
```

# Repository Files


## cleanup.py

```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = [
#   "ruff>=0.9.6",
#   "pytest>=8.3.4",
#   "mypy>=1.15.0",
# ]
# ///
# this_file: cleanup.py

"""
Cleanup tool for managing repository tasks and maintaining code quality.

This script provides a comprehensive set of commands for repository maintenance:

When to use each command:

- `cleanup.py status`: Use this FIRST when starting work to check the current state
  of the repository. It shows file structure, git status, and runs all code quality
  checks. Run this before making any changes to ensure you're starting from a clean state.

- `cleanup.py venv`: Run this when setting up the project for the first time or if
  your virtual environment is corrupted/missing. Creates a new virtual environment
  using uv.

- `cleanup.py install`: Use after `venv` or when dependencies have changed. Installs
  the package and all development dependencies in editable mode.

- `cleanup.py update`: Run this when you've made changes and want to commit them.
  It will:
  1. Show current status (like `status` command)
  2. Stage and commit any changes with a generic message
  Use this for routine maintenance commits.

- `cleanup.py push`: Run this after `update` when you want to push your committed
  changes to the remote repository.

Workflow Example:
1. Start work: `cleanup.py status`
2. Make changes to code
3. Commit changes: `cleanup.py update`
4. Push to remote: `cleanup.py push`

The script maintains a CLEANUP.txt file that records all operations with timestamps.
It also includes content from README.md at the start and TODO.md at the end of logs
for context.

Required Files:
- LOG.md: Project changelog
- README.md: Project documentation
- TODO.md: Pending tasks and future plans
"""

import subprocess
import os
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import NoReturn
from shutil import which

# Configuration
IGNORE_PATTERNS = [
    ".git",
    ".venv",
    "__pycache__",
    "*.pyc",
    "dist",
    "build",
    "*.egg-info",
]
REQUIRED_FILES = ["LOG.md", ".cursor/rules/0project.mdc", "TODO.md"]
LOG_FILE = Path("CLEANUP.txt")

# Ensure we're working from the script's directory
os.chdir(Path(__file__).parent)


def new() -> None:
    """Remove existing log file."""
    if LOG_FILE.exists():
        LOG_FILE.unlink()


def prefix() -> None:
    """Write README.md content to log file."""
    readme = Path(".cursor/rules/0project.mdc")
    if readme.exists():
        log_message("\n=== PROJECT STATEMENT ===")
        content = readme.read_text()
        log_message(content)


def suffix() -> None:
    """Write TODO.md content to log file."""
    todo = Path("TODO.md")
    if todo.exists():
        log_message("\n=== TODO.md ===")
        content = todo.read_text()
        log_message(content)


def log_message(message: str) -> None:
    """Log a message to file and console with timestamp."""
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
    log_line = f"{timestamp} - {message}\n"
    with LOG_FILE.open("a") as f:
        f.write(log_line)


def run_command(cmd: list[str], check: bool = True) -> subprocess.CompletedProcess:
    """Run a shell command and return the result."""
    try:
        result = subprocess.run(
            cmd,
            check=check,
            capture_output=True,
            text=True,
            shell=False,  # Explicitly set shell=False for security
        )
        if result.stdout:
            log_message(result.stdout)
        return result
    except subprocess.CalledProcessError as e:
        log_message(f"Command failed: {' '.join(cmd)}")
        log_message(f"Error: {e.stderr}")
        if check:
            raise
        return subprocess.CompletedProcess(cmd, 1, "", str(e))


def check_command_exists(cmd: str) -> bool:
    """Check if a command exists in the system."""
    try:
        return which(cmd) is not None
    except Exception:
        return False


class Cleanup:
    """Main cleanup tool class."""

    def __init__(self) -> None:
        self.workspace = Path.cwd()

    def _print_header(self, message: str) -> None:
        """Print a section header."""
        log_message(f"\n=== {message} ===")

    def _check_required_files(self) -> bool:
        """Check if all required files exist."""
        missing = False
        for file in REQUIRED_FILES:
            if not (self.workspace / file).exists():
                log_message(f"Error: {file} is missing")
                missing = True
        return not missing

    def _generate_tree(self) -> None:
        """Generate and display tree structure of the project."""
        if not check_command_exists("tree"):
            log_message("Warning: 'tree' command not found. Skipping tree generation.")
            return

        try:
            # Create/overwrite the file with YAML frontmatter
            rules_dir = Path(".cursor/rules")
            rules_dir.mkdir(parents=True, exist_ok=True)
            # Get tree output
            tree_result = run_command(["tree", "-a", "-I", ".git", "--gitignore", "-n", "-h", "-I", "*_cache"])
            tree_text = tree_result.stdout
            # Write frontmatter and tree output to file
            with open(rules_dir / "filetree.mdc", "w") as f:
                f.write("---\ndescription: File tree of the project\nglobs: \n---\n")
                f.write(tree_text)

            # Log the contents
            log_message("\nProject structure:")
            log_message(tree_text)

        except Exception as e:
            log_message(f"Failed to generate tree: {e}")
        return

    def _git_status(self) -> bool:
        """Check git status and return True if there are changes."""
        result = run_command(["git", "status", "--porcelain"], check=False)
        return bool(result.stdout.strip())

    def _venv(self) -> None:
        """Create and activate virtual environment using uv."""
        log_message("Setting up virtual environment")
        try:
            run_command(["uv", "venv"])
            # Activate the virtual environment
            venv_path = self.workspace / ".venv" / "bin" / "activate"
            if venv_path.exists():
                os.environ["VIRTUAL_ENV"] = str(self.workspace / ".venv")
                os.environ["PATH"] = f"{self.workspace / '.venv' / 'bin'}{os.pathsep}{os.environ['PATH']}"
                log_message("Virtual environment created and activated")
            else:
                log_message("Virtual environment created but activation failed")
        except Exception as e:
            log_message(f"Failed to create virtual environment: {e}")

    def _install(self) -> None:
        """Install package in development mode with all extras."""
        log_message("Installing package with all extras")
        try:
            self._venv()
            run_command(["uv", "pip", "install", "-e", ".[test,dev]"])
            log_message("Package installed successfully")
        except Exception as e:
            log_message(f"Failed to install package: {e}")

    def _run_checks(self) -> None:
        """Run code quality checks using ruff and pytest."""
        log_message("Running code quality checks")

        try:
            # Run ruff checks
            log_message(">>> Running code fixes...")
            run_command(
                [
                    "python",
                    "-m",
                    "ruff",
                    "check",
                    "--fix",
                    "--unsafe-fixes",
                    "src",
                    "tests",
                ],
                check=False,
            )
            run_command(
                [
                    "python",
                    "-m",
                    "ruff",
                    "format",
                    "--respect-gitignore",
                    "src",
                    "tests",
                ],
                check=False,
            )

            # Run type checks
            log_message(">>>Running type checks...")
            run_command(["python", "-m", "mypy", "src", "tests"], check=False)

            # Run tests
            log_message(">>> Running tests...")
            run_command(["python", "-m", "pytest", "tests"], check=False)

            log_message("All checks completed")
        except Exception as e:
            log_message(f"Failed during checks: {e}")

    def status(self) -> None:
        """Show current repository status: tree structure, git status, and run checks."""
        prefix()  # Add README.md content at start
        self._print_header("Current Status")

        # Check required files
        self._check_required_files()

        # Show tree structure
        self._generate_tree()

        # Show git status
        result = run_command(["git", "status"], check=False)
        log_message(result.stdout)

        # Run additional checks
        self._print_header("Environment Status")
        self._venv()
        self._install()
        self._run_checks()

        suffix()  # Add TODO.md content at end

    def venv(self) -> None:
        """Create and activate virtual environment."""
        self._print_header("Virtual Environment Setup")
        self._venv()

    def install(self) -> None:
        """Install package with all extras."""
        self._print_header("Package Installation")
        self._install()

    def update(self) -> None:
        """Show status and commit any changes if needed."""
        # First show current status
        self.status()

        # Then handle git changes if any
        if self._git_status():
            log_message("Changes detected in repository")
            try:
                # Add all changes
                run_command(["git", "add", "."])
                # Commit changes
                commit_msg = "Update repository files"
                run_command(["git", "commit", "-m", commit_msg])
                log_message("Changes committed successfully")
            except Exception as e:
                log_message(f"Failed to commit changes: {e}")
        else:
            log_message("No changes to commit")

    def push(self) -> None:
        """Push changes to remote repository."""
        self._print_header("Pushing Changes")
        try:
            run_command(["git", "push"])
            log_message("Changes pushed successfully")
        except Exception as e:
            log_message(f"Failed to push changes: {e}")


def print_usage() -> None:
    """Print usage information."""
    log_message("Usage:")
    log_message("  cleanup.py status   # Show current status and run all checks")
    log_message("  cleanup.py venv     # Create virtual environment")
    log_message("  cleanup.py install  # Install package with all extras")
    log_message("  cleanup.py update   # Update and commit changes")
    log_message("  cleanup.py push     # Push changes to remote")


def main() -> NoReturn:
    """Main entry point."""
    new()  # Clear log file

    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)

    command = sys.argv[1]
    cleanup = Cleanup()

    try:
        if command == "status":
            cleanup.status()
        elif command == "venv":
            cleanup.venv()
        elif command == "install":
            cleanup.install()
        elif command == "update":
            cleanup.update()
        elif command == "push":
            cleanup.push()
        else:
            print_usage()
    except Exception as e:
        log_message(f"Error: {e}")
    # Call the system-installed repomix to generate llms.txt
    run_command(["repomix", "-o", "llms.txt", "."])
    log_message("Repository content mixed into llms.txt by system repomix call.")
    sys.stdout.write(Path("CLEANUP.txt").read_text())
    sys.exit(0)  # Ensure we exit with a status code


if __name__ == "__main__":
    main()
```

## src/twat_os/__init__.py

```python
"""twat os plugin"""

from importlib import metadata

__version__ = metadata.version(__name__)
```

## src/twat_os/paths.toml

```text
[cache]
# Base directory for all cache operations
base_dir = "~/.cache/twat"
# Directory for storing package-specific cache data
package_dir = "~/.cache/twat/{package_name}"

[config]
# Base directory for configuration files
base_dir = "~/.config/twat"
# Directory for package-specific configuration
package_dir = "~/.config/twat/{package_name}"

[data]
# Base directory for user data
base_dir = "~/.local/share/twat"
# Directory for package-specific data
package_dir = "~/.local/share/twat/{package_name}"

[temp]
# Base directory for temporary files
base_dir = "~/tmp/twat"
# Directory for package-specific temporary files
package_dir = "~/tmp/twat/{package_name}"

[genai]
# Directory for storing LoRA files
lora_dir = "~/.local/share/twat/genai/loras"
# Directory for model weights
model_dir = "~/.local/share/twat/genai/models"
# Directory for generated images
output_dir = "~/Pictures/twat_genai"

[logs]
# Base directory for log files
base_dir = "~/.local/state/twat/logs"
# Directory for package-specific logs
package_dir = "~/.local/state/twat/logs/{package_name}"
```

## src/twat_os/paths.py

```python
#!/usr/bin/env -S uv run
# /// script
# dependencies = ["pydantic", "platformdirs"]
# ///
"""Path management for twat packages.

This module provides a centralized way to manage paths for various twat packages.
It handles path resolution, validation, and creation of directories as needed.
"""

from __future__ import annotations

import os
from pathlib import Path
from typing import TYPE_CHECKING

import platformdirs
import tomli
from pydantic import BaseModel, Field, field_validator, model_validator

if TYPE_CHECKING:
    from typing_extensions import Self

# Load default paths from TOML
PATHS_TOML = Path(__file__).parent / "paths.toml"
DEFAULT_PATHS = tomli.loads(PATHS_TOML.read_text())


class PathConfig(BaseModel):
    """Base configuration for path settings."""

    base_dir: Path
    package_dir: Path | None = None
    create_if_missing: bool = True

    @field_validator("base_dir", "package_dir")
    @classmethod
    def expand_path(cls, v: str | Path | None) -> Path | None:
        """Expand user and environment variables in paths."""
        if v is None:
            return None
        if isinstance(v, str):
            # Expand both ~ and environment variables
            expanded = os.path.expandvars(os.path.expanduser(v))
            return Path(expanded)
        return v

    @model_validator(mode="after")
    def validate_and_create_dirs(self) -> Self:
        """Create directories if they don't exist and creation is enabled."""
        if self.create_if_missing:
            self.base_dir.mkdir(parents=True, exist_ok=True)
            if self.package_dir:
                self.package_dir.mkdir(parents=True, exist_ok=True)
        return self


class CacheConfig(PathConfig):
    """Configuration for cache directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_cache_dir()) / "twat"
    )


class ConfigDirConfig(PathConfig):
    """Configuration for config directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_config_dir()) / "twat"
    )


class DataDirConfig(PathConfig):
    """Configuration for data directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat"
    )


class TempDirConfig(PathConfig):
    """Configuration for temporary directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_runtime_dir()) / "twat"
    )


class GenAIConfig(PathConfig):
    """Configuration for GenAI-specific paths."""

    lora_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/loras"
    )
    model_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/models"
    )
    output_dir: Path = Field(
        default_factory=lambda: Path.home() / "Pictures/twat_genai"
    )

    @model_validator(mode="after")
    def validate_and_create_all_dirs(self) -> Self:
        """Create all GenAI directories if enabled."""
        if self.create_if_missing:
            self.base_dir.mkdir(parents=True, exist_ok=True)
            self.lora_dir.mkdir(parents=True, exist_ok=True)
            self.model_dir.mkdir(parents=True, exist_ok=True)
            self.output_dir.mkdir(parents=True, exist_ok=True)
        return self


class LogConfig(PathConfig):
    """Configuration for log directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_state_dir()) / "twat/logs"
    )


class PathManager:
    """Central manager for all path configurations."""

    def __init__(
        self,
        package_name: str | None = None,
        config_file: str | Path | None = None,
        *,
        create_dirs: bool = True,
    ) -> None:
        """Initialize path manager.

        Args:
            package_name: Optional package name for package-specific paths
            config_file: Optional path to custom config file
            create_dirs: Whether to create directories if they don't exist
        """
        self.package_name = package_name
        self.create_dirs = create_dirs

        # Load config
        if config_file:
            config_path = Path(config_file)
            if not config_path.exists():
                msg = f"Config file not found: {config_file}"
                raise FileNotFoundError(msg)
            self.config = tomli.loads(config_path.read_text())
        else:
            self.config = DEFAULT_PATHS

        # Initialize path configurations
        self._init_paths()

    def _init_paths(self) -> None:
        """Initialize all path configurations."""

        # Helper to format package-specific paths
        def format_path(path_str: str) -> Path | None:
            if not self.package_name:
                return None
            expanded = os.path.expandvars(os.path.expanduser(path_str))
            return Path(expanded.format(package_name=self.package_name))

        # Initialize configurations
        self.cache = CacheConfig(
            base_dir=self.config["cache"]["base_dir"],
            package_dir=format_path(self.config["cache"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.config_dir = ConfigDirConfig(
            base_dir=self.config["config"]["base_dir"],
            package_dir=format_path(self.config["config"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.data = DataDirConfig(
            base_dir=self.config["data"]["base_dir"],
            package_dir=format_path(self.config["data"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.temp = TempDirConfig(
            base_dir=self.config["temp"]["base_dir"],
            package_dir=format_path(self.config["temp"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.genai = GenAIConfig(
            base_dir=self.config["data"]["base_dir"],
            lora_dir=self.config["genai"]["lora_dir"],
            model_dir=self.config["genai"]["model_dir"],
            output_dir=self.config["genai"]["output_dir"],
            create_if_missing=self.create_dirs,
        )

        self.logs = LogConfig(
            base_dir=self.config["logs"]["base_dir"],
            package_dir=format_path(self.config["logs"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

    def get_path(self, category: str, key: str = "base_dir") -> Path:
        """Get a specific path by category and key.

        Args:
            category: Path category (cache, config, data, temp, genai, logs)
            key: Path key within the category (base_dir, package_dir, etc.)

        Returns:
            Resolved path

        Raises:
            AttributeError: If category or key doesn't exist
        """
        config = getattr(self, category)
        return getattr(config, key)

    @classmethod
    def for_package(
        cls, package_name: str, config_file: str | Path | None = None
    ) -> PathManager:
        """Create a PathManager instance for a specific package.

        Args:
            package_name: Package name
            config_file: Optional path to custom config file

        Returns:
            PathManager instance configured for the package
        """
        return cls(package_name=package_name, config_file=config_file)

    def __repr__(self) -> str:
        """Return string representation of PathManager."""
        package_info = (
            f" for package '{self.package_name}'" if self.package_name else ""
        )
        return f"PathManager{package_info}"
```

## pyproject.toml

```text
#==============================================================================
# TWAT_OS PACKAGE CONFIGURATION
# This pyproject.toml defines the package metadata, dependencies, build system,
# and development environment for the twat-os package, which provides operating
# system utilities for the twat framework.
#==============================================================================

#------------------------------------------------------------------------------
# PROJECT METADATA
# Core package information used by PyPI and package managers.
#------------------------------------------------------------------------------
[project]
name = "twat-os" # Package name on PyPI
dynamic = ["version"] # Fields set dynamically at build time
description = "Operating system utilities for twat" # Short description
readme = "README.md" # Path to README file
requires-python = ">=3.10" # Minimum Python version
license = "MIT" # License type

# Keywords for PyPI search
keywords = [
    "os",
    "system",
    "twat",
    "utilities",
    "operating-system",
]

# PyPI classifiers for package categorization
classifiers = [
    "Development Status :: 4 - Beta", # Package maturity level
    "Programming Language :: Python",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
    "Operating System :: OS Independent",
    "License :: OSI Approved :: MIT License",
    "Intended Audience :: Developers",
]

# Core dependencies
dependencies = [
    "fire>=0.6.0",      # CLI framework
    "loguru>=0.7.2",    # Structured logging
    "twat>=1.8.1",       # Core twat package
    "pydantic>=2.0",    # Data validation and settings management
    "platformdirs>=3.0.0" # Platform-specific user directories
]

#------------------------------------------------------------------------------
# OPTIONAL DEPENDENCIES
# Additional dependencies for optional features, development, and testing.
#------------------------------------------------------------------------------
[project.optional-dependencies]

# Development tools
dev = [
    "hatch>=1.14.0",         # Build tool
    "hatchling>=1.27.0",     # Build backend
    "hatch-vcs>=0.4.0",      # Version control integration
    "mypy>=1.15.0",          # Type checking
    "pre-commit>=4.1.0",     # Pre-commit hooks
    "pyupgrade>=3.19.1",     # Python syntax upgrader
    "ruff>=0.9.7",           # Linting and formatting
    "absolufy-imports>=0.3.1", # Absolute imports
    "isort>=6.0.1",           # Import sorting
    "typing-extensions>=4.0.0" # For Self type hint and other backports
]

# Testing tools
test = [
    "pytest>=8.3.4",           # Testing framework
    "pytest-cov>=6.0.0",       # Coverage reporting
    "pytest-xdist>=3.6.1",     # Parallel testing
    "pytest-benchmark[histogram]>=5.1.0",  # Benchmarking with histogram
    "pytest-mock>=3.14.0",     # Mocking
    "pytest-asyncio>=0.25.3",  # Async testing
    "pytest-timeout>=2.3.1",   # Test timeouts
    "coverage[toml]>=7.6.12"   # Coverage with TOML support
]

# Documentation tools
docs = [
    "sphinx>=7.2.6",
    "sphinx-rtd-theme>=2.0.0",
    "sphinx-autodoc-typehints>=2.0.0",
    "myst-parser>=3.0.0", # Markdown support in Sphinx
]

#------------------------------------------------------------------------------
# COMMAND-LINE SCRIPTS
# Entry points for command-line executables installed with the package.
#------------------------------------------------------------------------------
[project.scripts]
twat-os = "twat_os.__main__:main"

[project.entry-points."twat.plugins"]
os = "twat_os"

# Author information
[[project.authors]]
name = "Adam Twardoch"
email = "adam+github@twardoch.com"

# Project URLs
[project.urls]
Documentation = "https://github.com/twardoch/twat-os#readme"
Issues = "https://github.com/twardoch/twat-os/issues"
Source = "https://github.com/twardoch/twat-os"

#------------------------------------------------------------------------------
# BUILD SYSTEM CONFIGURATION
# Defines the tools required to build the package.
#------------------------------------------------------------------------------
[build-system]
build-backend = "hatchling.build"
requires = [
    "hatchling>=1.27.0",
    "hatch-vcs>=0.4.0"
]

#------------------------------------------------------------------------------
# COVERAGE CONFIGURATION
# Settings for test coverage measurement and reporting.
#------------------------------------------------------------------------------
[tool.coverage.paths]
twat_os = ["src/twat_os", "*/twat-os/src/twat_os"]
tests = ["tests", "*/twat-os/tests"]

[tool.coverage.report]
exclude_lines = [
    "no cov",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:"
]

[tool.coverage.run]
source_pkgs = ["twat_os", "tests"]
branch = true
parallel = true
omit = ["src/twat_os/__about__.py"]

#------------------------------------------------------------------------------
# HATCH BUILD CONFIGURATION
# Configures the build process and development environments.
#------------------------------------------------------------------------------
[tool.hatch.build.hooks.vcs]
version-file = "src/twat_os/__version__.py"

[tool.hatch.build.targets.wheel]
packages = ["src/twat_os"]
include = [
    "src/twat_os/**/*.py",
    "src/twat_os/py.typed"
]
reproducible = true

[tool.hatch.envs.default]
features = ["dev", "test"]

[tool.hatch.envs.default.scripts]
test = "pytest {args:tests}"
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
type-check = "mypy src/twat_os tests"
lint = ["ruff check src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]
fix = ["ruff check --fix --unsafe-fixes src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]

[[tool.hatch.envs.all.matrix]]
python = ["3.10", "3.11", "3.12"]

[tool.hatch.envs.lint]
detached = true
features = ["dev"]

[tool.hatch.envs.lint.scripts]
typing = "mypy --install-types --non-interactive {args:src/twat_os tests}"
style = ["ruff check {args:.}", "ruff format --respect-gitignore {args:.}"]
fmt = ["ruff format --respect-gitignore {args:.}", "ruff check --fix {args:.}"]
all = ["style", "typing"]

[tool.hatch.envs.test]
features = ["test"]

[tool.hatch.envs.test.scripts]
test = "python -m pytest -n auto -p no:briefcase {args:tests}"
test-cov = "python -m pytest -n auto -p no:briefcase --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
bench = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only"
bench-save = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only --benchmark-json=benchmark/results.json"

# Documentation environment
[tool.hatch.envs.docs]
features = ["docs"]

# Documentation environment commands
[tool.hatch.envs.docs.scripts]
build = "sphinx-build -b html docs/source docs/build"

# GitHub Actions workflow configuration
[tool.hatch.envs.ci]
features = ["test"]

[tool.hatch.envs.ci.scripts]
test = "pytest --cov=src/twat_os --cov-report=xml"

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
version_scheme = "post-release"

#------------------------------------------------------------------------------
# MYPY CONFIGURATION
# Configuration for type checking with mypy.
#------------------------------------------------------------------------------
[tool.mypy]
python_version = "3.10"
check_untyped_defs = true
disallow_incomplete_defs = true
disallow_untyped_decorators = true
disallow_untyped_defs = true
no_implicit_optional = true
warn_no_return = true
warn_redundant_casts = true
warn_return_any = true
warn_unreachable = true
warn_unused_configs = true
warn_unused_ignores = true

#------------------------------------------------------------------------------
# RUFF CONFIGURATION
# Configuration for Ruff linting and formatting.
#------------------------------------------------------------------------------
[tool.ruff]
line-length = 88
target-version = "py310"

[tool.ruff.lint]
extend-select = [
    "A",     # flake8-builtins
    "ARG",   # flake8-unused-arguments
    "ASYNC", # flake8-async
    "B",     # flake8-bugbear
    "C",     # flake8-comprehensions
    "DTZ",   # flake8-datetimez
    "E",     # pycodestyle errors
    "EM",    # flake8-errmsg
    "F",     # pyflakes
    "FBT",   # flake8-boolean-trap
    "I",     # isort
    "ICN",   # flake8-import-conventions
    "ISC",   # flake8-implicit-str-concat
    "LOG",   # flake8-logging
    "N",     # pep8-naming
    "PLC",   # pylint convention
    "PLE",   # pylint error
    "PLR",   # pylint refactor
    "PLW",   # pylint warning
    "PT",    # flake8-pytest-style
    "PTH",   # flake8-use-pathlib
    "PYI",   # flake8-pyi
    "RET",   # flake8-return
    "RSE",   # flake8-raise
    "RUF",   # Ruff-specific
    "S",     # flake8-bandit
    "SIM",   # flake8-simplify
    "T",     # flake8-print
    "TCH",   # flake8-type-checking
    "TID",   # flake8-tidy-imports
    "UP",    # pyupgrade
    "W",     # pycodestyle warnings
    "YTT"    # flake8-2020
]

ignore = [
    "ARG001",  # Unused function argument
    "E501",    # Line too long
    "I001",    # Import block formatting
    "RUF001",  # String formatting
    "PLR2004", # Magic numbers
    "EXE003",  # Shebang formatting
    "ISC001",  # Implicit string concatenation
    "B027",    # Empty method in abstract base class
    "C901",    # Function complexity
    "FBT003",  # Boolean positional args
    "PLR0911", # Too many returns
    "PLR0912", # Too many branches
    "PLR0913", # Too many arguments
    "PLR0915", # Too many statements
    "PLW0603", # Global statement usage
    "S105",    # Possible hardcoded password
    "S106",    # Possible hardcoded password
    "S107",    # Possible hardcoded password
    "SIM102"   # Nested if statements
]

unfixable = ["F401"]  # Don't remove unused imports automatically

[tool.ruff.lint.isort]
known-first-party = ["twat_os"]

[tool.ruff.lint.flake8-tidy-imports]
ban-relative-imports = "all"

[tool.ruff.lint.per-file-ignores]
"tests/*" = ["S101", "PLR2004", "TID252"]

#------------------------------------------------------------------------------
# PYTEST CONFIGURATION
# Configuration for pytest testing framework.
#------------------------------------------------------------------------------
[tool.pytest.ini_options]
addopts = "-v --durations=10 -p no:briefcase"
asyncio_mode = "auto"
console_output_style = "progress"
filterwarnings = [
    "ignore::DeprecationWarning",
    "ignore::UserWarning"
]
log_cli = true
log_cli_level = "INFO"
markers = [
    "benchmark: marks tests as benchmarks (select with '-m benchmark')",
    "unit: mark a test as a unit test",
    "integration: mark a test as an integration test",
    "permutation: tests for permutation functionality",
    "parameter: tests for parameter parsing",
    "prompt: tests for prompt parsing"
]
norecursedirs = [
    ".*",
    "build",
    "dist",
    "venv",
    "__pycache__",
    "*.egg-info",
    "_private"
]
python_classes = ["Test*"]
python_files = ["test_*.py"]
python_functions = ["test_*"]
testpaths = ["tests"]

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",    # Minimum time
    "max",    # Maximum time
    "mean",   # Mean time
    "stddev", # Standard deviation
    "median", # Median time
    "iqr",    # Inter-quartile range
    "ops",    # Operations per second
    "rounds"  # Number of rounds
]
```

## TODO.md

```markdown
# TODO

- [ ] Initial task setup.
```

## VERSION.txt

```text
v2.7.5
```

## LOG.md

```markdown
# Log

This file is intended for manual log entries about development progress or significant events. For automated logs from the `cleanup.py` script, please refer to `CLEANUP.txt`.

---
```

## tests/test_package.py

```python
"""Test suite for twat_os."""


def test_version():
    """Verify package exposes version."""
    import twat_os

    assert twat_os.__version__
```

## .github/workflows/release.yml

```yaml
name: Release

on:
  push:
    tags: ["v*"]

permissions:
  contents: write
  id-token: write

jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/twat-os
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

## .github/workflows/push.yml

```yaml
name: Build & Test

on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"

      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"

  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}

      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"

      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/twat_os --cov=tests tests/

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml

  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5
```

## .cursor/rules/cleanup.mdc

```text
---
description: Run `cleanup.py` script before and after changes
globs:
---
Before you do any changes or if I say "cleanup", run the `cleanup.py update` script in the main folder. Analyze the results, describe recent changes in @LOG.md and edit @TODO.md to update priorities and plan next changes. PERFORM THE CHANGES, then run the `cleanup.py status` script and react to the results.

When you edit @TODO.md, lead in lines with empty GFM checkboxes if things aren't done (`- [ ] `) vs. filled (`- [x] `) if done.
```

## .cursor/rules/0project.mdc

```text
---
description: About the twat-os project
globs:
---
# About twat-os

`twat-os` is a Python package providing operating system related utilities for the `twat` ecosystem. Its primary focus is on robust and configurable path management for applications and plugins.

## Key Features:
- **Path Management**: Centralized system for managing application paths (cache, config, data, logs, etc.) using `platformdirs` for cross-platform compatibility and `pydantic` for validation.
- **Configurable**: Path definitions can be customized via a `paths.toml` file.
- **Integration with `twat`**: Designed to function as a plugin within the `twat` framework.
- **Developer Experience**: Clean API with type hints.

## Development Notes
- Uses `uv` for Python package management.
- Quality tools: `ruff` for linting/formatting, `mypy` for type checking, `pytest` for testing.
- Built with Hatch and includes CI/CD setup using GitHub Actions.
- Strong typing and runtime checks are encouraged.
```

## .cursor/rules/filetree.mdc

```text
---
description: File tree of the project
globs:
---
[4.0K]  .
├── [4.0K]  .cursor
│   └── [4.0K]  rules
│       ├── [ 982]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.0K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [4.0K]  .github
│   └── [4.0K]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.1K]  CHANGELOG.md
├── [1.1K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 187]  LOG.md
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [  34]  TODO.md
├── [   7]  VERSION.txt
├── [ 12K]  cleanup.py
├── [4.0K]  dist
│   └── [   1]  .gitkeep
├── [ 92K]  llms.txt
├── [ 11K]  pyproject.toml
├── [4.0K]  src
│   └── [4.0K]  twat_os
│       ├── [  95]  __init__.py
│       ├── [7.5K]  paths.py
│       └── [1.0K]  paths.toml
└── [4.0K]  tests
    └── [ 145]  test_package.py

9 directories, 24 files
```

## .cursor/rules/quality.mdc

```text
---
description: Quality
globs:
---
- **Verify Information**: Always verify information before presenting it. Do not make assumptions or speculate without clear evidence.
- **No Apologies**: Never use apologies.
- **No Whitespace Suggestions**: Don't suggest whitespace changes.
- **No Inventions**: Don't invent major changes other than what's explicitly requested.
- **No Unnecessary Confirmations**: Don't ask for confirmation of information already provided in the context.
- **Preserve Existing Code**: Don't remove unrelated code or functionalities. Pay attention to preserving existing structures.
- **No Implementation Checks**: Don't ask the user to verify implementations that are visible in the provided context.
- **No Unnecessary Updates**: Don't suggest updates or changes to files when there are no actual modifications needed.
- **No Current Implementation**: Don't show or discuss the current implementation unless specifically requested.
- **Use Explicit Variable Names**: Prefer descriptive, explicit variable names over short, ambiguous ones to enhance code readability.
- **Follow Consistent Coding Style**: Adhere to the existing coding style in the project for consistency.
- **Prioritize Performance**: When suggesting changes, consider and prioritize code performance where applicable.
- **Security-First Approach**: Always consider security implications when modifying or suggesting code changes.
- **Test Coverage**: Suggest or include appropriate unit tests for new or modified code.
- **Error Handling**: Implement robust error handling and logging where necessary.
- **Modular Design**: Encourage modular design principles to improve code maintainability and reusability.
- **Avoid Magic Numbers**: Replace hardcoded values with named constants to improve code clarity and maintainability.
- **Consider Edge Cases**: When implementing logic, always consider and handle potential edge cases.
- **Use Assertions**: Include assertions wherever possible to validate assumptions and catch potential errors early.
```

## README.md

````markdown
#



## Features

- Plugin for twat
- Modern Python packaging with PEP 621 compliance
- Type hints and runtime type checking
- Comprehensive test suite and documentation
- CI/CD ready configuration

## Installation

```bash
pip install twat-os
```

## Usage

```python
import twat_os
plugin = twat_os.plugin
```

## Development

This project uses [Hatch](https://hatch.pypa.io/) for development workflow management.

### Setup Development Environment

```bash
# Install hatch if you haven't already
pip install hatch

# Create and activate development environment
hatch shell

# Run tests
hatch run test

# Run tests with coverage
hatch run test-cov

# Run linting
hatch run lint

# Format code
hatch run format
```

## License

MIT License
````

## LICENSE

```text
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## CHANGELOG.md

```markdown
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]
### Added
- Created `TODO.md`, `LOG.md`, and `CHANGELOG.md`.

### Changed
- Corrected project description in `.cursor/rules/0project.mdc` to accurately describe `twat-os`.

### Refactored
- Simplified `cleanup.py`:
    - Removed internal `repomix` function.
    - Modified the script to call the system `repomix` command and output to `llms.txt` instead of `REPO_CONTENT.txt`.
- Improved `src/twat_os/paths.py`:
    - Added `from typing_extensions import Self` for compatibility.
    - Changed `create_dirs` parameter in `PathManager.__init__` to be keyword-only, resolving Ruff FBT001/FBT002 warnings.
- Updated `pyproject.toml`:
    - Added `pydantic` and `platformdirs` to core project dependencies.
    - Added `typing-extensions` to `dev` dependencies.
    - Removed the `[project.optional-dependencies.all]` group.
    - Updated `tool.hatch.envs.default.features` to exclude `all`.
```

## .gitignore

```text
*_autogen/
.DS_Store
__version__.py
__pycache__/
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
!?*.[Cc]ache/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!**/[Pp]ackages/build/
!Directory.Build.rsp
.*crunch*.local.xml
.axoCover/*
.builds
.cr/personal
.fake/
.history/
.ionide/
.localhistory/
.mfractor/
.ntvs_analysis.dat
.paket/paket.exe
.sass-cache/
.vs/
.vscode
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim_*.settings
*.bim.layout
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
**/[Pp]ackages/*
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
*~
~$*
$tf/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
coverage*.info
coverage*.json
coverage*.xml
csx/
CTestTestfile.cmake
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
ecf/
FakesAssemblies/
FodyWeavers.xsd
Generated_Code/
Generated\ Files/
healthchecksdb
install_manifest.txt
ipch/
Makefile
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
UpgradeLog*.htm
UpgradeLog*.XML
x64/
x86/
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Distribution / packaging
!dist/.gitkeep

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
.ruff_cache/

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Project specific
__version__.py
_private
```

## .pre-commit-config.yaml

```yaml
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]
```

## REPO_CONTENT.txt

````text
This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix. The content has been processed where empty lines have been removed.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: .specstory/**/*.md, .venv/**, _private/**, CLEANUP.txt, **/*.json, *.lock
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.cursor/
  rules/
    0project.mdc
    cleanup.mdc
    filetree.mdc
    quality.mdc
.github/
  workflows/
    push.yml
    release.yml
src/
  twat_os/
    __init__.py
    paths.py
    paths.toml
tests/
  test_package.py
.gitignore
.pre-commit-config.yaml
cleanup.py
LICENSE
pyproject.toml
README.md
VERSION.txt

================================================================
Files
================================================================

================
File: .cursor/rules/0project.mdc
================
---
description: About this project
globs:
---
# About this project

`twat-fs` is a file system utility library focused on robust and extensible file upload capabilities with multiple provider support. It provides:

- Multi-provider upload system with smart fallback (catbox.moe default, plus Dropbox, S3, etc.)
- Automatic retry for temporary failures, fallback for permanent ones
- URL validation and clean developer experience with type hints
- Simple CLI: `python -m twat_fs upload_file path/to/file.txt`
- Easy installation: `uv pip install twat-fs` (basic) or `uv pip install 'twat-fs[all,dev]'` (all features)

## Development Notes
- Uses `uv` for Python package management
- Quality tools: ruff, mypy, pytest
- Clear provider protocol for adding new storage backends
- Strong typing and runtime checks throughout

================
File: .cursor/rules/cleanup.mdc
================
---
description: Run `cleanup.py` script before and after changes
globs:
---
Before you do any changes or if I say "cleanup", run the `cleanup.py update` script in the main folder. Analyze the results, describe recent changes in @LOG.md and edit @TODO.md to update priorities and plan next changes. PERFORM THE CHANGES, then run the `cleanup.py status` script and react to the results.

When you edit @TODO.md, lead in lines with empty GFM checkboxes if things aren't done (`- [ ] `) vs. filled (`- [x] `) if done.

================
File: .cursor/rules/filetree.mdc
================
---
description: File tree of the project
globs:
---
[ 736]  .
├── [  64]  .benchmarks
├── [  96]  .cursor
│   └── [ 224]  rules
│       ├── [ 821]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.0K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [  96]  .github
│   └── [ 128]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.0K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [   7]  VERSION.txt
├── [ 13K]  cleanup.py
├── [ 192]  dist
│   └── [   1]  .gitkeep
├── [5.6K]  pyproject.toml
├── [  96]  src
│   └── [ 224]  twat_os
│       ├── [  95]  __init__.py
│       ├── [7.4K]  paths.py
│       └── [1.0K]  paths.toml
└── [ 128]  tests
    └── [ 145]  test_package.py

10 directories, 20 files

================
File: .cursor/rules/quality.mdc
================
---
description: Quality
globs:
---
- **Verify Information**: Always verify information before presenting it. Do not make assumptions or speculate without clear evidence.
- **No Apologies**: Never use apologies.
- **No Whitespace Suggestions**: Don't suggest whitespace changes.
- **No Inventions**: Don't invent major changes other than what's explicitly requested.
- **No Unnecessary Confirmations**: Don't ask for confirmation of information already provided in the context.
- **Preserve Existing Code**: Don't remove unrelated code or functionalities. Pay attention to preserving existing structures.
- **No Implementation Checks**: Don't ask the user to verify implementations that are visible in the provided context.
- **No Unnecessary Updates**: Don't suggest updates or changes to files when there are no actual modifications needed.
- **No Current Implementation**: Don't show or discuss the current implementation unless specifically requested.
- **Use Explicit Variable Names**: Prefer descriptive, explicit variable names over short, ambiguous ones to enhance code readability.
- **Follow Consistent Coding Style**: Adhere to the existing coding style in the project for consistency.
- **Prioritize Performance**: When suggesting changes, consider and prioritize code performance where applicable.
- **Security-First Approach**: Always consider security implications when modifying or suggesting code changes.
- **Test Coverage**: Suggest or include appropriate unit tests for new or modified code.
- **Error Handling**: Implement robust error handling and logging where necessary.
- **Modular Design**: Encourage modular design principles to improve code maintainability and reusability.
- **Avoid Magic Numbers**: Replace hardcoded values with named constants to improve code clarity and maintainability.
- **Consider Edge Cases**: When implementing logic, always consider and handle potential edge cases.
- **Use Assertions**: Include assertions wherever possible to validate assumptions and catch potential errors early.

================
File: .github/workflows/push.yml
================
name: Build & Test
on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:
permissions:
  contents: write
  id-token: write
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true
jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"
      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"
  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}
      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"
      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/twat_os --cov=tests tests/
      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml
  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true
      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs
      - name: Build distributions
        run: uv run python -m build --outdir dist
      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5

================
File: .github/workflows/release.yml
================
name: Release
on:
  push:
    tags: ["v*"]
permissions:
  contents: write
  id-token: write
jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/twat-os
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true
      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs
      - name: Build distributions
        run: uv run python -m build --outdir dist
      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)
      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

================
File: src/twat_os/__init__.py
================
__version__ = metadata.version(__name__)

================
File: src/twat_os/paths.py
================
PATHS_TOML = Path(__file__).parent / "paths.toml"
DEFAULT_PATHS = tomli.loads(PATHS_TOML.read_text())
class PathConfig(BaseModel):
    @field_validator("base_dir", "package_dir")
    def expand_path(cls, v: str | Path | None) -> Path | None:
        if isinstance(v, str):
            expanded = os.path.expandvars(os.path.expanduser(v))
            return Path(expanded)
    @model_validator(mode="after")
    def validate_and_create_dirs(self) -> Self:
            self.base_dir.mkdir(parents=True, exist_ok=True)
                self.package_dir.mkdir(parents=True, exist_ok=True)
class CacheConfig(PathConfig):
    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_cache_dir()) / "twat"
class ConfigDirConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_config_dir()) / "twat"
class DataDirConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat"
class TempDirConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_runtime_dir()) / "twat"
class GenAIConfig(PathConfig):
    lora_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/loras"
    model_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/models"
    output_dir: Path = Field(
        default_factory=lambda: Path.home() / "Pictures/twat_genai"
    def validate_and_create_all_dirs(self) -> Self:
            self.lora_dir.mkdir(parents=True, exist_ok=True)
            self.model_dir.mkdir(parents=True, exist_ok=True)
            self.output_dir.mkdir(parents=True, exist_ok=True)
class LogConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_state_dir()) / "twat/logs"
class PathManager:
    def __init__(
            config_path = Path(config_file)
            if not config_path.exists():
                raise FileNotFoundError(msg)
            self.config = tomli.loads(config_path.read_text())
        self._init_paths()
    def _init_paths(self) -> None:
        def format_path(path_str: str) -> Path | None:
            expanded = os.path.expandvars(os.path.expanduser(path_str))
            return Path(expanded.format(package_name=self.package_name))
        self.cache = CacheConfig(
            package_dir=format_path(self.config["cache"]["package_dir"]),
        self.config_dir = ConfigDirConfig(
            package_dir=format_path(self.config["config"]["package_dir"]),
        self.data = DataDirConfig(
            package_dir=format_path(self.config["data"]["package_dir"]),
        self.temp = TempDirConfig(
            package_dir=format_path(self.config["temp"]["package_dir"]),
        self.genai = GenAIConfig(
        self.logs = LogConfig(
            package_dir=format_path(self.config["logs"]["package_dir"]),
    def get_path(self, category: str, key: str = "base_dir") -> Path:
        config = getattr(self, category)
        return getattr(config, key)
    def for_package(
        return cls(package_name=package_name, config_file=config_file)
    def __repr__(self) -> str:

================
File: src/twat_os/paths.toml
================
[cache]
# Base directory for all cache operations
base_dir = "~/.cache/twat"
# Directory for storing package-specific cache data
package_dir = "~/.cache/twat/{package_name}"

[config]
# Base directory for configuration files
base_dir = "~/.config/twat"
# Directory for package-specific configuration
package_dir = "~/.config/twat/{package_name}"

[data]
# Base directory for user data
base_dir = "~/.local/share/twat"
# Directory for package-specific data
package_dir = "~/.local/share/twat/{package_name}"

[temp]
# Base directory for temporary files
base_dir = "~/tmp/twat"
# Directory for package-specific temporary files
package_dir = "~/tmp/twat/{package_name}"

[genai]
# Directory for storing LoRA files
lora_dir = "~/.local/share/twat/genai/loras"
# Directory for model weights
model_dir = "~/.local/share/twat/genai/models"
# Directory for generated images
output_dir = "~/Pictures/twat_genai"

[logs]
# Base directory for log files
base_dir = "~/.local/state/twat/logs"
# Directory for package-specific logs
package_dir = "~/.local/state/twat/logs/{package_name}"

================
File: tests/test_package.py
================
def test_version():

================
File: .gitignore
================
*_autogen/
.DS_Store
__version__.py
__pycache__/
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
!?*.[Cc]ache/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!**/[Pp]ackages/build/
!Directory.Build.rsp
.*crunch*.local.xml
.axoCover/*
.builds
.cr/personal
.fake/
.history/
.ionide/
.localhistory/
.mfractor/
.ntvs_analysis.dat
.paket/paket.exe
.sass-cache/
.vs/
.vscode
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim_*.settings
*.bim.layout
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
**/[Pp]ackages/*
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
*~
~$*
$tf/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
coverage*.info
coverage*.json
coverage*.xml
csx/
CTestTestfile.cmake
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
ecf/
FakesAssemblies/
FodyWeavers.xsd
Generated_Code/
Generated\ Files/
healthchecksdb
install_manifest.txt
ipch/
Makefile
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
UpgradeLog*.htm
UpgradeLog*.XML
x64/
x86/
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Distribution / packaging
!dist/.gitkeep

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
.ruff_cache/

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Project specific
__version__.py
_private

================
File: .pre-commit-config.yaml
================
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]

================
File: cleanup.py
================
LOG_FILE = Path("CLEANUP.txt")
os.chdir(Path(__file__).parent)
def new() -> None:
    if LOG_FILE.exists():
        LOG_FILE.unlink()
def prefix() -> None:
    readme = Path(".cursor/rules/0project.mdc")
    if readme.exists():
        log_message("\n=== PROJECT STATEMENT ===")
        content = readme.read_text()
        log_message(content)
def suffix() -> None:
    todo = Path("TODO.md")
    if todo.exists():
        log_message("\n=== TODO.md ===")
        content = todo.read_text()
def log_message(message: str) -> None:
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
    with LOG_FILE.open("a") as f:
        f.write(log_line)
def run_command(cmd: list[str], check: bool = True) -> subprocess.CompletedProcess:
        result = subprocess.run(
            log_message(result.stdout)
        log_message(f"Command failed: {' '.join(cmd)}")
        log_message(f"Error: {e.stderr}")
        return subprocess.CompletedProcess(cmd, 1, "", str(e))
def check_command_exists(cmd: str) -> bool:
        return which(cmd) is not None
class Cleanup:
    def __init__(self) -> None:
        self.workspace = Path.cwd()
    def _print_header(self, message: str) -> None:
        log_message(f"\n=== {message} ===")
    def _check_required_files(self) -> bool:
            if not (self.workspace / file).exists():
                log_message(f"Error: {file} is missing")
    def _generate_tree(self) -> None:
        if not check_command_exists("tree"):
            log_message("Warning: 'tree' command not found. Skipping tree generation.")
            rules_dir = Path(".cursor/rules")
            rules_dir.mkdir(parents=True, exist_ok=True)
            tree_result = run_command(["tree", "-a", "-I", ".git", "--gitignore", "-n", "-h", "-I", "*_cache"])
            with open(rules_dir / "filetree.mdc", "w") as f:
                f.write("---\ndescription: File tree of the project\nglobs: \n---\n")
                f.write(tree_text)
            log_message("\nProject structure:")
            log_message(tree_text)
            log_message(f"Failed to generate tree: {e}")
    def _git_status(self) -> bool:
        result = run_command(["git", "status", "--porcelain"], check=False)
        return bool(result.stdout.strip())
    def _venv(self) -> None:
        log_message("Setting up virtual environment")
            run_command(["uv", "venv"])
            if venv_path.exists():
                os.environ["VIRTUAL_ENV"] = str(self.workspace / ".venv")
                log_message("Virtual environment created and activated")
                log_message("Virtual environment created but activation failed")
            log_message(f"Failed to create virtual environment: {e}")
    def _install(self) -> None:
        log_message("Installing package with all extras")
            self._venv()
            run_command(["uv", "pip", "install", "-e", ".[test,dev]"])
            log_message("Package installed successfully")
            log_message(f"Failed to install package: {e}")
    def _run_checks(self) -> None:
        log_message("Running code quality checks")
            log_message(">>> Running code fixes...")
            run_command(
            log_message(">>>Running type checks...")
            run_command(["python", "-m", "mypy", "src", "tests"], check=False)
            log_message(">>> Running tests...")
            run_command(["python", "-m", "pytest", "tests"], check=False)
            log_message("All checks completed")
            log_message(f"Failed during checks: {e}")
    def status(self) -> None:
        prefix()  # Add README.md content at start
        self._print_header("Current Status")
        self._check_required_files()
        self._generate_tree()
        result = run_command(["git", "status"], check=False)
        self._print_header("Environment Status")
        self._install()
        self._run_checks()
        suffix()  # Add TODO.md content at end
    def venv(self) -> None:
        self._print_header("Virtual Environment Setup")
    def install(self) -> None:
        self._print_header("Package Installation")
    def update(self) -> None:
        self.status()
        if self._git_status():
            log_message("Changes detected in repository")
                run_command(["git", "add", "."])
                run_command(["git", "commit", "-m", commit_msg])
                log_message("Changes committed successfully")
                log_message(f"Failed to commit changes: {e}")
            log_message("No changes to commit")
    def push(self) -> None:
        self._print_header("Pushing Changes")
            run_command(["git", "push"])
            log_message("Changes pushed successfully")
            log_message(f"Failed to push changes: {e}")
def repomix(
            cmd.append("--compress")
            cmd.append("--remove-empty-lines")
            cmd.append("-i")
            cmd.append(ignore_patterns)
        cmd.extend(["-o", output_file])
        run_command(cmd)
        log_message(f"Repository content mixed into {output_file}")
        log_message(f"Failed to mix repository: {e}")
def print_usage() -> None:
    log_message("Usage:")
    log_message("  cleanup.py status   # Show current status and run all checks")
    log_message("  cleanup.py venv     # Create virtual environment")
    log_message("  cleanup.py install  # Install package with all extras")
    log_message("  cleanup.py update   # Update and commit changes")
    log_message("  cleanup.py push     # Push changes to remote")
def main() -> NoReturn:
    new()  # Clear log file
    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)
    cleanup = Cleanup()
            cleanup.status()
            cleanup.venv()
            cleanup.install()
            cleanup.update()
            cleanup.push()
        log_message(f"Error: {e}")
    repomix()
    sys.stdout.write(Path("CLEANUP.txt").read_text())
    sys.exit(0)  # Ensure we exit with a status code
    main()

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: pyproject.toml
================
# this_file: pyproject.toml
# this_project: twat_os
[project]
name = "twat-os"
dynamic = ["version"]
description = "Operating system utilities for twat"
readme = "README.md"
requires-python = ">=3.10"
license = "MIT"
keywords = [
    "os",
    "system",
    "twat"
]
classifiers = [
    "Development Status :: 4 - Beta",
    "Programming Language :: Python",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
]

dependencies = [
    "fire>=0.6.0",
    "loguru>=0.7.2",
    "twat>=1.8.1"
]

[project.optional-dependencies]
dev = [
    "hatch>=1.14.0",
    "hatchling>=1.27.0",
    "hatch-vcs>=0.4.0",
    "mypy>=1.15.0",
    "pre-commit>=4.1.0",
    "pyupgrade>=3.19.1",
    "ruff>=0.9.6"
]

test = [
    "pytest>=8.3.4",
    "pytest-cov>=6.0.0",
    "pytest-benchmark>=5.1.0",
    "pytest-mock>=3.14.0",
    "pytest-asyncio>=0.25.3",
    "pytest-timeout>=2.3.1"
]

all = [
    "fire>=0.6.0",
    "loguru>=0.7.2",
    "twat>=1.8.1"
]

[project.scripts]
twat-os = "twat_os.__main__:main"

[project.entry-points."twat.plugins"]
os = "twat_os"

[[project.authors]]
name = "Adam Twardoch"
email = "adam+github@twardoch.com"

[project.urls]
Documentation = "https://github.com/twardoch/twat-os#readme"
Issues = "https://github.com/twardoch/twat-os/issues"
Source = "https://github.com/twardoch/twat-os"

[build-system]
build-backend = "hatchling.build"
requires = [
    "hatchling>=1.27.0",
    "hatch-vcs>=0.4.0"
]

[tool.coverage.paths]
twat_os = ["src/twat_os", "*/twat-os/src/twat_os"]
tests = ["tests", "*/twat-os/tests"]

[tool.coverage.report]
exclude_lines = [
    "no cov",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:"
]

[tool.coverage.run]
source_pkgs = ["twat_os", "tests"]
branch = true
parallel = true
omit = ["src/twat_os/__about__.py"]

[tool.hatch.build.hooks.vcs]
version-file = "src/twat_os/__version__.py"

[tool.hatch.build.targets.wheel]
packages = ["src/twat_os"]
include = [
    "src/twat_os/**/*.py",
    "src/twat_os/py.typed"
]

[tool.hatch.envs.default]
dependencies = [
    "pytest>=8.3.4",
    "pytest-cov>=6.0.0",
    "ruff>=0.9.6",
    "mypy>=1.15.0"
]

[tool.hatch.envs.default.scripts]
test = "pytest {args:tests}"
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
type-check = "mypy src/twat_os tests"
lint = ["ruff check src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]
fix = ["ruff check --fix --unsafe-fixes src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]

[[tool.hatch.envs.all.matrix]]
python = ["3.10", "3.11", "3.12"]

[tool.hatch.envs.lint]
detached = true
dependencies = [
    "pytest>=8.3.4",
    "pytest-cov>=6.0.0",
    "ruff>=0.9.6",
    "mypy>=1.15.0"
]

[tool.hatch.envs.lint.scripts]
typing = "mypy --install-types --non-interactive {args:src/twat_os tests}"
style = ["ruff check {args:.}", "ruff format --respect-gitignore {args:.}"]
fmt = ["ruff format --respect-gitignore {args:.}", "ruff check --fix {args:.}"]
all = ["style", "typing"]

[tool.hatch.envs.test]
dependencies = []

[tool.hatch.envs.test.scripts]
test = "python -m pytest -n auto -p no:briefcase {args:tests}"
test-cov = "python -m pytest -n auto -p no:briefcase --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
bench = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only"
bench-save = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only --benchmark-json=benchmark/results.json"

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
version_scheme = "post-release"

[tool.mypy]
python_version = "3.10"
check_untyped_defs = true
disallow_incomplete_defs = true
disallow_untyped_decorators = true
disallow_untyped_defs = true
no_implicit_optional = true
warn_no_return = true
warn_redundant_casts = true
warn_return_any = true
warn_unreachable = true
warn_unused_configs = true
warn_unused_ignores = true

[tool.ruff]
line-length = 88
target-version = "py310"

[tool.ruff.lint]
extend-select = [
    "A",
    "ARG",
    "B",
    "C",
    "DTZ",
    "E",
    "EM",
    "F",
    "FBT",
    "I",
    "ICN",
    "ISC",
    "N",
    "PLC",
    "PLE",
    "PLR",
    "PLW",
    "Q",
    "RUF",
    "S",
    "T",
    "TID",
    "UP",
    "W",
    "YTT"
]
ignore = [
    "ARG001",
    "E501",
    "I001",
    "RUF001",
    "PLR2004",
    "EXE003",
    "ISC001"
]

[tool.ruff.per-file-ignores]
"tests/*" = ["S101"]

[tool.pytest.ini_options]
addopts = "-v --durations=10 -p no:briefcase"
asyncio_mode = "auto"
console_output_style = "progress"
filterwarnings = [
    "ignore::DeprecationWarning",
    "ignore::UserWarning"
]
log_cli = true
log_cli_level = "INFO"
markers = [
    "benchmark: marks tests as benchmarks (select with '-m benchmark')",
    "unit: mark a test as a unit test",
    "integration: mark a test as an integration test",
    "permutation: tests for permutation functionality",
    "parameter: tests for parameter parsing",
    "prompt: tests for prompt parsing"
]
norecursedirs = [
    ".*",
    "build",
    "dist",
    "venv",
    "__pycache__",
    "*.egg-info",
    "_private"
]
python_classes = ["Test*"]
python_files = ["test_*.py"]
python_functions = ["test_*"]
testpaths = ["tests"]

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",
    "max",
    "mean",
    "stddev",
    "median",
    "iqr",
    "ops",
    "rounds"
]

================
File: README.md
================
#



## Features

- Plugin for twat
- Modern Python packaging with PEP 621 compliance
- Type hints and runtime type checking
- Comprehensive test suite and documentation
- CI/CD ready configuration

## Installation

```bash
pip install twat-os
```

## Usage

```python
import twat_os
plugin = twat_os.plugin
```

## Development

This project uses [Hatch](https://hatch.pypa.io/) for development workflow management.

### Setup Development Environment

```bash
# Install hatch if you haven't already
pip install hatch

# Create and activate development environment
hatch shell

# Run tests
hatch run test

# Run tests with coverage
hatch run test-cov

# Run linting
hatch run lint

# Format code
hatch run format
```

## License

MIT License

================
File: VERSION.txt
================
v2.6.2



================================================================
End of Codebase
================================================================
````

## CLEANUP.txt

```text
2025-06-25 10:53:28 -
=== PROJECT STATEMENT ===
2025-06-25 10:53:28 - ---
description: About the twat-os project
globs:
---
# About twat-os

`twat-os` is a Python package providing operating system related utilities for the `twat` ecosystem. Its primary focus is on robust and configurable path management for applications and plugins.

## Key Features:
- **Path Management**: Centralized system for managing application paths (cache, config, data, logs, etc.) using `platformdirs` for cross-platform compatibility and `pydantic` for validation.
- **Configurable**: Path definitions can be customized via a `paths.toml` file.
- **Integration with `twat`**: Designed to function as a plugin within the `twat` framework.
- **Developer Experience**: Clean API with type hints.

## Development Notes
- Uses `uv` for Python package management.
- Quality tools: `ruff` for linting/formatting, `mypy` for type checking, `pytest` for testing.
- Built with Hatch and includes CI/CD setup using GitHub Actions.
- Strong typing and runtime checks are encouraged.

2025-06-25 10:53:28 -
=== Current Status ===
2025-06-25 10:53:28 - [4.0K]  .
├── [4.0K]  .cursor
│   └── [4.0K]  rules
│       ├── [ 982]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.0K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [4.0K]  .github
│   └── [4.0K]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.1K]  CHANGELOG.md
├── [1.1K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 187]  LOG.md
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [  34]  TODO.md
├── [   7]  VERSION.txt
├── [ 12K]  cleanup.py
├── [4.0K]  dist
│   └── [   1]  .gitkeep
├── [ 92K]  llms.txt
├── [ 11K]  pyproject.toml
├── [4.0K]  src
│   └── [4.0K]  twat_os
│       ├── [  95]  __init__.py
│       ├── [7.5K]  paths.py
│       └── [1.0K]  paths.toml
└── [4.0K]  tests
    └── [ 145]  test_package.py

9 directories, 24 files

2025-06-25 10:53:28 -
Project structure:
2025-06-25 10:53:28 - [4.0K]  .
├── [4.0K]  .cursor
│   └── [4.0K]  rules
│       ├── [ 982]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.0K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [4.0K]  .github
│   └── [4.0K]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.1K]  CHANGELOG.md
├── [1.1K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 187]  LOG.md
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [  34]  TODO.md
├── [   7]  VERSION.txt
├── [ 12K]  cleanup.py
├── [4.0K]  dist
│   └── [   1]  .gitkeep
├── [ 92K]  llms.txt
├── [ 11K]  pyproject.toml
├── [4.0K]  src
│   └── [4.0K]  twat_os
│       ├── [  95]  __init__.py
│       ├── [7.5K]  paths.py
│       └── [1.0K]  paths.toml
└── [4.0K]  tests
    └── [ 145]  test_package.py

9 directories, 24 files

2025-06-25 10:53:28 - HEAD detached from 23e0688
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   .cursor/rules/filetree.mdc
	modified:   CLEANUP.txt

no changes added to commit (use "git add" and/or "git commit -a")

2025-06-25 10:53:28 - HEAD detached from 23e0688
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   .cursor/rules/filetree.mdc
	modified:   CLEANUP.txt

no changes added to commit (use "git add" and/or "git commit -a")

2025-06-25 10:53:28 -
=== Environment Status ===
2025-06-25 10:53:28 - Setting up virtual environment
2025-06-25 10:53:29 - Virtual environment created and activated
2025-06-25 10:53:29 - Installing package with all extras
2025-06-25 10:53:29 - Setting up virtual environment
2025-06-25 10:53:29 - Virtual environment created and activated
2025-06-25 10:53:36 - Package installed successfully
2025-06-25 10:53:36 - Running code quality checks
2025-06-25 10:53:36 - >>> Running code fixes...
2025-06-25 10:53:36 - src/twat_os/paths.py:44:43: PTH111 `os.path.expanduser()` should be replaced by `Path.expanduser()`
   |
42 |         if isinstance(v, str):
43 |             # Expand both ~ and environment variables
44 |             expanded = os.path.expandvars(os.path.expanduser(v))
   |                                           ^^^^^^^^^^^^^^^^^^ PTH111
45 |             return Path(expanded)
46 |         return v
   |

src/twat_os/paths.py:162:43: PTH111 `os.path.expanduser()` should be replaced by `Path.expanduser()`
    |
160 |             if not self.package_name:
161 |                 return None
162 |             expanded = os.path.expandvars(os.path.expanduser(path_str))
    |                                           ^^^^^^^^^^^^^^^^^^ PTH111
163 |             return Path(expanded.format(package_name=self.package_name))
    |

tests/test_package.py:6:5: PLC0415 `import` should be at the top-level of a file
  |
4 | def test_version():
5 |     """Verify package exposes version."""
6 |     import twat_os
  |     ^^^^^^^^^^^^^^ PLC0415
7 |
8 |     assert twat_os.__version__
  |

Found 5 errors (2 fixed, 3 remaining).

2025-06-25 10:53:36 - 3 files left unchanged

2025-06-25 10:53:36 - >>>Running type checks...
2025-06-25 10:53:46 - tests/test_package.py:4: error: Function is missing a return type annotation  [no-untyped-def]
tests/test_package.py:4: note: Use "-> None" if function does not return a value
src/twat_os/paths.py:218: error: Returning Any from function declared to return "Path"  [no-any-return]
Found 2 errors in 2 files (checked 4 source files)

2025-06-25 10:53:46 - >>> Running tests...
2025-06-25 10:53:48 - ============================= test session starts ==============================
platform linux -- Python 3.12.11, pytest-8.4.1, pluggy-1.6.0 -- /app/.venv/bin/python
cachedir: .pytest_cache
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /app
configfile: pyproject.toml
plugins: asyncio-1.0.0, benchmark-5.1.0, mock-3.14.1, timeout-2.4.0, cov-6.2.1, anyio-4.9.0, xdist-3.7.0
asyncio: mode=Mode.AUTO, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 1 item

tests/test_package.py::test_version PASSED                               [100%]

============================= slowest 10 durations =============================

(3 durations < 0.005s hidden.  Use -vv to show these durations.)
============================== 1 passed in 0.03s ===============================

2025-06-25 10:53:48 - All checks completed
2025-06-25 10:53:48 -
=== TODO.md ===
2025-06-25 10:53:48 - # TODO

- [ ] Initial task setup.
```

## llms.txt

`````text
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-06-25 10:48:14

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
cleanup.py
src
  twat_os
    __init__.py
    paths.toml
    paths.py
pyproject.toml
VERSION.txt
tests
  test_package.py
.github
  workflows
    release.yml
    push.yml
.cursor
  rules
    cleanup.mdc
    0project.mdc
    filetree.mdc
    quality.mdc
README.md
LICENSE
.gitignore
.pre-commit-config.yaml
REPO_CONTENT.txt
CLEANUP.txt
```

# Repository Files


## cleanup.py

```python
#!/usr/bin/env -S uv run -s
# /// script
# dependencies = [
#   "ruff>=0.9.6",
#   "pytest>=8.3.4",
#   "mypy>=1.15.0",
# ]
# ///
# this_file: cleanup.py

"""
Cleanup tool for managing repository tasks and maintaining code quality.

This script provides a comprehensive set of commands for repository maintenance:

When to use each command:

- `cleanup.py status`: Use this FIRST when starting work to check the current state
  of the repository. It shows file structure, git status, and runs all code quality
  checks. Run this before making any changes to ensure you're starting from a clean state.

- `cleanup.py venv`: Run this when setting up the project for the first time or if
  your virtual environment is corrupted/missing. Creates a new virtual environment
  using uv.

- `cleanup.py install`: Use after `venv` or when dependencies have changed. Installs
  the package and all development dependencies in editable mode.

- `cleanup.py update`: Run this when you've made changes and want to commit them.
  It will:
  1. Show current status (like `status` command)
  2. Stage and commit any changes with a generic message
  Use this for routine maintenance commits.

- `cleanup.py push`: Run this after `update` when you want to push your committed
  changes to the remote repository.

Workflow Example:
1. Start work: `cleanup.py status`
2. Make changes to code
3. Commit changes: `cleanup.py update`
4. Push to remote: `cleanup.py push`

The script maintains a CLEANUP.txt file that records all operations with timestamps.
It also includes content from README.md at the start and TODO.md at the end of logs
for context.

Required Files:
- LOG.md: Project changelog
- README.md: Project documentation
- TODO.md: Pending tasks and future plans
"""

import subprocess
import os
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import NoReturn
from shutil import which

# Configuration
IGNORE_PATTERNS = [
    ".git",
    ".venv",
    "__pycache__",
    "*.pyc",
    "dist",
    "build",
    "*.egg-info",
]
REQUIRED_FILES = ["LOG.md", ".cursor/rules/0project.mdc", "TODO.md"]
LOG_FILE = Path("CLEANUP.txt")

# Ensure we're working from the script's directory
os.chdir(Path(__file__).parent)


def new() -> None:
    """Remove existing log file."""
    if LOG_FILE.exists():
        LOG_FILE.unlink()


def prefix() -> None:
    """Write README.md content to log file."""
    readme = Path(".cursor/rules/0project.mdc")
    if readme.exists():
        log_message("\n=== PROJECT STATEMENT ===")
        content = readme.read_text()
        log_message(content)


def suffix() -> None:
    """Write TODO.md content to log file."""
    todo = Path("TODO.md")
    if todo.exists():
        log_message("\n=== TODO.md ===")
        content = todo.read_text()
        log_message(content)


def log_message(message: str) -> None:
    """Log a message to file and console with timestamp."""
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
    log_line = f"{timestamp} - {message}\n"
    with LOG_FILE.open("a") as f:
        f.write(log_line)


def run_command(cmd: list[str], check: bool = True) -> subprocess.CompletedProcess:
    """Run a shell command and return the result."""
    try:
        result = subprocess.run(
            cmd,
            check=check,
            capture_output=True,
            text=True,
            shell=False,  # Explicitly set shell=False for security
        )
        if result.stdout:
            log_message(result.stdout)
        return result
    except subprocess.CalledProcessError as e:
        log_message(f"Command failed: {' '.join(cmd)}")
        log_message(f"Error: {e.stderr}")
        if check:
            raise
        return subprocess.CompletedProcess(cmd, 1, "", str(e))


def check_command_exists(cmd: str) -> bool:
    """Check if a command exists in the system."""
    try:
        return which(cmd) is not None
    except Exception:
        return False


class Cleanup:
    """Main cleanup tool class."""

    def __init__(self) -> None:
        self.workspace = Path.cwd()

    def _print_header(self, message: str) -> None:
        """Print a section header."""
        log_message(f"\n=== {message} ===")

    def _check_required_files(self) -> bool:
        """Check if all required files exist."""
        missing = False
        for file in REQUIRED_FILES:
            if not (self.workspace / file).exists():
                log_message(f"Error: {file} is missing")
                missing = True
        return not missing

    def _generate_tree(self) -> None:
        """Generate and display tree structure of the project."""
        if not check_command_exists("tree"):
            log_message("Warning: 'tree' command not found. Skipping tree generation.")
            return

        try:
            # Create/overwrite the file with YAML frontmatter
            rules_dir = Path(".cursor/rules")
            rules_dir.mkdir(parents=True, exist_ok=True)
            # Get tree output
            tree_result = run_command(["tree", "-a", "-I", ".git", "--gitignore", "-n", "-h", "-I", "*_cache"])
            tree_text = tree_result.stdout
            # Write frontmatter and tree output to file
            with open(rules_dir / "filetree.mdc", "w") as f:
                f.write("---\ndescription: File tree of the project\nglobs: \n---\n")
                f.write(tree_text)

            # Log the contents
            log_message("\nProject structure:")
            log_message(tree_text)

        except Exception as e:
            log_message(f"Failed to generate tree: {e}")
        return

    def _git_status(self) -> bool:
        """Check git status and return True if there are changes."""
        result = run_command(["git", "status", "--porcelain"], check=False)
        return bool(result.stdout.strip())

    def _venv(self) -> None:
        """Create and activate virtual environment using uv."""
        log_message("Setting up virtual environment")
        try:
            run_command(["uv", "venv"])
            # Activate the virtual environment
            venv_path = self.workspace / ".venv" / "bin" / "activate"
            if venv_path.exists():
                os.environ["VIRTUAL_ENV"] = str(self.workspace / ".venv")
                os.environ["PATH"] = f"{self.workspace / '.venv' / 'bin'}{os.pathsep}{os.environ['PATH']}"
                log_message("Virtual environment created and activated")
            else:
                log_message("Virtual environment created but activation failed")
        except Exception as e:
            log_message(f"Failed to create virtual environment: {e}")

    def _install(self) -> None:
        """Install package in development mode with all extras."""
        log_message("Installing package with all extras")
        try:
            self._venv()
            run_command(["uv", "pip", "install", "-e", ".[test,dev]"])
            log_message("Package installed successfully")
        except Exception as e:
            log_message(f"Failed to install package: {e}")

    def _run_checks(self) -> None:
        """Run code quality checks using ruff and pytest."""
        log_message("Running code quality checks")

        try:
            # Run ruff checks
            log_message(">>> Running code fixes...")
            run_command(
                [
                    "python",
                    "-m",
                    "ruff",
                    "check",
                    "--fix",
                    "--unsafe-fixes",
                    "src",
                    "tests",
                ],
                check=False,
            )
            run_command(
                [
                    "python",
                    "-m",
                    "ruff",
                    "format",
                    "--respect-gitignore",
                    "src",
                    "tests",
                ],
                check=False,
            )

            # Run type checks
            log_message(">>>Running type checks...")
            run_command(["python", "-m", "mypy", "src", "tests"], check=False)

            # Run tests
            log_message(">>> Running tests...")
            run_command(["python", "-m", "pytest", "tests"], check=False)

            log_message("All checks completed")
        except Exception as e:
            log_message(f"Failed during checks: {e}")

    def status(self) -> None:
        """Show current repository status: tree structure, git status, and run checks."""
        prefix()  # Add README.md content at start
        self._print_header("Current Status")

        # Check required files
        self._check_required_files()

        # Show tree structure
        self._generate_tree()

        # Show git status
        result = run_command(["git", "status"], check=False)
        log_message(result.stdout)

        # Run additional checks
        self._print_header("Environment Status")
        self._venv()
        self._install()
        self._run_checks()

        suffix()  # Add TODO.md content at end

    def venv(self) -> None:
        """Create and activate virtual environment."""
        self._print_header("Virtual Environment Setup")
        self._venv()

    def install(self) -> None:
        """Install package with all extras."""
        self._print_header("Package Installation")
        self._install()

    def update(self) -> None:
        """Show status and commit any changes if needed."""
        # First show current status
        self.status()

        # Then handle git changes if any
        if self._git_status():
            log_message("Changes detected in repository")
            try:
                # Add all changes
                run_command(["git", "add", "."])
                # Commit changes
                commit_msg = "Update repository files"
                run_command(["git", "commit", "-m", commit_msg])
                log_message("Changes committed successfully")
            except Exception as e:
                log_message(f"Failed to commit changes: {e}")
        else:
            log_message("No changes to commit")

    def push(self) -> None:
        """Push changes to remote repository."""
        self._print_header("Pushing Changes")
        try:
            run_command(["git", "push"])
            log_message("Changes pushed successfully")
        except Exception as e:
            log_message(f"Failed to push changes: {e}")


def repomix(
    *,
    compress: bool = True,
    remove_empty_lines: bool = True,
    ignore_patterns: str = ".specstory/**/*.md,.venv/**,_private/**,CLEANUP.txt,**/*.json,*.lock",
    output_file: str = "REPO_CONTENT.txt",
) -> None:
    """Combine repository files into a single text file.

    Args:
        compress: Whether to compress whitespace in output
        remove_empty_lines: Whether to remove empty lines
        ignore_patterns: Comma-separated glob patterns of files to ignore
        output_file: Output file path
    """
    try:
        # Build command
        cmd = ["repomix"]
        if compress:
            cmd.append("--compress")
        if remove_empty_lines:
            cmd.append("--remove-empty-lines")
        if ignore_patterns:
            cmd.append("-i")
            cmd.append(ignore_patterns)
        cmd.extend(["-o", output_file])

        # Run repomix
        run_command(cmd)
        log_message(f"Repository content mixed into {output_file}")

    except Exception as e:
        log_message(f"Failed to mix repository: {e}")


def print_usage() -> None:
    """Print usage information."""
    log_message("Usage:")
    log_message("  cleanup.py status   # Show current status and run all checks")
    log_message("  cleanup.py venv     # Create virtual environment")
    log_message("  cleanup.py install  # Install package with all extras")
    log_message("  cleanup.py update   # Update and commit changes")
    log_message("  cleanup.py push     # Push changes to remote")


def main() -> NoReturn:
    """Main entry point."""
    new()  # Clear log file

    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)

    command = sys.argv[1]
    cleanup = Cleanup()

    try:
        if command == "status":
            cleanup.status()
        elif command == "venv":
            cleanup.venv()
        elif command == "install":
            cleanup.install()
        elif command == "update":
            cleanup.update()
        elif command == "push":
            cleanup.push()
        else:
            print_usage()
    except Exception as e:
        log_message(f"Error: {e}")
    repomix()
    sys.stdout.write(Path("CLEANUP.txt").read_text())
    sys.exit(0)  # Ensure we exit with a status code


if __name__ == "__main__":
    main()
```

## src/twat_os/__init__.py

```python
"""twat os plugin"""

from importlib import metadata

__version__ = metadata.version(__name__)
```

## src/twat_os/paths.toml

```text
[cache]
# Base directory for all cache operations
base_dir = "~/.cache/twat"
# Directory for storing package-specific cache data
package_dir = "~/.cache/twat/{package_name}"

[config]
# Base directory for configuration files
base_dir = "~/.config/twat"
# Directory for package-specific configuration
package_dir = "~/.config/twat/{package_name}"

[data]
# Base directory for user data
base_dir = "~/.local/share/twat"
# Directory for package-specific data
package_dir = "~/.local/share/twat/{package_name}"

[temp]
# Base directory for temporary files
base_dir = "~/tmp/twat"
# Directory for package-specific temporary files
package_dir = "~/tmp/twat/{package_name}"

[genai]
# Directory for storing LoRA files
lora_dir = "~/.local/share/twat/genai/loras"
# Directory for model weights
model_dir = "~/.local/share/twat/genai/models"
# Directory for generated images
output_dir = "~/Pictures/twat_genai"

[logs]
# Base directory for log files
base_dir = "~/.local/state/twat/logs"
# Directory for package-specific logs
package_dir = "~/.local/state/twat/logs/{package_name}"
```

## src/twat_os/paths.py

```python
#!/usr/bin/env -S uv run
# /// script
# dependencies = ["pydantic", "platformdirs"]
# ///
"""Path management for twat packages.

This module provides a centralized way to manage paths for various twat packages.
It handles path resolution, validation, and creation of directories as needed.
"""

from __future__ import annotations

import os
from pathlib import Path
from typing import Self

import platformdirs
import tomli
from pydantic import BaseModel, Field, field_validator, model_validator

# Load default paths from TOML
PATHS_TOML = Path(__file__).parent / "paths.toml"
DEFAULT_PATHS = tomli.loads(PATHS_TOML.read_text())


class PathConfig(BaseModel):
    """Base configuration for path settings."""

    base_dir: Path
    package_dir: Path | None = None
    create_if_missing: bool = True

    @field_validator("base_dir", "package_dir")
    @classmethod
    def expand_path(cls, v: str | Path | None) -> Path | None:
        """Expand user and environment variables in paths."""
        if v is None:
            return None
        if isinstance(v, str):
            # Expand both ~ and environment variables
            expanded = os.path.expandvars(os.path.expanduser(v))
            return Path(expanded)
        return v

    @model_validator(mode="after")
    def validate_and_create_dirs(self) -> Self:
        """Create directories if they don't exist and creation is enabled."""
        if self.create_if_missing:
            self.base_dir.mkdir(parents=True, exist_ok=True)
            if self.package_dir:
                self.package_dir.mkdir(parents=True, exist_ok=True)
        return self


class CacheConfig(PathConfig):
    """Configuration for cache directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_cache_dir()) / "twat"
    )


class ConfigDirConfig(PathConfig):
    """Configuration for config directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_config_dir()) / "twat"
    )


class DataDirConfig(PathConfig):
    """Configuration for data directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat"
    )


class TempDirConfig(PathConfig):
    """Configuration for temporary directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_runtime_dir()) / "twat"
    )


class GenAIConfig(PathConfig):
    """Configuration for GenAI-specific paths."""

    lora_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/loras"
    )
    model_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/models"
    )
    output_dir: Path = Field(
        default_factory=lambda: Path.home() / "Pictures/twat_genai"
    )

    @model_validator(mode="after")
    def validate_and_create_all_dirs(self) -> Self:
        """Create all GenAI directories if enabled."""
        if self.create_if_missing:
            self.base_dir.mkdir(parents=True, exist_ok=True)
            self.lora_dir.mkdir(parents=True, exist_ok=True)
            self.model_dir.mkdir(parents=True, exist_ok=True)
            self.output_dir.mkdir(parents=True, exist_ok=True)
        return self


class LogConfig(PathConfig):
    """Configuration for log directories."""

    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_state_dir()) / "twat/logs"
    )


class PathManager:
    """Central manager for all path configurations."""

    def __init__(
        self,
        package_name: str | None = None,
        config_file: str | Path | None = None,
        create_dirs: bool = True,
    ) -> None:
        """Initialize path manager.

        Args:
            package_name: Optional package name for package-specific paths
            config_file: Optional path to custom config file
            create_dirs: Whether to create directories if they don't exist
        """
        self.package_name = package_name
        self.create_dirs = create_dirs

        # Load config
        if config_file:
            config_path = Path(config_file)
            if not config_path.exists():
                msg = f"Config file not found: {config_file}"
                raise FileNotFoundError(msg)
            self.config = tomli.loads(config_path.read_text())
        else:
            self.config = DEFAULT_PATHS

        # Initialize path configurations
        self._init_paths()

    def _init_paths(self) -> None:
        """Initialize all path configurations."""

        # Helper to format package-specific paths
        def format_path(path_str: str) -> Path | None:
            if not self.package_name:
                return None
            expanded = os.path.expandvars(os.path.expanduser(path_str))
            return Path(expanded.format(package_name=self.package_name))

        # Initialize configurations
        self.cache = CacheConfig(
            base_dir=self.config["cache"]["base_dir"],
            package_dir=format_path(self.config["cache"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.config_dir = ConfigDirConfig(
            base_dir=self.config["config"]["base_dir"],
            package_dir=format_path(self.config["config"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.data = DataDirConfig(
            base_dir=self.config["data"]["base_dir"],
            package_dir=format_path(self.config["data"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.temp = TempDirConfig(
            base_dir=self.config["temp"]["base_dir"],
            package_dir=format_path(self.config["temp"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

        self.genai = GenAIConfig(
            base_dir=self.config["data"]["base_dir"],
            lora_dir=self.config["genai"]["lora_dir"],
            model_dir=self.config["genai"]["model_dir"],
            output_dir=self.config["genai"]["output_dir"],
            create_if_missing=self.create_dirs,
        )

        self.logs = LogConfig(
            base_dir=self.config["logs"]["base_dir"],
            package_dir=format_path(self.config["logs"]["package_dir"]),
            create_if_missing=self.create_dirs,
        )

    def get_path(self, category: str, key: str = "base_dir") -> Path:
        """Get a specific path by category and key.

        Args:
            category: Path category (cache, config, data, temp, genai, logs)
            key: Path key within the category (base_dir, package_dir, etc.)

        Returns:
            Resolved path

        Raises:
            AttributeError: If category or key doesn't exist
        """
        config = getattr(self, category)
        return getattr(config, key)

    @classmethod
    def for_package(
        cls, package_name: str, config_file: str | Path | None = None
    ) -> PathManager:
        """Create a PathManager instance for a specific package.

        Args:
            package_name: Package name
            config_file: Optional path to custom config file

        Returns:
            PathManager instance configured for the package
        """
        return cls(package_name=package_name, config_file=config_file)

    def __repr__(self) -> str:
        """Return string representation of PathManager."""
        package_info = (
            f" for package '{self.package_name}'" if self.package_name else ""
        )
        return f"PathManager{package_info}"
```

## pyproject.toml

```text
#==============================================================================
# TWAT_OS PACKAGE CONFIGURATION
# This pyproject.toml defines the package metadata, dependencies, build system,
# and development environment for the twat-os package, which provides operating
# system utilities for the twat framework.
#==============================================================================

#------------------------------------------------------------------------------
# PROJECT METADATA
# Core package information used by PyPI and package managers.
#------------------------------------------------------------------------------
[project]
name = "twat-os" # Package name on PyPI
dynamic = ["version"] # Fields set dynamically at build time
description = "Operating system utilities for twat" # Short description
readme = "README.md" # Path to README file
requires-python = ">=3.10" # Minimum Python version
license = "MIT" # License type

# Keywords for PyPI search
keywords = [
    "os",
    "system",
    "twat",
    "utilities",
    "operating-system",
]

# PyPI classifiers for package categorization
classifiers = [
    "Development Status :: 4 - Beta", # Package maturity level
    "Programming Language :: Python",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
    "Operating System :: OS Independent",
    "License :: OSI Approved :: MIT License",
    "Intended Audience :: Developers",
]

# Core dependencies
dependencies = [
    "fire>=0.6.0",      # CLI framework
    "loguru>=0.7.2",    # Structured logging
    "twat>=1.8.1"       # Core twat package
]

#------------------------------------------------------------------------------
# OPTIONAL DEPENDENCIES
# Additional dependencies for optional features, development, and testing.
#------------------------------------------------------------------------------
[project.optional-dependencies]

# Development tools
dev = [
    "hatch>=1.14.0",         # Build tool
    "hatchling>=1.27.0",     # Build backend
    "hatch-vcs>=0.4.0",      # Version control integration
    "mypy>=1.15.0",          # Type checking
    "pre-commit>=4.1.0",     # Pre-commit hooks
    "pyupgrade>=3.19.1",     # Python syntax upgrader
    "ruff>=0.9.7",           # Linting and formatting
    "absolufy-imports>=0.3.1", # Absolute imports
    "isort>=6.0.1"           # Import sorting
]

# Testing tools
test = [
    "pytest>=8.3.4",           # Testing framework
    "pytest-cov>=6.0.0",       # Coverage reporting
    "pytest-xdist>=3.6.1",     # Parallel testing
    "pytest-benchmark[histogram]>=5.1.0",  # Benchmarking with histogram
    "pytest-mock>=3.14.0",     # Mocking
    "pytest-asyncio>=0.25.3",  # Async testing
    "pytest-timeout>=2.3.1",   # Test timeouts
    "coverage[toml]>=7.6.12"   # Coverage with TOML support
]

# Documentation tools
docs = [
    "sphinx>=7.2.6",
    "sphinx-rtd-theme>=2.0.0",
    "sphinx-autodoc-typehints>=2.0.0",
    "myst-parser>=3.0.0", # Markdown support in Sphinx
]

# All optional dependencies combined
all = [
    "fire>=0.6.0",
    "loguru>=0.7.2",
    "twat>=1.8.1",
    "pathlib>=1.0.1",         # Path manipulation utilities
    "psutil>=5.9.5",          # System monitoring and resource utilization
    "pre-commit>=4.1.0",      # Pre-commit hooks
    "ruff>=0.9.7",            # Linting and formatting
    "mypy>=1.15.0"            # Type checking
]

#------------------------------------------------------------------------------
# COMMAND-LINE SCRIPTS
# Entry points for command-line executables installed with the package.
#------------------------------------------------------------------------------
[project.scripts]
twat-os = "twat_os.__main__:main"

[project.entry-points."twat.plugins"]
os = "twat_os"

# Author information
[[project.authors]]
name = "Adam Twardoch"
email = "adam+github@twardoch.com"

# Project URLs
[project.urls]
Documentation = "https://github.com/twardoch/twat-os#readme"
Issues = "https://github.com/twardoch/twat-os/issues"
Source = "https://github.com/twardoch/twat-os"

#------------------------------------------------------------------------------
# BUILD SYSTEM CONFIGURATION
# Defines the tools required to build the package.
#------------------------------------------------------------------------------
[build-system]
build-backend = "hatchling.build"
requires = [
    "hatchling>=1.27.0",
    "hatch-vcs>=0.4.0"
]

#------------------------------------------------------------------------------
# COVERAGE CONFIGURATION
# Settings for test coverage measurement and reporting.
#------------------------------------------------------------------------------
[tool.coverage.paths]
twat_os = ["src/twat_os", "*/twat-os/src/twat_os"]
tests = ["tests", "*/twat-os/tests"]

[tool.coverage.report]
exclude_lines = [
    "no cov",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:"
]

[tool.coverage.run]
source_pkgs = ["twat_os", "tests"]
branch = true
parallel = true
omit = ["src/twat_os/__about__.py"]

#------------------------------------------------------------------------------
# HATCH BUILD CONFIGURATION
# Configures the build process and development environments.
#------------------------------------------------------------------------------
[tool.hatch.build.hooks.vcs]
version-file = "src/twat_os/__version__.py"

[tool.hatch.build.targets.wheel]
packages = ["src/twat_os"]
include = [
    "src/twat_os/**/*.py",
    "src/twat_os/py.typed"
]
reproducible = true

[tool.hatch.envs.default]
features = ["dev", "test", "all"]

[tool.hatch.envs.default.scripts]
test = "pytest {args:tests}"
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
type-check = "mypy src/twat_os tests"
lint = ["ruff check src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]
fix = ["ruff check --fix --unsafe-fixes src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]

[[tool.hatch.envs.all.matrix]]
python = ["3.10", "3.11", "3.12"]

[tool.hatch.envs.lint]
detached = true
features = ["dev"]

[tool.hatch.envs.lint.scripts]
typing = "mypy --install-types --non-interactive {args:src/twat_os tests}"
style = ["ruff check {args:.}", "ruff format --respect-gitignore {args:.}"]
fmt = ["ruff format --respect-gitignore {args:.}", "ruff check --fix {args:.}"]
all = ["style", "typing"]

[tool.hatch.envs.test]
features = ["test"]

[tool.hatch.envs.test.scripts]
test = "python -m pytest -n auto -p no:briefcase {args:tests}"
test-cov = "python -m pytest -n auto -p no:briefcase --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
bench = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only"
bench-save = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only --benchmark-json=benchmark/results.json"

# Documentation environment
[tool.hatch.envs.docs]
features = ["docs"]

# Documentation environment commands
[tool.hatch.envs.docs.scripts]
build = "sphinx-build -b html docs/source docs/build"

# GitHub Actions workflow configuration
[tool.hatch.envs.ci]
features = ["test"]

[tool.hatch.envs.ci.scripts]
test = "pytest --cov=src/twat_os --cov-report=xml"

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
version_scheme = "post-release"

#------------------------------------------------------------------------------
# MYPY CONFIGURATION
# Configuration for type checking with mypy.
#------------------------------------------------------------------------------
[tool.mypy]
python_version = "3.10"
check_untyped_defs = true
disallow_incomplete_defs = true
disallow_untyped_decorators = true
disallow_untyped_defs = true
no_implicit_optional = true
warn_no_return = true
warn_redundant_casts = true
warn_return_any = true
warn_unreachable = true
warn_unused_configs = true
warn_unused_ignores = true

#------------------------------------------------------------------------------
# RUFF CONFIGURATION
# Configuration for Ruff linting and formatting.
#------------------------------------------------------------------------------
[tool.ruff]
line-length = 88
target-version = "py310"

[tool.ruff.lint]
extend-select = [
    "A",     # flake8-builtins
    "ARG",   # flake8-unused-arguments
    "ASYNC", # flake8-async
    "B",     # flake8-bugbear
    "C",     # flake8-comprehensions
    "DTZ",   # flake8-datetimez
    "E",     # pycodestyle errors
    "EM",    # flake8-errmsg
    "F",     # pyflakes
    "FBT",   # flake8-boolean-trap
    "I",     # isort
    "ICN",   # flake8-import-conventions
    "ISC",   # flake8-implicit-str-concat
    "LOG",   # flake8-logging
    "N",     # pep8-naming
    "PLC",   # pylint convention
    "PLE",   # pylint error
    "PLR",   # pylint refactor
    "PLW",   # pylint warning
    "PT",    # flake8-pytest-style
    "PTH",   # flake8-use-pathlib
    "PYI",   # flake8-pyi
    "RET",   # flake8-return
    "RSE",   # flake8-raise
    "RUF",   # Ruff-specific
    "S",     # flake8-bandit
    "SIM",   # flake8-simplify
    "T",     # flake8-print
    "TCH",   # flake8-type-checking
    "TID",   # flake8-tidy-imports
    "UP",    # pyupgrade
    "W",     # pycodestyle warnings
    "YTT"    # flake8-2020
]

ignore = [
    "ARG001",  # Unused function argument
    "E501",    # Line too long
    "I001",    # Import block formatting
    "RUF001",  # String formatting
    "PLR2004", # Magic numbers
    "EXE003",  # Shebang formatting
    "ISC001",  # Implicit string concatenation
    "B027",    # Empty method in abstract base class
    "C901",    # Function complexity
    "FBT003",  # Boolean positional args
    "PLR0911", # Too many returns
    "PLR0912", # Too many branches
    "PLR0913", # Too many arguments
    "PLR0915", # Too many statements
    "PLW0603", # Global statement usage
    "S105",    # Possible hardcoded password
    "S106",    # Possible hardcoded password
    "S107",    # Possible hardcoded password
    "SIM102"   # Nested if statements
]

unfixable = ["F401"]  # Don't remove unused imports automatically

[tool.ruff.lint.isort]
known-first-party = ["twat_os"]

[tool.ruff.lint.flake8-tidy-imports]
ban-relative-imports = "all"

[tool.ruff.lint.per-file-ignores]
"tests/*" = ["S101", "PLR2004", "TID252"]

#------------------------------------------------------------------------------
# PYTEST CONFIGURATION
# Configuration for pytest testing framework.
#------------------------------------------------------------------------------
[tool.pytest.ini_options]
addopts = "-v --durations=10 -p no:briefcase"
asyncio_mode = "auto"
console_output_style = "progress"
filterwarnings = [
    "ignore::DeprecationWarning",
    "ignore::UserWarning"
]
log_cli = true
log_cli_level = "INFO"
markers = [
    "benchmark: marks tests as benchmarks (select with '-m benchmark')",
    "unit: mark a test as a unit test",
    "integration: mark a test as an integration test",
    "permutation: tests for permutation functionality",
    "parameter: tests for parameter parsing",
    "prompt: tests for prompt parsing"
]
norecursedirs = [
    ".*",
    "build",
    "dist",
    "venv",
    "__pycache__",
    "*.egg-info",
    "_private"
]
python_classes = ["Test*"]
python_files = ["test_*.py"]
python_functions = ["test_*"]
testpaths = ["tests"]

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",    # Minimum time
    "max",    # Maximum time
    "mean",   # Mean time
    "stddev", # Standard deviation
    "median", # Median time
    "iqr",    # Inter-quartile range
    "ops",    # Operations per second
    "rounds"  # Number of rounds
]
```

## VERSION.txt

```text
v2.7.5
```

## tests/test_package.py

```python
"""Test suite for twat_os."""


def test_version():
    """Verify package exposes version."""
    import twat_os

    assert twat_os.__version__
```

## .github/workflows/release.yml

```yaml
name: Release

on:
  push:
    tags: ["v*"]

permissions:
  contents: write
  id-token: write

jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/twat-os
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

## .github/workflows/push.yml

```yaml
name: Build & Test

on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"

      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"

  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}

      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"

      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/twat_os --cov=tests tests/

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml

  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5
```

## .cursor/rules/cleanup.mdc

```text
---
description: Run `cleanup.py` script before and after changes
globs:
---
Before you do any changes or if I say "cleanup", run the `cleanup.py update` script in the main folder. Analyze the results, describe recent changes in @LOG.md and edit @TODO.md to update priorities and plan next changes. PERFORM THE CHANGES, then run the `cleanup.py status` script and react to the results.

When you edit @TODO.md, lead in lines with empty GFM checkboxes if things aren't done (`- [ ] `) vs. filled (`- [x] `) if done.
```

## .cursor/rules/0project.mdc

```text
---
description: About this project
globs:
---
# About this project

`twat-fs` is a file system utility library focused on robust and extensible file upload capabilities with multiple provider support. It provides:

- Multi-provider upload system with smart fallback (catbox.moe default, plus Dropbox, S3, etc.)
- Automatic retry for temporary failures, fallback for permanent ones
- URL validation and clean developer experience with type hints
- Simple CLI: `python -m twat_fs upload_file path/to/file.txt`
- Easy installation: `uv pip install twat-fs` (basic) or `uv pip install 'twat-fs[all,dev]'` (all features)

## Development Notes
- Uses `uv` for Python package management
- Quality tools: ruff, mypy, pytest
- Clear provider protocol for adding new storage backends
- Strong typing and runtime checks throughout
```

## .cursor/rules/filetree.mdc

```text
---
description: File tree of the project
globs:
---
[ 736]  .
├── [  64]  .benchmarks
├── [  96]  .cursor
│   └── [ 224]  rules
│       ├── [ 821]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.0K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [  96]  .github
│   └── [ 128]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.0K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [   7]  VERSION.txt
├── [ 13K]  cleanup.py
├── [ 192]  dist
│   └── [   1]  .gitkeep
├── [5.6K]  pyproject.toml
├── [  96]  src
│   └── [ 224]  twat_os
│       ├── [  95]  __init__.py
│       ├── [7.4K]  paths.py
│       └── [1.0K]  paths.toml
└── [ 128]  tests
    └── [ 145]  test_package.py

10 directories, 20 files
```

## .cursor/rules/quality.mdc

```text
---
description: Quality
globs:
---
- **Verify Information**: Always verify information before presenting it. Do not make assumptions or speculate without clear evidence.
- **No Apologies**: Never use apologies.
- **No Whitespace Suggestions**: Don't suggest whitespace changes.
- **No Inventions**: Don't invent major changes other than what's explicitly requested.
- **No Unnecessary Confirmations**: Don't ask for confirmation of information already provided in the context.
- **Preserve Existing Code**: Don't remove unrelated code or functionalities. Pay attention to preserving existing structures.
- **No Implementation Checks**: Don't ask the user to verify implementations that are visible in the provided context.
- **No Unnecessary Updates**: Don't suggest updates or changes to files when there are no actual modifications needed.
- **No Current Implementation**: Don't show or discuss the current implementation unless specifically requested.
- **Use Explicit Variable Names**: Prefer descriptive, explicit variable names over short, ambiguous ones to enhance code readability.
- **Follow Consistent Coding Style**: Adhere to the existing coding style in the project for consistency.
- **Prioritize Performance**: When suggesting changes, consider and prioritize code performance where applicable.
- **Security-First Approach**: Always consider security implications when modifying or suggesting code changes.
- **Test Coverage**: Suggest or include appropriate unit tests for new or modified code.
- **Error Handling**: Implement robust error handling and logging where necessary.
- **Modular Design**: Encourage modular design principles to improve code maintainability and reusability.
- **Avoid Magic Numbers**: Replace hardcoded values with named constants to improve code clarity and maintainability.
- **Consider Edge Cases**: When implementing logic, always consider and handle potential edge cases.
- **Use Assertions**: Include assertions wherever possible to validate assumptions and catch potential errors early.
```

## README.md

````markdown
#



## Features

- Plugin for twat
- Modern Python packaging with PEP 621 compliance
- Type hints and runtime type checking
- Comprehensive test suite and documentation
- CI/CD ready configuration

## Installation

```bash
pip install twat-os
```

## Usage

```python
import twat_os
plugin = twat_os.plugin
```

## Development

This project uses [Hatch](https://hatch.pypa.io/) for development workflow management.

### Setup Development Environment

```bash
# Install hatch if you haven't already
pip install hatch

# Create and activate development environment
hatch shell

# Run tests
hatch run test

# Run tests with coverage
hatch run test-cov

# Run linting
hatch run lint

# Format code
hatch run format
```

## License

MIT License
````

## LICENSE

```text
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## .gitignore

```text
*_autogen/
.DS_Store
__version__.py
__pycache__/
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
!?*.[Cc]ache/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!**/[Pp]ackages/build/
!Directory.Build.rsp
.*crunch*.local.xml
.axoCover/*
.builds
.cr/personal
.fake/
.history/
.ionide/
.localhistory/
.mfractor/
.ntvs_analysis.dat
.paket/paket.exe
.sass-cache/
.vs/
.vscode
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim_*.settings
*.bim.layout
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
**/[Pp]ackages/*
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
*~
~$*
$tf/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
coverage*.info
coverage*.json
coverage*.xml
csx/
CTestTestfile.cmake
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
ecf/
FakesAssemblies/
FodyWeavers.xsd
Generated_Code/
Generated\ Files/
healthchecksdb
install_manifest.txt
ipch/
Makefile
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
UpgradeLog*.htm
UpgradeLog*.XML
x64/
x86/
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Distribution / packaging
!dist/.gitkeep

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
.ruff_cache/

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Project specific
__version__.py
_private
```

## .pre-commit-config.yaml

```yaml
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]
```

## REPO_CONTENT.txt

````text
This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix. The content has been processed where empty lines have been removed.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: .specstory/**/*.md, .venv/**, _private/**, CLEANUP.txt, **/*.json, *.lock
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.cursor/
  rules/
    0project.mdc
    cleanup.mdc
    filetree.mdc
    quality.mdc
.github/
  workflows/
    push.yml
    release.yml
src/
  twat_os/
    __init__.py
    paths.py
    paths.toml
tests/
  test_package.py
.gitignore
.pre-commit-config.yaml
cleanup.py
LICENSE
pyproject.toml
README.md
VERSION.txt

================================================================
Files
================================================================

================
File: .cursor/rules/0project.mdc
================
---
description: About this project
globs:
---
# About this project

`twat-fs` is a file system utility library focused on robust and extensible file upload capabilities with multiple provider support. It provides:

- Multi-provider upload system with smart fallback (catbox.moe default, plus Dropbox, S3, etc.)
- Automatic retry for temporary failures, fallback for permanent ones
- URL validation and clean developer experience with type hints
- Simple CLI: `python -m twat_fs upload_file path/to/file.txt`
- Easy installation: `uv pip install twat-fs` (basic) or `uv pip install 'twat-fs[all,dev]'` (all features)

## Development Notes
- Uses `uv` for Python package management
- Quality tools: ruff, mypy, pytest
- Clear provider protocol for adding new storage backends
- Strong typing and runtime checks throughout

================
File: .cursor/rules/cleanup.mdc
================
---
description: Run `cleanup.py` script before and after changes
globs:
---
Before you do any changes or if I say "cleanup", run the `cleanup.py update` script in the main folder. Analyze the results, describe recent changes in @LOG.md and edit @TODO.md to update priorities and plan next changes. PERFORM THE CHANGES, then run the `cleanup.py status` script and react to the results.

When you edit @TODO.md, lead in lines with empty GFM checkboxes if things aren't done (`- [ ] `) vs. filled (`- [x] `) if done.

================
File: .cursor/rules/filetree.mdc
================
---
description: File tree of the project
globs:
---
[ 736]  .
├── [  64]  .benchmarks
├── [  96]  .cursor
│   └── [ 224]  rules
│       ├── [ 821]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.0K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [  96]  .github
│   └── [ 128]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.0K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [   7]  VERSION.txt
├── [ 13K]  cleanup.py
├── [ 192]  dist
│   └── [   1]  .gitkeep
├── [5.6K]  pyproject.toml
├── [  96]  src
│   └── [ 224]  twat_os
│       ├── [  95]  __init__.py
│       ├── [7.4K]  paths.py
│       └── [1.0K]  paths.toml
└── [ 128]  tests
    └── [ 145]  test_package.py

10 directories, 20 files

================
File: .cursor/rules/quality.mdc
================
---
description: Quality
globs:
---
- **Verify Information**: Always verify information before presenting it. Do not make assumptions or speculate without clear evidence.
- **No Apologies**: Never use apologies.
- **No Whitespace Suggestions**: Don't suggest whitespace changes.
- **No Inventions**: Don't invent major changes other than what's explicitly requested.
- **No Unnecessary Confirmations**: Don't ask for confirmation of information already provided in the context.
- **Preserve Existing Code**: Don't remove unrelated code or functionalities. Pay attention to preserving existing structures.
- **No Implementation Checks**: Don't ask the user to verify implementations that are visible in the provided context.
- **No Unnecessary Updates**: Don't suggest updates or changes to files when there are no actual modifications needed.
- **No Current Implementation**: Don't show or discuss the current implementation unless specifically requested.
- **Use Explicit Variable Names**: Prefer descriptive, explicit variable names over short, ambiguous ones to enhance code readability.
- **Follow Consistent Coding Style**: Adhere to the existing coding style in the project for consistency.
- **Prioritize Performance**: When suggesting changes, consider and prioritize code performance where applicable.
- **Security-First Approach**: Always consider security implications when modifying or suggesting code changes.
- **Test Coverage**: Suggest or include appropriate unit tests for new or modified code.
- **Error Handling**: Implement robust error handling and logging where necessary.
- **Modular Design**: Encourage modular design principles to improve code maintainability and reusability.
- **Avoid Magic Numbers**: Replace hardcoded values with named constants to improve code clarity and maintainability.
- **Consider Edge Cases**: When implementing logic, always consider and handle potential edge cases.
- **Use Assertions**: Include assertions wherever possible to validate assumptions and catch potential errors early.

================
File: .github/workflows/push.yml
================
name: Build & Test
on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:
permissions:
  contents: write
  id-token: write
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true
jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"
      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"
  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}
      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"
      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/twat_os --cov=tests tests/
      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml
  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true
      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs
      - name: Build distributions
        run: uv run python -m build --outdir dist
      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5

================
File: .github/workflows/release.yml
================
name: Release
on:
  push:
    tags: ["v*"]
permissions:
  contents: write
  id-token: write
jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/twat-os
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true
      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs
      - name: Build distributions
        run: uv run python -m build --outdir dist
      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)
      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

================
File: src/twat_os/__init__.py
================
__version__ = metadata.version(__name__)

================
File: src/twat_os/paths.py
================
PATHS_TOML = Path(__file__).parent / "paths.toml"
DEFAULT_PATHS = tomli.loads(PATHS_TOML.read_text())
class PathConfig(BaseModel):
    @field_validator("base_dir", "package_dir")
    def expand_path(cls, v: str | Path | None) -> Path | None:
        if isinstance(v, str):
            expanded = os.path.expandvars(os.path.expanduser(v))
            return Path(expanded)
    @model_validator(mode="after")
    def validate_and_create_dirs(self) -> Self:
            self.base_dir.mkdir(parents=True, exist_ok=True)
                self.package_dir.mkdir(parents=True, exist_ok=True)
class CacheConfig(PathConfig):
    base_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_cache_dir()) / "twat"
class ConfigDirConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_config_dir()) / "twat"
class DataDirConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat"
class TempDirConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_runtime_dir()) / "twat"
class GenAIConfig(PathConfig):
    lora_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/loras"
    model_dir: Path = Field(
        default_factory=lambda: Path(platformdirs.user_data_dir()) / "twat/genai/models"
    output_dir: Path = Field(
        default_factory=lambda: Path.home() / "Pictures/twat_genai"
    def validate_and_create_all_dirs(self) -> Self:
            self.lora_dir.mkdir(parents=True, exist_ok=True)
            self.model_dir.mkdir(parents=True, exist_ok=True)
            self.output_dir.mkdir(parents=True, exist_ok=True)
class LogConfig(PathConfig):
        default_factory=lambda: Path(platformdirs.user_state_dir()) / "twat/logs"
class PathManager:
    def __init__(
            config_path = Path(config_file)
            if not config_path.exists():
                raise FileNotFoundError(msg)
            self.config = tomli.loads(config_path.read_text())
        self._init_paths()
    def _init_paths(self) -> None:
        def format_path(path_str: str) -> Path | None:
            expanded = os.path.expandvars(os.path.expanduser(path_str))
            return Path(expanded.format(package_name=self.package_name))
        self.cache = CacheConfig(
            package_dir=format_path(self.config["cache"]["package_dir"]),
        self.config_dir = ConfigDirConfig(
            package_dir=format_path(self.config["config"]["package_dir"]),
        self.data = DataDirConfig(
            package_dir=format_path(self.config["data"]["package_dir"]),
        self.temp = TempDirConfig(
            package_dir=format_path(self.config["temp"]["package_dir"]),
        self.genai = GenAIConfig(
        self.logs = LogConfig(
            package_dir=format_path(self.config["logs"]["package_dir"]),
    def get_path(self, category: str, key: str = "base_dir") -> Path:
        config = getattr(self, category)
        return getattr(config, key)
    def for_package(
        return cls(package_name=package_name, config_file=config_file)
    def __repr__(self) -> str:

================
File: src/twat_os/paths.toml
================
[cache]
# Base directory for all cache operations
base_dir = "~/.cache/twat"
# Directory for storing package-specific cache data
package_dir = "~/.cache/twat/{package_name}"

[config]
# Base directory for configuration files
base_dir = "~/.config/twat"
# Directory for package-specific configuration
package_dir = "~/.config/twat/{package_name}"

[data]
# Base directory for user data
base_dir = "~/.local/share/twat"
# Directory for package-specific data
package_dir = "~/.local/share/twat/{package_name}"

[temp]
# Base directory for temporary files
base_dir = "~/tmp/twat"
# Directory for package-specific temporary files
package_dir = "~/tmp/twat/{package_name}"

[genai]
# Directory for storing LoRA files
lora_dir = "~/.local/share/twat/genai/loras"
# Directory for model weights
model_dir = "~/.local/share/twat/genai/models"
# Directory for generated images
output_dir = "~/Pictures/twat_genai"

[logs]
# Base directory for log files
base_dir = "~/.local/state/twat/logs"
# Directory for package-specific logs
package_dir = "~/.local/state/twat/logs/{package_name}"

================
File: tests/test_package.py
================
def test_version():

================
File: .gitignore
================
*_autogen/
.DS_Store
__version__.py
__pycache__/
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
!?*.[Cc]ache/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!**/[Pp]ackages/build/
!Directory.Build.rsp
.*crunch*.local.xml
.axoCover/*
.builds
.cr/personal
.fake/
.history/
.ionide/
.localhistory/
.mfractor/
.ntvs_analysis.dat
.paket/paket.exe
.sass-cache/
.vs/
.vscode
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim_*.settings
*.bim.layout
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
**/[Pp]ackages/*
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
*~
~$*
$tf/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
coverage*.info
coverage*.json
coverage*.xml
csx/
CTestTestfile.cmake
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
ecf/
FakesAssemblies/
FodyWeavers.xsd
Generated_Code/
Generated\ Files/
healthchecksdb
install_manifest.txt
ipch/
Makefile
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
UpgradeLog*.htm
UpgradeLog*.XML
x64/
x86/
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Distribution / packaging
!dist/.gitkeep

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/
.ruff_cache/

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Project specific
__version__.py
_private

================
File: .pre-commit-config.yaml
================
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]

================
File: cleanup.py
================
LOG_FILE = Path("CLEANUP.txt")
os.chdir(Path(__file__).parent)
def new() -> None:
    if LOG_FILE.exists():
        LOG_FILE.unlink()
def prefix() -> None:
    readme = Path(".cursor/rules/0project.mdc")
    if readme.exists():
        log_message("\n=== PROJECT STATEMENT ===")
        content = readme.read_text()
        log_message(content)
def suffix() -> None:
    todo = Path("TODO.md")
    if todo.exists():
        log_message("\n=== TODO.md ===")
        content = todo.read_text()
def log_message(message: str) -> None:
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
    with LOG_FILE.open("a") as f:
        f.write(log_line)
def run_command(cmd: list[str], check: bool = True) -> subprocess.CompletedProcess:
        result = subprocess.run(
            log_message(result.stdout)
        log_message(f"Command failed: {' '.join(cmd)}")
        log_message(f"Error: {e.stderr}")
        return subprocess.CompletedProcess(cmd, 1, "", str(e))
def check_command_exists(cmd: str) -> bool:
        return which(cmd) is not None
class Cleanup:
    def __init__(self) -> None:
        self.workspace = Path.cwd()
    def _print_header(self, message: str) -> None:
        log_message(f"\n=== {message} ===")
    def _check_required_files(self) -> bool:
            if not (self.workspace / file).exists():
                log_message(f"Error: {file} is missing")
    def _generate_tree(self) -> None:
        if not check_command_exists("tree"):
            log_message("Warning: 'tree' command not found. Skipping tree generation.")
            rules_dir = Path(".cursor/rules")
            rules_dir.mkdir(parents=True, exist_ok=True)
            tree_result = run_command(["tree", "-a", "-I", ".git", "--gitignore", "-n", "-h", "-I", "*_cache"])
            with open(rules_dir / "filetree.mdc", "w") as f:
                f.write("---\ndescription: File tree of the project\nglobs: \n---\n")
                f.write(tree_text)
            log_message("\nProject structure:")
            log_message(tree_text)
            log_message(f"Failed to generate tree: {e}")
    def _git_status(self) -> bool:
        result = run_command(["git", "status", "--porcelain"], check=False)
        return bool(result.stdout.strip())
    def _venv(self) -> None:
        log_message("Setting up virtual environment")
            run_command(["uv", "venv"])
            if venv_path.exists():
                os.environ["VIRTUAL_ENV"] = str(self.workspace / ".venv")
                log_message("Virtual environment created and activated")
                log_message("Virtual environment created but activation failed")
            log_message(f"Failed to create virtual environment: {e}")
    def _install(self) -> None:
        log_message("Installing package with all extras")
            self._venv()
            run_command(["uv", "pip", "install", "-e", ".[test,dev]"])
            log_message("Package installed successfully")
            log_message(f"Failed to install package: {e}")
    def _run_checks(self) -> None:
        log_message("Running code quality checks")
            log_message(">>> Running code fixes...")
            run_command(
            log_message(">>>Running type checks...")
            run_command(["python", "-m", "mypy", "src", "tests"], check=False)
            log_message(">>> Running tests...")
            run_command(["python", "-m", "pytest", "tests"], check=False)
            log_message("All checks completed")
            log_message(f"Failed during checks: {e}")
    def status(self) -> None:
        prefix()  # Add README.md content at start
        self._print_header("Current Status")
        self._check_required_files()
        self._generate_tree()
        result = run_command(["git", "status"], check=False)
        self._print_header("Environment Status")
        self._install()
        self._run_checks()
        suffix()  # Add TODO.md content at end
    def venv(self) -> None:
        self._print_header("Virtual Environment Setup")
    def install(self) -> None:
        self._print_header("Package Installation")
    def update(self) -> None:
        self.status()
        if self._git_status():
            log_message("Changes detected in repository")
                run_command(["git", "add", "."])
                run_command(["git", "commit", "-m", commit_msg])
                log_message("Changes committed successfully")
                log_message(f"Failed to commit changes: {e}")
            log_message("No changes to commit")
    def push(self) -> None:
        self._print_header("Pushing Changes")
            run_command(["git", "push"])
            log_message("Changes pushed successfully")
            log_message(f"Failed to push changes: {e}")
def repomix(
            cmd.append("--compress")
            cmd.append("--remove-empty-lines")
            cmd.append("-i")
            cmd.append(ignore_patterns)
        cmd.extend(["-o", output_file])
        run_command(cmd)
        log_message(f"Repository content mixed into {output_file}")
        log_message(f"Failed to mix repository: {e}")
def print_usage() -> None:
    log_message("Usage:")
    log_message("  cleanup.py status   # Show current status and run all checks")
    log_message("  cleanup.py venv     # Create virtual environment")
    log_message("  cleanup.py install  # Install package with all extras")
    log_message("  cleanup.py update   # Update and commit changes")
    log_message("  cleanup.py push     # Push changes to remote")
def main() -> NoReturn:
    new()  # Clear log file
    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)
    cleanup = Cleanup()
            cleanup.status()
            cleanup.venv()
            cleanup.install()
            cleanup.update()
            cleanup.push()
        log_message(f"Error: {e}")
    repomix()
    sys.stdout.write(Path("CLEANUP.txt").read_text())
    sys.exit(0)  # Ensure we exit with a status code
    main()

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: pyproject.toml
================
# this_file: pyproject.toml
# this_project: twat_os
[project]
name = "twat-os"
dynamic = ["version"]
description = "Operating system utilities for twat"
readme = "README.md"
requires-python = ">=3.10"
license = "MIT"
keywords = [
    "os",
    "system",
    "twat"
]
classifiers = [
    "Development Status :: 4 - Beta",
    "Programming Language :: Python",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
]

dependencies = [
    "fire>=0.6.0",
    "loguru>=0.7.2",
    "twat>=1.8.1"
]

[project.optional-dependencies]
dev = [
    "hatch>=1.14.0",
    "hatchling>=1.27.0",
    "hatch-vcs>=0.4.0",
    "mypy>=1.15.0",
    "pre-commit>=4.1.0",
    "pyupgrade>=3.19.1",
    "ruff>=0.9.6"
]

test = [
    "pytest>=8.3.4",
    "pytest-cov>=6.0.0",
    "pytest-benchmark>=5.1.0",
    "pytest-mock>=3.14.0",
    "pytest-asyncio>=0.25.3",
    "pytest-timeout>=2.3.1"
]

all = [
    "fire>=0.6.0",
    "loguru>=0.7.2",
    "twat>=1.8.1"
]

[project.scripts]
twat-os = "twat_os.__main__:main"

[project.entry-points."twat.plugins"]
os = "twat_os"

[[project.authors]]
name = "Adam Twardoch"
email = "adam+github@twardoch.com"

[project.urls]
Documentation = "https://github.com/twardoch/twat-os#readme"
Issues = "https://github.com/twardoch/twat-os/issues"
Source = "https://github.com/twardoch/twat-os"

[build-system]
build-backend = "hatchling.build"
requires = [
    "hatchling>=1.27.0",
    "hatch-vcs>=0.4.0"
]

[tool.coverage.paths]
twat_os = ["src/twat_os", "*/twat-os/src/twat_os"]
tests = ["tests", "*/twat-os/tests"]

[tool.coverage.report]
exclude_lines = [
    "no cov",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:"
]

[tool.coverage.run]
source_pkgs = ["twat_os", "tests"]
branch = true
parallel = true
omit = ["src/twat_os/__about__.py"]

[tool.hatch.build.hooks.vcs]
version-file = "src/twat_os/__version__.py"

[tool.hatch.build.targets.wheel]
packages = ["src/twat_os"]
include = [
    "src/twat_os/**/*.py",
    "src/twat_os/py.typed"
]

[tool.hatch.envs.default]
dependencies = [
    "pytest>=8.3.4",
    "pytest-cov>=6.0.0",
    "ruff>=0.9.6",
    "mypy>=1.15.0"
]

[tool.hatch.envs.default.scripts]
test = "pytest {args:tests}"
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
type-check = "mypy src/twat_os tests"
lint = ["ruff check src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]
fix = ["ruff check --fix --unsafe-fixes src/twat_os tests", "ruff format --respect-gitignore src/twat_os tests"]

[[tool.hatch.envs.all.matrix]]
python = ["3.10", "3.11", "3.12"]

[tool.hatch.envs.lint]
detached = true
dependencies = [
    "pytest>=8.3.4",
    "pytest-cov>=6.0.0",
    "ruff>=0.9.6",
    "mypy>=1.15.0"
]

[tool.hatch.envs.lint.scripts]
typing = "mypy --install-types --non-interactive {args:src/twat_os tests}"
style = ["ruff check {args:.}", "ruff format --respect-gitignore {args:.}"]
fmt = ["ruff format --respect-gitignore {args:.}", "ruff check --fix {args:.}"]
all = ["style", "typing"]

[tool.hatch.envs.test]
dependencies = []

[tool.hatch.envs.test.scripts]
test = "python -m pytest -n auto -p no:briefcase {args:tests}"
test-cov = "python -m pytest -n auto -p no:briefcase --cov-report=term-missing --cov-config=pyproject.toml --cov=src/twat_os --cov=tests {args:tests}"
bench = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only"
bench-save = "python -m pytest -v -p no:briefcase tests/test_benchmark.py --benchmark-only --benchmark-json=benchmark/results.json"

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
version_scheme = "post-release"

[tool.mypy]
python_version = "3.10"
check_untyped_defs = true
disallow_incomplete_defs = true
disallow_untyped_decorators = true
disallow_untyped_defs = true
no_implicit_optional = true
warn_no_return = true
warn_redundant_casts = true
warn_return_any = true
warn_unreachable = true
warn_unused_configs = true
warn_unused_ignores = true

[tool.ruff]
line-length = 88
target-version = "py310"

[tool.ruff.lint]
extend-select = [
    "A",
    "ARG",
    "B",
    "C",
    "DTZ",
    "E",
    "EM",
    "F",
    "FBT",
    "I",
    "ICN",
    "ISC",
    "N",
    "PLC",
    "PLE",
    "PLR",
    "PLW",
    "Q",
    "RUF",
    "S",
    "T",
    "TID",
    "UP",
    "W",
    "YTT"
]
ignore = [
    "ARG001",
    "E501",
    "I001",
    "RUF001",
    "PLR2004",
    "EXE003",
    "ISC001"
]

[tool.ruff.per-file-ignores]
"tests/*" = ["S101"]

[tool.pytest.ini_options]
addopts = "-v --durations=10 -p no:briefcase"
asyncio_mode = "auto"
console_output_style = "progress"
filterwarnings = [
    "ignore::DeprecationWarning",
    "ignore::UserWarning"
]
log_cli = true
log_cli_level = "INFO"
markers = [
    "benchmark: marks tests as benchmarks (select with '-m benchmark')",
    "unit: mark a test as a unit test",
    "integration: mark a test as an integration test",
    "permutation: tests for permutation functionality",
    "parameter: tests for parameter parsing",
    "prompt: tests for prompt parsing"
]
norecursedirs = [
    ".*",
    "build",
    "dist",
    "venv",
    "__pycache__",
    "*.egg-info",
    "_private"
]
python_classes = ["Test*"]
python_files = ["test_*.py"]
python_functions = ["test_*"]
testpaths = ["tests"]

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",
    "max",
    "mean",
    "stddev",
    "median",
    "iqr",
    "ops",
    "rounds"
]

================
File: README.md
================
#



## Features

- Plugin for twat
- Modern Python packaging with PEP 621 compliance
- Type hints and runtime type checking
- Comprehensive test suite and documentation
- CI/CD ready configuration

## Installation

```bash
pip install twat-os
```

## Usage

```python
import twat_os
plugin = twat_os.plugin
```

## Development

This project uses [Hatch](https://hatch.pypa.io/) for development workflow management.

### Setup Development Environment

```bash
# Install hatch if you haven't already
pip install hatch

# Create and activate development environment
hatch shell

# Run tests
hatch run test

# Run tests with coverage
hatch run test-cov

# Run linting
hatch run lint

# Format code
hatch run format
```

## License

MIT License

================
File: VERSION.txt
================
v2.6.2



================================================================
End of Codebase
================================================================
````

## CLEANUP.txt

```text
2025-03-05 12:14:24 -
=== PROJECT STATEMENT ===
2025-03-05 12:14:24 - ---
description: About this project
globs:
---
# About this project

`twat-fs` is a file system utility library focused on robust and extensible file upload capabilities with multiple provider support. It provides:

- Multi-provider upload system with smart fallback (catbox.moe default, plus Dropbox, S3, etc.)
- Automatic retry for temporary failures, fallback for permanent ones
- URL validation and clean developer experience with type hints
- Simple CLI: `python -m twat_fs upload_file path/to/file.txt`
- Easy installation: `uv pip install twat-fs` (basic) or `uv pip install 'twat-fs[all,dev]'` (all features)

## Development Notes
- Uses `uv` for Python package management
- Quality tools: ruff, mypy, pytest
- Clear provider protocol for adding new storage backends
- Strong typing and runtime checks throughout

2025-03-05 12:14:24 -
=== Current Status ===
2025-03-05 12:14:24 - Error: LOG.md is missing
2025-03-05 12:14:24 - Error: TODO.md is missing
2025-03-05 12:14:24 - [ 736]  .
├── [  64]  .benchmarks
├── [  96]  .cursor
│   └── [ 224]  rules
│       ├── [ 821]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.0K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [  96]  .github
│   └── [ 128]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.0K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [   7]  VERSION.txt
├── [ 13K]  cleanup.py
├── [ 192]  dist
│   └── [   1]  .gitkeep
├── [5.6K]  pyproject.toml
├── [  96]  src
│   └── [ 224]  twat_os
│       ├── [  95]  __init__.py
│       ├── [7.4K]  paths.py
│       └── [1.0K]  paths.toml
└── [ 128]  tests
    └── [ 145]  test_package.py

10 directories, 20 files

2025-03-05 12:14:24 -
Project structure:
2025-03-05 12:14:24 - [ 736]  .
├── [  64]  .benchmarks
├── [  96]  .cursor
│   └── [ 224]  rules
│       ├── [ 821]  0project.mdc
│       ├── [ 516]  cleanup.mdc
│       ├── [1.0K]  filetree.mdc
│       └── [2.0K]  quality.mdc
├── [  96]  .github
│   └── [ 128]  workflows
│       ├── [2.7K]  push.yml
│       └── [1.4K]  release.yml
├── [3.5K]  .gitignore
├── [ 470]  .pre-commit-config.yaml
├── [1.0K]  CLEANUP.txt
├── [1.0K]  LICENSE
├── [ 742]  README.md
├── [ 33K]  REPO_CONTENT.txt
├── [   7]  VERSION.txt
├── [ 13K]  cleanup.py
├── [ 192]  dist
│   └── [   1]  .gitkeep
├── [5.6K]  pyproject.toml
├── [  96]  src
│   └── [ 224]  twat_os
│       ├── [  95]  __init__.py
│       ├── [7.4K]  paths.py
│       └── [1.0K]  paths.toml
└── [ 128]  tests
    └── [ 145]  test_package.py

10 directories, 20 files

2025-03-05 12:14:24 - On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   .cursor/rules/filetree.mdc
	modified:   CLEANUP.txt

no changes added to commit (use "git add" and/or "git commit -a")

2025-03-05 12:14:24 - On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   .cursor/rules/filetree.mdc
	modified:   CLEANUP.txt

no changes added to commit (use "git add" and/or "git commit -a")

2025-03-05 12:14:24 -
=== Environment Status ===
2025-03-05 12:14:24 - Setting up virtual environment
2025-03-05 12:14:27 - Virtual environment created and activated
2025-03-05 12:14:27 - Installing package with all extras
2025-03-05 12:14:27 - Setting up virtual environment
2025-03-05 12:14:27 - Virtual environment created and activated
2025-03-05 12:14:30 - Package installed successfully
2025-03-05 12:14:30 - Running code quality checks
2025-03-05 12:14:30 - >>> Running code fixes...
2025-03-05 12:14:30 - src/twat_os/paths.py:126:9: FBT001 Boolean-typed positional argument in function definition
    |
124 |         package_name: str | None = None,
125 |         config_file: str | Path | None = None,
126 |         create_dirs: bool = True,
    |         ^^^^^^^^^^^ FBT001
127 |     ) -> None:
128 |         """Initialize path manager.
    |

src/twat_os/paths.py:126:9: FBT002 Boolean default positional argument in function definition
    |
124 |         package_name: str | None = None,
125 |         config_file: str | Path | None = None,
126 |         create_dirs: bool = True,
    |         ^^^^^^^^^^^ FBT002
127 |     ) -> None:
128 |         """Initialize path manager.
    |

Found 2 errors.

2025-03-05 12:14:30 - 3 files left unchanged

2025-03-05 12:14:30 - >>>Running type checks...
2025-03-05 12:14:32 - tests/test_package.py:4: error: Function is missing a return type annotation  [no-untyped-def]
tests/test_package.py:4: note: Use "-> None" if function does not return a value
src/twat_os/paths.py:15: error: Module "typing" has no attribute "Self"  [attr-defined]
src/twat_os/paths.py:15: note: Use `from typing_extensions import Self` instead
src/twat_os/paths.py:15: note: See https://mypy.readthedocs.io/en/stable/runtime_troubles.html#using-new-additions-to-the-typing-module
src/twat_os/paths.py:214: error: Returning Any from function declared to return "Path"  [no-any-return]
Found 3 errors in 2 files (checked 4 source files)

2025-03-05 12:14:32 - >>> Running tests...
2025-03-05 12:14:35 - ============================= test session starts ==============================
platform darwin -- Python 3.12.8, pytest-8.3.5, pluggy-1.5.0 -- /Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_os/.venv/bin/python
cachedir: .pytest_cache
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/_good/twat/plugins/repos/twat_os
configfile: pyproject.toml
plugins: cov-6.0.0, asyncio-0.25.3, anyio-4.8.0, benchmark-5.1.0, timeout-2.3.1, mock-3.14.0
asyncio: mode=Mode.AUTO, asyncio_default_fixture_loop_scope=None
collecting ... collected 1 item

tests/test_package.py::test_version PASSED                               [100%]

============================= slowest 10 durations =============================
0.01s call     tests/test_package.py::test_version

(2 durations < 0.005s hidden.  Use -vv to show these durations.)
============================== 1 passed in 0.05s ===============================

2025-03-05 12:14:35 - All checks completed
2025-03-05 12:14:38 -
📦 Repomix v0.2.29

No custom config found at repomix.config.json or global config at /Users/adam/.config/repomix/repomix.config.json.
You can add a config file for additional settings. Please check https://github.com/yamadashy/repomix for more information.
⠙ Searching for files...
[2K[1A[2K[G⠹ Collecting files...
[2K[1A[2K[G⠸ Collecting files...
[2K[1A[2K[G⠼ Collecting files...
[2K[1A[2K[G⠴ Running security check...
[2K[1A[2K[G⠦ Running security check...
[2K[1A[2K[G⠧ Processing files...
[2K[1A[2K[G⠇ Processing files...
[2K[1A[2K[G⠏ Processing files...
[2K[1A[2K[G⠋ Processing file... (8/17) src/twat_os/paths.py
[2K[1A[2K[G⠙ Calculating metrics...
[2K[1A[2K[G⠹ Calculating metrics...
[2K[1A[2K[G⠸ Calculating metrics...
[2K[1A[2K[G⠼ Calculating metrics...
[2K[1A[2K[G⠴ Calculating metrics...
[2K[1A[2K[G⠦ Calculating metrics...
[2K[1A[2K[G⠧ Calculating metrics...
[2K[1A[2K[G⠇ Calculating metrics...
[2K[1A[2K[G⠏ Calculating metrics...
[2K[1A[2K[G⠋ Calculating metrics...
[2K[1A[2K[G✔ Packing completed successfully!

📈 Top 5 Files by Character Count and Token Count:
──────────────────────────────────────────────────
1.  cleanup.py (5,977 chars, 1,344 tokens)
2.  pyproject.toml (5,700 chars, 1,837 tokens)
3.  .gitignore (3,633 chars, 1,391 tokens)
4.  src/twat_os/paths.py (3,107 chars, 688 tokens)
5.  .github/workflows/push.yml (2,743 chars, 708 tokens)

🔎 Security Check:
──────────────────
✔ No suspicious files detected.

📊 Pack Summary:
────────────────
  Total Files: 17 files
  Total Chars: 33,953 chars
 Total Tokens: 9,008 tokens
       Output: REPO_CONTENT.txt
     Security: ✔ No suspicious files detected

🎉 All Done!
Your repository has been successfully packed.

💡 Repomix is now available in your browser! Try it at https://repomix.com

2025-03-05 12:14:38 - Repository content mixed into REPO_CONTENT.txt
```

## Statistics

- Total Files: 19
- Total Characters: 90475
- Total Tokens: 0
`````

## Statistics

- Total Files: 23
- Total Characters: 182422
- Total Tokens: 0
``````

## Statistics

- Total Files: 23
- Total Characters: 274609
- Total Tokens: 0
```````

## Statistics

- Total Files: 23
- Total Characters: 366759
- Total Tokens: 0
````````

## Statistics

- Total Files: 23
- Total Characters: 459169
- Total Tokens: 0
`````````

## Statistics

- Total Files: 23
- Total Characters: 551561
- Total Tokens: 0
